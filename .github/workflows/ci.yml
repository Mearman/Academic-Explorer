name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run knip in dry-run mode (no PR creation)'
        required: false
        default: false
        type: boolean
  schedule:
    # Run knip analysis every Monday at 9:00 AM UTC
    - cron: '0 9 * * 1'

env:
  NODE_VERSION: 20.x
  PNPM_VERSION: 10.16.1

jobs:
  setup:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      cache-key: ${{ steps.cache-keys.outputs.cache-key }}
      nx-cache-key: ${{ steps.cache-keys.outputs.nx-cache-key }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Generate cache keys
        id: cache-keys
        run: |
          echo "cache-key=node-modules-${{ hashFiles('pnpm-lock.yaml') }}" >> $GITHUB_OUTPUT
          # Generate optimized Nx cache key with workspace hash
          WORKSPACE_HASH="$(echo '${{ hashFiles('nx.json', 'package.json', 'pnpm-lock.yaml', 'tsconfig*.json', 'vite.config.ts', 'vitest.workspace.ts', 'eslint.config.ts') }}')"
          echo "nx-cache-key=nx-v2-${{ runner.os }}-${WORKSPACE_HASH}" >> $GITHUB_OUTPUT
          echo "nx-workspace-key=nx-workspace-${{ runner.os }}-${{ github.ref_name }}-${WORKSPACE_HASH}" >> $GITHUB_OUTPUT

      - name: Cache node_modules
        id: cache-deps
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ steps.cache-keys.outputs.cache-key }}
          restore-keys: |
            node-modules-

      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: pnpm install --no-frozen-lockfile

      - name: Cache Nx workspace data
        uses: actions/cache@v4
        with:
          path: |
            .nx/workspace-data
            .nx/installation
          key: ${{ steps.cache-keys.outputs.nx-workspace-key }}
          restore-keys: |
            nx-workspace-${{ runner.os }}-${{ github.ref_name }}-
            nx-workspace-${{ runner.os }}-

      - name: Cache Nx task cache
        uses: actions/cache@v4
        with:
          path: .nx/cache
          key: ${{ steps.cache-keys.outputs.nx-cache-key }}-${{ github.run_id }}
          restore-keys: |
            ${{ steps.cache-keys.outputs.nx-cache-key }}-
            nx-v2-${{ runner.os }}-

  eslint-autofix:
    needs: setup
    runs-on: ubuntu-latest
    timeout-minutes: 10

    # Only run on push events and if commit doesn't contain [skip lint-fix]
    if: github.event_name == 'push' && !contains(github.event.head_commit.message, '[skip lint-fix]')

    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          fail-on-cache-miss: true

      - name: Run ESLint with auto-fix (stable mode)
        run: |
          echo "‚ú® Running ESLint auto-fix with stability optimizations..."

          # Ensure daemon is stopped
          pnpm nx daemon --stop 2>/dev/null || true

          # Run with timeout and error recovery
          if timeout 8m pnpm nx run-many -t lint:fix --parallel=1 --maxWorkers=1; then
            echo "‚úÖ ESLint auto-fix completed successfully"
          else
            echo "‚ö†Ô∏è  ESLint auto-fix encountered issues, trying fallback..."
            # Reset any corrupted cache and try again
            pnpm nx reset
            timeout 5m pnpm nx run-many -t lint:fix --parallel=1 --maxWorkers=1 || true
          fi
        env:
          NODE_OPTIONS: "--max-old-space-size=4096"
          NX_DAEMON: "false"
          NX_PARALLEL: "1"
          ESLINT_USE_FLAT_CONFIG: "true"
        continue-on-error: true

      - name: Check for changes
        id: verify-changed-files
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Files changed by ESLint auto-fix:"
            git status --porcelain
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No files were changed by ESLint auto-fix"
          fi

      - name: Configure Git
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Commit and push changes
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          git add .
          git commit -m "style: auto-fix ESLint issues [skip lint-fix]

          Automatically applied ESLint fixes via GitHub Actions.

          - Applied auto-fixable ESLint rules
          - Triggered by commit: ${{ github.event.head_commit.message }}
          - SHA: ${{ github.sha }}"
          git push

      - name: Summary
        run: |
          echo "## ESLint Auto-fix Summary" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.verify-changed-files.outputs.changed }}" == "true" ]; then
            echo "‚úÖ ESLint fixes were applied and committed" >> $GITHUB_STEP_SUMMARY
            echo "üìù Changes pushed to ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ÑπÔ∏è No ESLint fixes were needed" >> $GITHUB_STEP_SUMMARY
          fi

  quality-checks:
    needs: [setup, eslint-autofix]
    runs-on: ubuntu-latest
    timeout-minutes: 25

    # Skip if eslint-autofix was skipped, otherwise run always
    if: always() && (needs.eslint-autofix.result == 'success' || needs.eslint-autofix.result == 'skipped')

    strategy:
      fail-fast: false
      matrix:
        check: [lint, build, typecheck]
        include:
          - check: lint
            timeout: 8
            parallel: 1
          - check: build
            timeout: 12
            parallel: 2
          - check: typecheck
            timeout: 10
            parallel: 1

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Fetch latest changes if eslint-autofix made commits
          ref: ${{ github.ref }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          fail-on-cache-miss: true

      - name: Restore Nx cache
        uses: actions/cache/restore@v4
        with:
          path: .nx/cache
          key: ${{ needs.setup.outputs.nx-cache-key }}-${{ github.run_id }}
          restore-keys: |
            ${{ needs.setup.outputs.nx-cache-key }}-
            nx-stable-${{ runner.os }}-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Initialize Nx environment
        run: |
          echo "üîß Initializing Nx environment..."

          # Ensure daemon is stopped (CI should not use daemon)
          pnpm nx daemon --stop 2>/dev/null || true

          # Check and repair cache if needed
          if [ -d ".nx/cache" ]; then
            echo "Validating existing cache..."
            CACHE_SIZE=$(du -sh .nx/cache 2>/dev/null | cut -f1 || echo "0B")
            CACHE_FILES=$(find .nx/cache -type f 2>/dev/null | wc -l || echo "0")
            echo "  Cache size: $CACHE_SIZE (${CACHE_FILES} files)"

            # Simple corruption check
            if [ "$CACHE_FILES" -gt 10000 ]; then
              echo "‚ö†Ô∏è  Cache appears bloated, cleaning..."
              find .nx/cache -type f -mtime +7 -delete 2>/dev/null || true
            fi
          else
            echo "No existing cache found"
          fi

          # Verify Nx installation
          pnpm nx --version

      - name: Build core packages for typecheck
        if: matrix.check == 'typecheck'
        run: |
          echo "üèóÔ∏è  Building core packages for TypeScript compilation..."
          timeout 8m pnpm nx run-many -t build -p client,graph,utils,simulation --parallel=2
        env:
          NODE_OPTIONS: "--max-old-space-size=4096"
          NX_DAEMON: "false"

      - name: Run ${{ matrix.check }} with optimized settings
        run: |
          echo "üîß Configuring environment for ${{ matrix.check }}..."

          # Ensure clean state
          pnpm nx daemon --stop 2>/dev/null || true

          case "${{ matrix.check }}" in
            "lint")
              echo "‚ú® Running ESLint with stability optimizations..."
              timeout ${{ matrix.timeout }}m pnpm nx run-many -t lint --parallel=${{ matrix.parallel }} --maxWorkers=1
              ;;
            "build")
              echo "üöÄ Running optimized build process..."
              timeout ${{ matrix.timeout }}m pnpm nx run-many -t build --parallel=${{ matrix.parallel }}
              ;;
            "typecheck")
              echo "üîç Running TypeScript compilation check..."
              timeout ${{ matrix.timeout }}m pnpm typecheck
              ;;
            *)
              echo "üîÑ Running ${{ matrix.check }}..."
              timeout ${{ matrix.timeout }}m pnpm nx run-many -t ${{ matrix.check }} --parallel=${{ matrix.parallel }}
              ;;
          esac
        env:
          NODE_OPTIONS: "--max-old-space-size=6144"
          NX_DAEMON: "false"
          NX_PARALLEL: "${{ matrix.parallel }}"
          NX_CLOUD_DISTRIBUTED_EXECUTION: "false"
          NX_CACHE: "true"
          ESLINT_USE_FLAT_CONFIG: "true"

      - name: Upload build artifact
        if: matrix.check == 'build'
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ github.sha }}
          path: apps/web/dist/
          retention-days: 1
          compression-level: 6

      - name: Save Nx cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .nx/cache
          key: ${{ needs.setup.outputs.nx-cache-key }}-${{ matrix.check }}-${{ github.run_id }}-${{ github.run_attempt }}

      - name: Add performance summary
        if: always() && matrix.check == 'typecheck'
        run: |
          echo "## üöÄ Performance Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Cache statistics
          if [ -d ".nx/cache" ]; then
            CACHE_SIZE=$(du -sh .nx/cache 2>/dev/null | cut -f1 || echo "0B")
            CACHE_FILES=$(find .nx/cache -type f 2>/dev/null | wc -l || echo "0")
            echo "### Cache Metrics" >> $GITHUB_STEP_SUMMARY
            echo "- **Cache Size**: $CACHE_SIZE" >> $GITHUB_STEP_SUMMARY
            echo "- **Cache Files**: $CACHE_FILES" >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Optimizations Applied" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Stability Improvements**" >> $GITHUB_STEP_SUMMARY
            echo "- Disabled Nx daemon for CI stability" >> $GITHUB_STEP_SUMMARY
            echo "- Reduced parallelism to prevent resource exhaustion" >> $GITHUB_STEP_SUMMARY
            echo "- Added aggressive timeouts with fallback recovery" >> $GITHUB_STEP_SUMMARY
            echo "- Simplified cache strategy for reliability" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è No cache data available" >> $GITHUB_STEP_SUMMARY
          fi

  test:
    needs: setup
    runs-on: ubuntu-latest
    timeout-minutes: 20

    strategy:
      fail-fast: false
      matrix:
        test-type: [unit, integration]
        include:
          - test-type: unit
            command: test:unit
            coverage: true
            timeout: 10
          - test-type: integration
            command: test:integration
            coverage: false
            timeout: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          fail-on-cache-miss: true

      - name: Restore Nx workspace cache
        uses: actions/cache/restore@v4
        with:
          path: |
            .nx/workspace-data
            .nx/installation
          key: ${{ needs.setup.outputs.nx-workspace-key }}
          restore-keys: |
            nx-workspace-${{ runner.os }}-${{ github.ref_name }}-
            nx-workspace-${{ runner.os }}-

      - name: Restore Nx task cache
        uses: actions/cache/restore@v4
        with:
          path: .nx/cache
          key: ${{ needs.setup.outputs.nx-cache-key }}-${{ github.run_id }}
          restore-keys: |
            ${{ needs.setup.outputs.nx-cache-key }}-
            nx-v2-${{ runner.os }}-

      # E2E test setup removed - no E2E tests currently exist
      # TODO: Re-enable when actual E2E tests are implemented

      - name: Setup test environment
        run: |
          echo "üß™ Setting up test environment for ${{ matrix.test-type }}..."
          # Ensure daemon is stopped
          pnpm nx daemon --stop 2>/dev/null || true

          # Clear any test artifacts
          find . -name "coverage" -type d -exec rm -rf {} + 2>/dev/null || true

      - name: Run ${{ matrix.test-type }} tests
        run: |
          echo "üß™ Running ${{ matrix.test-type }} tests..."
          if [ "${{ matrix.coverage }}" = "true" ]; then
            timeout ${{ matrix.timeout }}m pnpm nx run-many -t ${{ matrix.command }} --coverage --parallel=1
          else
            timeout ${{ matrix.timeout }}m pnpm nx run-many -t ${{ matrix.command }} --parallel=1
          fi
        env:
          NODE_OPTIONS: "--max-old-space-size=8192 --expose-gc"
          NX_DAEMON: "false"
          NX_PARALLEL: "1"
          NX_CLOUD_DISTRIBUTED_EXECUTION: "false"
          VITEST_MAX_THREADS: "2"
          VITEST_MIN_THREADS: "1"

      - name: Upload coverage artifacts
        if: always() && matrix.coverage == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.test-type }}-${{ github.sha }}
          path: |
            apps/*/coverage/
            packages/*/coverage/
          retention-days: 7
          if-no-files-found: warn

      - name: Collect coverage files for reporting
        if: always() && matrix.coverage == 'true'
        run: |
          echo "Collecting coverage files..."
          mkdir -p coverage-reports

          # Find all coverage-final.json files and copy them
          find . -name "coverage-final.json" -path "*/coverage/*" | while read file; do
            project_name=$(echo "$file" | sed 's|./||' | sed 's|/coverage/coverage-final.json||')
            echo "Found coverage for: $project_name"
            cp "$file" "coverage-reports/coverage-final-${project_name//\//-}.json"
          done

          # List what we found
          echo "Coverage files collected:"
          ls -la coverage-reports/ || echo "No coverage reports directory created"

          # Also collect HTML reports if they exist
          find . -name "index.html" -path "*/coverage/*" | while read file; do
            project_name=$(echo "$file" | sed 's|./||' | sed 's|/coverage/index.html||')
            mkdir -p "coverage-reports/html-${project_name//\//-}"
            cp -r "$(dirname "$file")/*" "coverage-reports/html-${project_name//\//-}/" 2>/dev/null || true
          done

      - name: Upload merged coverage reports
        if: always() && matrix.coverage == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports-${{ matrix.test-type }}-${{ github.sha }}
          path: coverage-reports/
          retention-days: 7
          if-no-files-found: warn

      - name: Save Nx task cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .nx/cache
          key: ${{ needs.setup.outputs.nx-cache-key }}-${{ matrix.test-type }}-${{ github.run_id }}-${{ github.run_attempt }}

  coverage-report:
    needs: [test]
    runs-on: ubuntu-latest
    timeout-minutes: 5

    if: always() && (needs.test.result == 'success' || needs.test.result == 'failure')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download coverage artifacts
        uses: actions/download-artifact@v5
        with:
          pattern: coverage-reports-unit-${{ github.sha }}
          path: ./
          merge-multiple: true

      - name: Setup Node.js for coverage processing
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install tsx for coverage scripts
        run: npm install -g tsx

      - name: Verify coverage files structure
        run: |
          echo "Checking downloaded coverage files..."
          find . -name "*coverage*" -type f | head -20
          echo "\nChecking for coverage-final.json files..."
          find . -name "coverage-final.json" | head -10
          echo "\nChecking coverage-reports directory..."
          ls -la coverage-reports/ 2>/dev/null || echo "No coverage-reports directory found"
          echo "\nAll files in current directory:"
          ls -la

      - name: Create coverage summary
        run: |
          echo "Creating coverage summary..."
          if [ -f "tools/scripts/create-coverage-summary.ts" ]; then
            npx tsx tools/scripts/create-coverage-summary.ts
          else
            echo "Warning: create-coverage-summary.ts not found, creating fallback summary"
            mkdir -p coverage-reports
            cat > coverage-reports/coverage-summary.json << 'EOF'
          {
            "total": {
              "lines": { "pct": 0 },
              "functions": { "pct": 0 },
              "branches": { "pct": 0 },
              "statements": { "pct": 0 }
            }
          }
          EOF
          fi

      - name: Generate coverage summary
        run: |
          echo "## Coverage Report" >> $GITHUB_STEP_SUMMARY
          if [ -f "tools/scripts/generate-coverage-report.ts" ]; then
            npx tsx tools/scripts/generate-coverage-report.ts summary >> $GITHUB_STEP_SUMMARY
          elif [ -f "coverage-reports/coverage-summary.json" ]; then
            echo "\n### Coverage Summary" >> $GITHUB_STEP_SUMMARY
            cat coverage-reports/coverage-summary.json | jq -r '
              "üìä **Coverage Metrics:**\n" +
              "- Lines: " + (.total.lines.pct|tostring) + "%\n" +
              "- Functions: " + (.total.functions.pct|tostring) + "%\n" +
              "- Branches: " + (.total.branches.pct|tostring) + "%\n" +
              "- Statements: " + (.total.statements.pct|tostring) + "%"' >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è **No coverage data available**" >> $GITHUB_STEP_SUMMARY
            echo "Coverage reports were not generated or uploaded properly." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload consolidated coverage report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-consolidated-${{ github.sha }}
          path: coverage-reports/
          retention-days: 30
          if-no-files-found: warn

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        run: |
          if [ -f "tools/scripts/manage-coverage-comments.ts" ]; then
            npx tsx tools/scripts/manage-coverage-comments.ts
          else
            echo "Warning: manage-coverage-comments.ts not found, skipping PR comment"
            echo "Consider creating a simple PR comment script or updating the coverage workflow"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.number }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}

  acknowledgements:
    needs: [setup, quality-checks]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    # Only run on dependency changes or manual trigger
    if: >
      (github.event_name == 'push' &&
       (contains(github.event.head_commit.message, 'package.json') ||
        contains(github.event.head_commit.message, 'pnpm-lock.yaml') ||
        contains(github.event.head_commit.message, '[update-ack]'))) ||
      github.event_name == 'workflow_dispatch'

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 2

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          fail-on-cache-miss: true

      - name: Check for problematic licenses
        run: pnpm licenses:check

      - name: Generate acknowledgements
        run: |
          echo "Generating acknowledgements for production dependencies..."
          pnpm licenses:generate > temp_ack.md

          # Add header and metadata
          cat > ACKNOWLEDGEMENTS.md << EOF
          # Third-Party Acknowledgements

          This document acknowledges the third-party packages used in this project and their licenses.

          **Generated on:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Dependencies analyzed:** Production dependencies only
          **Last updated:** Commit $(git rev-parse --short HEAD)

          ---

          EOF

          cat temp_ack.md >> ACKNOWLEDGEMENTS.md
          rm temp_ack.md

      - name: Check for changes
        id: check-changes
        run: |
          if git diff --quiet ACKNOWLEDGEMENTS.md; then
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "No changes in acknowledgements"
          else
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected in acknowledgements"
            echo "Changes:"
            git diff --no-color ACKNOWLEDGEMENTS.md | head -20
          fi

      - name: Configure git
        if: steps.check-changes.outputs.changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Commit acknowledgements
        if: steps.check-changes.outputs.changes == 'true'
        run: |
          git add ACKNOWLEDGEMENTS.md

          COMMIT_MSG="chore(deps): update third-party acknowledgements

          - Updated acknowledgements for production dependencies
          - Generated from $(git log -1 --pretty=format:'%s' HEAD)
          - Analysis timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          [skip ci]"

          git commit -m "$COMMIT_MSG"

      - name: Push changes to current branch
        if: steps.check-changes.outputs.changes == 'true' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
        run: |
          git push origin ${{ github.ref_name }}

      - name: Create pull request for other branches
        if: steps.check-changes.outputs.changes == 'true' && github.ref != 'refs/heads/main' && github.ref != 'refs/heads/develop'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore(deps): update third-party acknowledgements"
          title: "üîÑ Update Third-Party Acknowledgements"
          body: |
            ## üìã Acknowledgements Update

            This PR updates the third-party acknowledgements file based on current production dependencies.

            ### Changes
            - ‚úÖ Scanned production dependencies only
            - ‚úÖ Excluded private packages
            - ‚úÖ Verified license compatibility
            - üïí Generated during CI run

            ### License Status
            All included packages use approved licenses (MIT, Apache-2.0, BSD, ISC, etc.)

            ---
            *This PR was automatically generated by the CI workflow.*
          branch: update-acknowledgements
          delete-branch: true

      - name: Add job summary
        if: always()
        run: |
          echo "## üìã Acknowledgements Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check-changes.outputs.changes }}" == "true" ]; then
            echo "‚úÖ **Changes detected and committed**" >> $GITHUB_STEP_SUMMARY
            echo "- Updated ACKNOWLEDGEMENTS.md with current dependencies" >> $GITHUB_STEP_SUMMARY
            echo "- All licenses passed compatibility check" >> $GITHUB_STEP_SUMMARY

            if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/develop" ]; then
              echo "- Changes pushed directly to ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "- Created pull request for review" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ÑπÔ∏è **No changes needed**" >> $GITHUB_STEP_SUMMARY
            echo "- Acknowledgements are up to date" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  accessibility:
    needs: [setup, quality-checks]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    continue-on-error: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          fail-on-cache-miss: true

      - name: Install Chrome for accessibility testing
        run: |
          wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
          sudo sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google-chrome.list'
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable

      - name: Download build artifact
        uses: actions/download-artifact@v5
        with:
          name: dist-${{ github.sha }}
          path: dist/

      - name: Start preview server for accessibility testing
        run: pnpm nx preview &
        env:
          NODE_OPTIONS: "--max-old-space-size=6144"

      - name: Wait for preview server to be ready
        run: |
          echo "Waiting for preview server to start..."
          timeout 30 bash -c 'until curl -f http://localhost:4173 > /dev/null 2>&1; do sleep 1; done'
          echo "Preview server responding, waiting for app to be ready..."
          timeout 30 bash -c 'until curl -s http://localhost:4173 | grep -q "Academic Explorer\|<div id=\"root\""; do sleep 2; done'
          echo "Preview server and app are ready"

      - name: Run accessibility tests
        run: pnpm nx a11y:ci
        env:
          NODE_OPTIONS: "--max-old-space-size=6144"
          CHROME_PATH: "/usr/bin/google-chrome-stable"
          PUPPETEER_EXECUTABLE_PATH: "/usr/bin/google-chrome-stable"

      - name: Upload accessibility reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: accessibility-reports-${{ github.sha }}
          path: |
            .lighthouseci/
            pa11y-results.json
          retention-days: 7

  release:
    needs: [setup, quality-checks, test, accessibility]
    runs-on: ubuntu-latest
    timeout-minutes: 30

    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    permissions:
      contents: write
      issues: write
      pull-requests: write

    outputs:
      released: ${{ steps.create-releases.outputs.release_created }}
      tag: ${{ steps.create-releases.outputs.release_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          fail-on-cache-miss: true

      - name: Run Nx Release
        id: nx-release
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Run nx release version (updates files but doesn't commit)
          pnpm release:version --skip-publish --dry-run

          # Check if there are actual changes to make
          if pnpm release:version --skip-publish 2>&1 | grep -q "No changes to version"; then
            echo "release_created=false" >> $GITHUB_OUTPUT
            echo "No version changes needed"
            exit 0
          fi

          echo "release_created=true" >> $GITHUB_OUTPUT

          # Get the new versions that would be created
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT

          echo "Nx Release would create version: $NEW_VERSION"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub releases
        id: create-releases
        if: steps.nx-release.outputs.release_created == 'true'
        run: |
          # Create tags and GitHub releases
          pnpm release:publish

          echo "release_created=true" >> $GITHUB_OUTPUT
          echo "release_tag=${{ steps.nx-release.outputs.release_tag }}" >> $GITHUB_OUTPUT
          echo "new_version=${{ steps.nx-release.outputs.new_version }}" >> $GITHUB_OUTPUT

          echo "Created GitHub releases with tags"

      - name: Update version and create follow-up commit
        if: steps.create-releases.outputs.release_created == 'true'
        run: |
          # Check if there are changes from nx release version
          if git diff --quiet HEAD; then
            echo "No changes to commit - nx release didn't update files"
            exit 0
          fi

          # Stage all changes from nx release
          git add .

          # Create follow-up commit with version bumps and changelog updates
          git commit -m "chore(release): bump versions [skip ci]

          Automated version bumps and changelog updates:
          - Updated package versions via nx release
          - Generated changelogs for affected packages
          - Release: ${{ steps.create-releases.outputs.release_tag }}"

          # Push the follow-up commit
          git push origin main

      - name: Build for release
        if: steps.create-releases.outputs.release_created == 'true'
        run: |
          # Rebuild with the updated version
          pnpm nx build
        env:
          NODE_OPTIONS: "--max-old-space-size=4096"

      - name: Upload build artifact for deployment
        if: steps.create-releases.outputs.release_created == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: dist-release-${{ github.run_id }}
          path: apps/web/dist/
          retention-days: 1
          compression-level: 6

  deploy:
    needs: [release]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    if: needs.release.outputs.released == 'true'

    permissions:
      contents: read
      pages: write
      id-token: write

    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v5
        with:
          name: dist-release-${{ github.run_id }}
          path: dist/

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: dist/

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  knip-analysis:
    needs: [setup, quality-checks]
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # Only run on scheduled events (weekly) or manual dispatch
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          fail-on-cache-miss: true

      - name: Run knip analysis
        id: knip-run
        run: |
          echo "üîç Running knip analysis..."

          if pnpm knip --reporter json > knip-report.json 2>&1; then
            echo "knip_exit_code=0" >> $GITHUB_OUTPUT
            echo "‚úÖ Knip analysis completed successfully"
          else
            echo "knip_exit_code=$?" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Knip found unused code"
          fi

          if [ -s knip-report.json ] && [ "$(jq '.issues | length' knip-report.json 2>/dev/null || echo 0)" -gt 0 ]; then
            echo "has_issues=true" >> $GITHUB_OUTPUT
            echo "üìä Knip found unused code to clean up"

            UNUSED_FILES=$(jq -r '.issues[] | select(.type == "unlisted") | .file' knip-report.json 2>/dev/null | wc -l || echo 0)
            UNUSED_DEPS=$(jq -r '.issues[] | select(.type == "dependencies") | .dependencies[]?' knip-report.json 2>/dev/null | wc -l || echo 0)
            UNUSED_EXPORTS=$(jq -r '.issues[] | select(.type == "exports") | .exports[]?' knip-report.json 2>/dev/null | wc -l || echo 0)

            echo "unused_files=$UNUSED_FILES" >> $GITHUB_OUTPUT
            echo "unused_deps=$UNUSED_DEPS" >> $GITHUB_OUTPUT
            echo "unused_exports=$UNUSED_EXPORTS" >> $GITHUB_OUTPUT

            echo "## üßπ Knip Analysis Summary" > knip-summary.md
            echo "" >> knip-summary.md
            echo "Knip found the following unused code:" >> knip-summary.md
            echo "- üìÅ Unused files: $UNUSED_FILES" >> knip-summary.md
            echo "- üì¶ Unused dependencies: $UNUSED_DEPS" >> knip-summary.md
            echo "- üîó Unused exports: $UNUSED_EXPORTS" >> knip-summary.md
            echo "" >> knip-summary.md

            if [ "$UNUSED_FILES" -gt 0 ]; then
              echo "### Unused Files" >> knip-summary.md
              jq -r '.issues[] | select(.type == "unlisted") | "- `" + .file + "`"' knip-report.json >> knip-summary.md
              echo "" >> knip-summary.md
            fi

            if [ "$UNUSED_DEPS" -gt 0 ]; then
              echo "### Unused Dependencies" >> knip-summary.md
              jq -r '.issues[] | select(.type == "dependencies") | .dependencies[]? | "- `" + . + "`"' knip-report.json >> knip-summary.md
              echo "" >> knip-summary.md
            fi

            if [ "$UNUSED_EXPORTS" -gt 0 ]; then
              echo "### Unused Exports" >> knip-summary.md
              jq -r '.issues[] | select(.type == "exports") | .exports[]? | "- `" + .symbol + "` in `" + .file + "`"' knip-report.json >> knip-summary.md
            fi
          else
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "‚ú® No unused code found!"
          fi

      - name: Create cleanup branch and apply fixes
        if: steps.knip-run.outputs.has_issues == 'true' && !inputs.dry_run
        id: apply-fixes
        run: |
          BRANCH_NAME="chore/knip-cleanup-$(date +%Y%m%d-%H%M%S)"

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git checkout -b "$BRANCH_NAME"

          echo "üîß Applying knip fixes..."
          if pnpm knip --fix; then
            echo "‚úÖ Automatic fixes applied successfully"

            if git diff --quiet; then
              echo "changes_made=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è No changes were made by knip --fix"
            else
              echo "changes_made=true" >> $GITHUB_OUTPUT
              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

              git add .
              git commit -m "chore: remove unused code detected by knip

              This commit removes unused code identified by knip analysis:
              - Unused files: ${{ steps.knip-run.outputs.unused_files }}
              - Unused dependencies: ${{ steps.knip-run.outputs.unused_deps }}
              - Unused exports: ${{ steps.knip-run.outputs.unused_exports }}

              Generated automatically by CI workflow."

              echo "üß™ Running verification tests..."
              if pnpm typecheck && pnpm build && pnpm test && pnpm lint; then
                echo "‚úÖ All tests passed after cleanup"
                git push origin "$BRANCH_NAME"
                echo "üì§ Pushed changes to branch"
              else
                echo "‚ùå Tests failed after cleanup"
                exit 1
              fi
            fi
          else
            echo "‚ùå Failed to apply automatic fixes"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        if: steps.apply-fixes.outputs.changes_made == 'true'
        run: |
          PR_TITLE="üßπ chore: automated code cleanup via knip"

          PR_BODY="## ü§ñ Automated Code Cleanup

          This PR was automatically created by the CI workflow to remove unused code.

          $(cat knip-summary.md)

          ## ‚úÖ Verification

          - [x] Knip analysis completed
          - [x] Automatic fixes applied
          - [x] TypeScript compilation passes
          - [x] Build succeeds
          - [x] Tests pass
          - [x] Linting passes

          ## üìã Manual Review Needed

          Please review the changes to ensure:
          - No critical code was accidentally removed
          - All functionality still works as expected
          - The cleanup aligns with project goals

          ---
          ü§ñ Generated by CI workflow"

          gh pr create \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --base main \
            --head "${{ steps.apply-fixes.outputs.branch_name }}" \
            --label "automated" \
            --label "chore" \
            --label "knip"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload knip report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: knip-report-${{ github.run_id }}
          path: |
            knip-report.json
            knip-summary.md
          retention-days: 7

      - name: Add job summary
        if: always()
        run: |
          echo "## üéØ Knip Analysis Summary" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.knip-run.outputs.has_issues }}" == "true" ]; then
            echo "üîç **Knip found unused code**" >> $GITHUB_STEP_SUMMARY
            echo "- Files: ${{ steps.knip-run.outputs.unused_files }}" >> $GITHUB_STEP_SUMMARY
            echo "- Dependencies: ${{ steps.knip-run.outputs.unused_deps }}" >> $GITHUB_STEP_SUMMARY
            echo "- Exports: ${{ steps.knip-run.outputs.unused_exports }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "${{ steps.apply-fixes.outputs.changes_made }}" == "true" ]; then
              echo "‚úÖ **PR created for cleanup**" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ÑπÔ∏è **No changes needed** - Knip didn't make any modifications" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ú® **No unused code found** - Repository is clean!" >> $GITHUB_STEP_SUMMARY
          fi

  cleanup:
    needs: [release, deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 5

    if: always()

    steps:
      - name: Delete temporary artifacts
        uses: geekyeggo/delete-artifact@v5
        with:
          name: |
            dist-${{ github.sha }}
            dist-release-${{ github.run_id }}
            coverage-*-${{ github.sha }}
            knip-report-${{ github.run_id }}
          failOnError: false
