# Data Model: Graph List Persistent Working Set

**Feature**: 038-graph-list
**Date**: 2025-12-02
**Phase**: 1 - Design & Contracts

## Overview

This document defines the data model for the Graph List feature, including type definitions, storage schema, and data relationships.

## Core Entities

### GraphListNode

Represents a single node in the persistent graph working set.

```typescript
/**
 * Provenance tracking for graph list nodes
 * Indicates how a node was added to the graph list
 */
export type GraphProvenance =
  | 'user'              // Explicitly added by user via search/UI
  | 'collection-load'   // Added when loading from bookmarks/history
  | 'expansion'         // Added when user expands node relationships
  | 'auto-population';  // Added by background auto-population system

/**
 * Node in the persistent graph working set
 *
 * Stored in IndexedDB via CatalogueStorageProvider interface.
 * Bypasses entity type filters (always visible when in graph list).
 */
export interface GraphListNode {
  /**
   * Unique identifier (auto-generated by storage provider)
   * Format: UUID v4 or similar
   */
  id: string;

  /**
   * OpenAlex entity ID
   * @example "W2741809807" (work), "A5017898742" (author)
   */
  entityId: string;

  /**
   * Entity type from OpenAlex
   * @example "works", "authors", "institutions", "sources", "topics"
   */
  entityType: EntityType;

  /**
   * Display label for the node
   * Extracted from entity data (e.g., work title, author name)
   */
  label: string;

  /**
   * Timestamp when node was added to graph list
   * Used for pruning old auto-populated nodes
   */
  addedAt: Date;

  /**
   * How this node was added to the graph list
   * Used for UI display and pruning strategy
   */
  provenance: GraphProvenance;
}
```

### Configuration Constants

Size limits and thresholds for graph list management.

```typescript
/**
 * Graph list configuration constants
 * Extracted to prevent magic numbers (Constitution Principle XVII)
 */
export const GRAPH_LIST_CONFIG = {
  /** Maximum number of nodes allowed in graph list */
  MAX_SIZE: 1000,

  /** Threshold for showing "approaching limit" warning */
  WARNING_THRESHOLD: 900,

  /** Age threshold for pruning auto-populated nodes (milliseconds) */
  PRUNE_AGE_MS: 24 * 60 * 60 * 1000, // 24 hours

  /** Special list ID for graph list in storage */
  LIST_ID: 'graph-list',
} as const;
```

## Storage Schema

### IndexedDB Structure

Graph list nodes are stored as `CatalogueEntity` records in existing IndexedDB tables.

```typescript
// Existing table (no schema changes required)
interface CatalogueEntity {
  id?: string;                // Auto-increment primary key
  listId: string;             // "graph-list" for graph list nodes
  entityType: EntityType;     // OpenAlex entity type
  entityId: string;           // OpenAlex ID
  addedAt: Date;              // Timestamp
  notes?: string;             // Used to store provenance
  position: number;           // Display order (unused for graph list)
}

// Provenance serialization in notes field
// Format: "provenance:user" | "provenance:expansion" | etc.
```

**Indexes** (existing, no changes):
- `[listId, entityType, entityId]` - Composite index for unique constraint
- `listId` - Query all nodes in graph list
- `addedAt` - Query nodes by timestamp (for pruning)

### Special List ID

```typescript
// Added to packages/utils/src/storage/catalogue-db.ts
export const SPECIAL_LIST_IDS = {
  BOOKMARKS: "bookmarks-list",
  HISTORY: "history-list",
  GRAPH: "graph-list",       // NEW
} as const;
```

## Data Relationships

### Graph List ↔ Collections (Bookmarks/History)

```
┌─────────────────────────────────────┐
│ Node Visibility Logic               │
│                                     │
│ visible_nodes = graph_list ∪        │
│   (collections ∩ entity_types)      │
│                                     │
│ Where:                              │
│ - graph_list: Always visible        │
│ - collections: Bookmarks + History  │
│ - entity_types: Enabled filters     │
└─────────────────────────────────────┘

Example:
  Graph list:        [W1, A1, I1]  (always visible)
  Bookmarks:         [W1, W2, A1, A2]
  Enabled types:     [works]
  ────────────────────────────────────
  Visible:           [W1, A1, I1, W2]
                     └─graph list──┘ └collection filtered┘
```

**Key properties**:
- **Union, not intersection**: Graph list + filtered collections (not either/or)
- **Deduplication**: Same entity appears once even if in both graph list and collections
- **Filter bypass**: Graph list nodes ignore entity type filters
- **Persistence**: Graph list persists across sessions, unlike transient UI state

### Provenance Flow

```
User Actions                Provenance Type          Storage Operation
─────────────────────────────────────────────────────────────────────
Search → "Add to graph"  →  user              →  addToGraphList()
Load bookmarks           →  collection-load   →  addToGraphList()
Expand node              →  expansion         →  addToGraphList()
Auto-population          →  auto-population   →  addToGraphList()
```

**Provenance transitions**: Allowed (updates provenance to most recent)

```typescript
// If node already exists in graph list, update provenance
// Example: node added via expansion, later bookmarked
//   Initial: provenance = 'expansion'
//   After bookmark load: provenance = 'collection-load' (most recent)
```

## Validation Rules

### Node Addition

```typescript
interface AddToGraphListValidation {
  // FR-016: Prevent duplicate nodes (same entity ID can only appear once)
  uniqueEntityId: (entityId: string) => boolean;

  // FR-017, FR-019: Enforce size limit (1000 nodes maximum)
  enforceMaxSize: (currentSize: number) => boolean;

  // Type-safe provenance
  validProvenance: (provenance: unknown) => provenance is GraphProvenance;

  // Required fields
  requiredFields: (node: Partial<GraphListNode>) => node is GraphListNode;
}

// Validation implementation
const validateAddition = async (node: GraphListNode): Promise<void> => {
  // Check size limit
  const currentSize = await storageProvider.getGraphListSize();
  if (currentSize >= GRAPH_LIST_CONFIG.MAX_SIZE) {
    throw new Error(`Graph list is full (${GRAPH_LIST_CONFIG.MAX_SIZE} nodes). Remove some nodes to add more.`);
  }

  // Check duplicate
  const existing = await storageProvider.getGraphList();
  if (existing.some(n => n.entityId === node.entityId)) {
    // Update provenance instead of adding duplicate
    await storageProvider.updateGraphListNode(node.entityId, { provenance: node.provenance });
    return;
  }

  // Validate provenance
  const validProvenances: GraphProvenance[] = ['user', 'collection-load', 'expansion', 'auto-population'];
  if (!validProvenances.includes(node.provenance)) {
    throw new Error(`Invalid provenance: ${node.provenance}`);
  }

  // All checks passed, add node
  await storageProvider.addToGraphList(node);
};
```

### Node Removal

```typescript
interface RemoveFromGraphListValidation {
  // FR-011: Remove all connected edges when node removed
  cascadeEdgeRemoval: (entityId: string) => Promise<void>;

  // No validation required for removal (any node can be removed)
  allowAnyNode: true;
}
```

### Pruning

```typescript
interface PruneValidation {
  // FR-020: Prune auto-populated nodes older than 24 hours
  isEligibleForPruning: (node: GraphListNode) => boolean;
}

const isEligibleForPruning = (node: GraphListNode): boolean => {
  const cutoffDate = new Date(Date.now() - GRAPH_LIST_CONFIG.PRUNE_AGE_MS);
  return node.provenance === 'auto-population' && node.addedAt < cutoffDate;
};
```

## State Transitions

### Node Lifecycle

```
[Not in graph list]
    ↓ addToGraphList(node)
[In graph list] ───→ {provenance updated if re-added}
    ↓ removeFromGraphList(entityId)
[Not in graph list]
    ↓ clearGraphList()
[Empty graph list]
```

### Size Warning States

```
< 900 nodes:   Normal operation
900-999 nodes: Warning state (show toast/banner)
1000 nodes:    Full state (block additions)
```

## Query Patterns

### Common Operations

```typescript
// 1. Get all graph list nodes (most common)
const nodes = await storageProvider.getGraphList();
// Returns: GraphListNode[]
// Performance: O(n) where n = graph list size, typically <50ms

// 2. Check if node exists in graph list
const exists = (await storageProvider.getGraphList())
  .some(n => n.entityId === targetEntityId);
// Performance: O(n), but can be optimized with Set

// 3. Get nodes by provenance
const userAddedNodes = (await storageProvider.getGraphList())
  .filter(n => n.provenance === 'user');
// Performance: O(n), suitable for UI filters

// 4. Get graph list size (for limit checks)
const size = await storageProvider.getGraphListSize();
// Performance: O(1) if cached, O(n) if counting

// 5. Prune old auto-populated nodes
const pruned = await storageProvider.pruneGraphList();
// Returns: number of nodes removed
// Performance: O(n) read + O(k) writes where k = pruned count
```

## Performance Considerations

### IndexedDB Transaction Batching

For bulk operations, use transactions to batch writes:

```typescript
// Bad: Multiple transactions (slow)
for (const node of nodes) {
  await storageProvider.addToGraphList(node);
}

// Good: Single transaction (fast)
await storageProvider.batchAddToGraphList(nodes);
```

### Optimistic Updates

UI updates immediately, storage persists asynchronously:

```typescript
// Zustand store pattern
addNode: (node) => {
  // 1. Optimistic update (instant UI)
  set(state => ({ nodes: [...state.nodes, node] }));

  // 2. Persist to IndexedDB (async)
  storageProvider.addToGraphList(node).catch(error => {
    // 3. Revert on failure
    set(state => ({ nodes: state.nodes.filter(n => n.id !== node.id) }));
    showErrorToast(error.message);
  });
}
```

## Type Guards

```typescript
/**
 * Type guard for GraphProvenance
 */
export const isGraphProvenance = (value: unknown): value is GraphProvenance => {
  return typeof value === 'string' && ['user', 'collection-load', 'expansion', 'auto-population'].includes(value);
};

/**
 * Type guard for GraphListNode
 */
export const isGraphListNode = (value: unknown): value is GraphListNode => {
  if (typeof value !== 'object' || value === null) return false;
  const node = value as Record<string, unknown>;
  return (
    typeof node.id === 'string' &&
    typeof node.entityId === 'string' &&
    typeof node.entityType === 'string' &&
    typeof node.label === 'string' &&
    node.addedAt instanceof Date &&
    isGraphProvenance(node.provenance)
  );
};
```

## Next Steps

1. Generate storage provider interface contract (`contracts/storage-provider-graph-list.ts`)
2. Generate quickstart guide (`quickstart.md`)
3. Update agent context files with new types and patterns
