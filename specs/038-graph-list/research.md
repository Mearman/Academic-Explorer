# Research Document: Graph List Persistent Working Set

**Feature**: 038-graph-list
**Date**: 2025-12-02
**Phase**: 0 - Outline & Research

## Overview

This document consolidates research findings for implementing the Graph List feature. All NEEDS CLARIFICATION items from Technical Context have been resolved through codebase analysis and established patterns.

## Research Areas

### 1. Storage Provider Pattern

**Decision**: Extend existing `CatalogueStorageProvider` interface with graph list methods

**Rationale**:
- Established pattern: `SPECIAL_LIST_IDS.BOOKMARKS` and `SPECIAL_LIST_IDS.HISTORY` already exist
- Interface provides `initializeSpecialLists()` for creating system lists on first use
- Both Dexie (IndexedDB) and in-memory providers implement the interface
- Pattern proven: bookmarks/history work identically across providers

**Implementation approach**:
1. Add `SPECIAL_LIST_IDS.GRAPH = "graph-list"` constant to `catalogue-db.ts`
2. Extend interface with 5 new methods:
   - `getGraphList(): Promise<GraphListNode[]>`
   - `addToGraphList(node: GraphListNode): Promise<string>`
   - `removeFromGraphList(entityId: string): Promise<void>`
   - `clearGraphList(): Promise<void>`
   - `getGraphListSize(): Promise<number>`
3. Implement in both `DexieStorageProvider` and `InMemoryStorageProvider`
4. Update `initializeSpecialLists()` to create graph list on first call

**Alternatives considered**:
- **Separate storage mechanism**: Rejected—adds complexity, breaks abstraction
- **Zustand-only state**: Rejected—loses persistence across browser sessions
- **LocalStorage**: Rejected—size limits, no structured queries, no transactions

### 2. Graph List Node Structure

**Decision**: Create `GraphListNode` type extending `CatalogueEntity` with provenance field

**Rationale**:
- `CatalogueEntity` already has: `entityId`, `entityType`, `addedAt`, `notes`, `position`
- Need to add: `provenance` field to track how node was added
- Reuses existing storage schema, IndexedDB tables, and query patterns
- Type-safe provenance via enum: `'user' | 'expansion' | 'auto-population' | 'collection-load'`

**Schema**:
```typescript
export type GraphProvenance = 'user' | 'expansion' | 'auto-population' | 'collection-load';

export interface GraphListNode {
  id: string;            // Auto-generated by storage provider
  entityId: string;      // OpenAlex ID (e.g., "W2741809807")
  entityType: EntityType; // works, authors, institutions, etc.
  label: string;         // Display name
  addedAt: Date;         // Timestamp
  provenance: GraphProvenance; // How node was added
}
```

**Storage approach**:
- Graph list nodes stored as `CatalogueEntity` records with `listId = "graph-list"`
- `provenance` stored in `notes` field using structured format: `provenance:user`
- Extract provenance on read, serialize on write
- Maintains compatibility with existing storage provider interface

**Alternatives considered**:
- **Separate table**: Rejected—duplicates entity storage, complicates queries
- **JSON in notes**: Rejected—harder to query, less type-safe
- **Separate provenance table**: Rejected—adds joins, slows queries

### 3. Node Visibility Logic Integration

**Decision**: Modify graph data loading to combine graph list with filtered collections

**Rationale**:
- Current logic: `nodes = collections ∩ entity_types` (filters apply to everything)
- New logic: `nodes = graph_list ∪ (collections ∩ entity_types)` (graph list bypasses filters)
- Solves "invisible expansion" bug where discovered nodes disappear due to filters
- Union operation: graph list nodes always visible + filtered collection nodes

**Implementation location**: `apps/web/src/hooks/use-graph-data.ts` (or similar graph data hook)

**Logic flow**:
```typescript
const getVisibleNodes = async (): Promise<GraphNode[]> => {
  // Step 1: Get graph list nodes (always visible)
  const graphListNodes = await storageProvider.getGraphList();

  // Step 2: Get collection nodes (bookmarks + history)
  const collectionNodes = [
    ...(await storageProvider.getBookmarks()),
    ...(await storageProvider.getHistory())
  ];

  // Step 3: Filter collection nodes by enabled entity types
  const filteredCollectionNodes = collectionNodes.filter(node =>
    enabledEntityTypes.includes(node.entityType)
  );

  // Step 4: Union (deduplicate by entityId)
  const nodeMap = new Map<string, GraphNode>();
  for (const node of [...graphListNodes, ...filteredCollectionNodes]) {
    if (!nodeMap.has(node.entityId)) {
      nodeMap.set(node.entityId, node);
    }
  }

  return Array.from(nodeMap.values());
};
```

**Alternatives considered**:
- **Auto-enable entity types**: Rejected—surprising behavior, loses user intent
- **Separate graph list visibility toggle**: Rejected—adds complexity, confusing UX
- **Expansion results as temporary layer**: Rejected—not persistent, loses context on refresh

### 4. Provenance Tracking

**Decision**: Track provenance at node addition time using 4 categories

**Rationale**:
- **User transparency**: Users should understand how their graph was built
- **Pruning strategy**: Auto-population nodes can be bulk-removed
- **Debug support**: Helps diagnose graph population issues
- **Audit trail**: Research context requires understanding exploration path

**Provenance categories**:
1. **`user`**: Explicitly added via search → "Add to graph" button
2. **`collection-load`**: Added when loading from bookmarks/history
3. **`expansion`**: Added when user expands node to discover relationships
4. **`auto-population`**: Added by background auto-population system

**UI display**: Provenance indicator (badge/icon) next to each node in graph list sidebar

**Alternatives considered**:
- **No provenance tracking**: Rejected—loses context, makes pruning impossible
- **Timestamp-only**: Rejected—doesn't distinguish addition methods
- **Detailed event log**: Rejected—over-engineered for current needs

### 5. Size Limit & Pruning Strategy

**Decision**: Hard limit of 1000 nodes with warning at 900, prune auto-populated nodes older than 24 hours

**Rationale**:
- **Performance ceiling**: Graph rendering degrades beyond 1000 nodes (60fps requirement)
- **Memory constraints**: Tests run serially due to OOM issues—enforce limits proactively
- **Pruning target**: Auto-populated nodes are lowest-value (discovered automatically, not user-selected)
- **Age threshold**: 24 hours balances stale data removal with preserving recent exploration

**Implementation**:
```typescript
const GRAPH_LIST_CONFIG = {
  MAX_SIZE: 1000,
  WARNING_THRESHOLD: 900,
  PRUNE_AGE_MS: 24 * 60 * 60 * 1000, // 24 hours
} as const;

const pruneAutoPopulatedNodes = async (): Promise<number> => {
  const nodes = await storageProvider.getGraphList();
  const cutoffDate = new Date(Date.now() - GRAPH_LIST_CONFIG.PRUNE_AGE_MS);

  const nodesToRemove = nodes.filter(node =>
    node.provenance === 'auto-population' &&
    node.addedAt < cutoffDate
  );

  for (const node of nodesToRemove) {
    await storageProvider.removeFromGraphList(node.entityId);
  }

  return nodesToRemove.length;
};
```

**Alternatives considered**:
- **Unlimited size**: Rejected—causes performance degradation, OOM failures
- **LRU eviction**: Rejected—loses user-added nodes, complex to implement
- **Manual-only removal**: Rejected—poor UX for large graphs

### 6. Real-time UI Updates

**Decision**: Use Zustand store with optimistic updates + eventual consistency

**Rationale**:
- **Optimistic rendering**: UI updates immediately, storage persists asynchronously
- **Eventual consistency**: Background sync ensures UI reflects storage state
- **Performance**: Avoids blocking UI on IndexedDB transactions (can take 10-50ms)
- **Error handling**: Failed operations show toast notification, revert optimistic change

**State management**:
```typescript
interface GraphListState {
  nodes: GraphListNode[];
  isLoading: boolean;
  error: string | null;
  addNode: (node: GraphListNode) => Promise<void>;
  removeNode: (entityId: string) => Promise<void>;
  clearList: () => Promise<void>;
  refresh: () => Promise<void>;
}

const useGraphListStore = create<GraphListState>((set, get) => ({
  nodes: [],
  isLoading: false,
  error: null,

  addNode: async (node) => {
    // Optimistic update
    set(state => ({ nodes: [...state.nodes, node] }));

    try {
      await storageProvider.addToGraphList(node);
    } catch (error) {
      // Revert on failure
      set(state => ({ nodes: state.nodes.filter(n => n.entityId !== node.entityId) }));
      // Show error toast
      throw error;
    }
  },

  // Similar patterns for removeNode, clearList
}));
```

**Alternatives considered**:
- **Synchronous storage**: Rejected—blocks UI, poor UX
- **React Query only**: Rejected—adds complexity for simple CRUD operations
- **Redux**: Rejected—too heavyweight for this feature scope

## Technology Choices

### Primary Stack
- **TypeScript 5.9.2**: Existing project language, strict type safety
- **Dexie 4.0.10**: IndexedDB wrapper, existing storage foundation
- **Zustand 5.0.3 + Immer 10.1.1**: Lightweight state management, existing in project
- **Mantine 7.18.0**: UI components, existing design system
- **Vitest 3.0.0**: Testing framework, existing test infrastructure

### Testing Strategy
- **Unit tests**: Storage provider methods, provenance tracking, size limit enforcement
- **Component tests**: GraphListSidebar, GraphListNode, empty states
- **Integration tests**: Visibility logic, optimistic updates, error handling
- **E2E tests**: Persistence across sessions, prune functionality, size limit warnings

**Test execution**: Serial (existing constraint), use in-memory provider for speed

## Open Questions

None—all technical decisions resolved through codebase analysis and established patterns.

## Implementation Notes

1. **Backwards compatibility**: Not required (Constitution Principle VII)—new feature, no existing graph list data
2. **Migration**: Not needed—graph list is new, no existing data to migrate
3. **Breaking changes**: Acceptable during development—node visibility logic changes behavior
4. **Performance targets**: All specified in Technical Context, achievable with IndexedDB + optimistic updates

## Next Steps

Proceed to Phase 1 (Design & Contracts):
1. Generate data-model.md with GraphListNode schema
2. Generate storage-provider-graph-list.ts interface contract
3. Generate quickstart.md usage guide
4. Update agent context files
