
> @academic-explorer/web@8.1.0 lint /Users/joe/Documents/Research/PhD/Academic Explorer/apps/web
> eslint . --format=json

[{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/.lighthouserc.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/eslint.config.ts","messages":[{"ruleId":"@typescript-eslint/no-deprecated","severity":2,"message":"`config` is deprecated. ESLint core now provides this functionality via `defineConfig()`,\nwhich we now recommend instead. See {@link https://typescript-eslint.io/packages/typescript-eslint/#config-deprecated}.","line":4,"column":25,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":4,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import tseslint from 'typescript-eslint';\nimport reactConfig from '../../eslint.config.react.js';\n\nexport default tseslint.config([\n  {\n    // Global ignores for this app - exclude test files for now\n    ignores: [\n      'src/**/*.{test,spec}.{ts,tsx}',\n      'src/test/**/*.{ts,tsx}',\n    ],\n  },\n  ...reactConfig,\n  {\n    // Source files - use strict type checking (test files already ignored globally)\n    files: ['src/**/*.{ts,tsx}'],\n    languageOptions: {\n      parserOptions: {\n        project: './tsconfig.json',\n        tsconfigRootDir: import.meta.dirname,\n      },\n    },\n    rules: {\n      // App-specific rules\n      'no-console': 'warn', // Allow console in app development\n      '@typescript-eslint/no-explicit-any': 'warn', // More lenient for app code\n\n      // React-specific overrides for the app\n      'react-refresh/only-export-components': [\n        'warn',\n        { allowConstantExport: true },\n      ],\n\n      // Allow some flexibility in app code\n      '@typescript-eslint/no-unsafe-assignment': 'warn',\n      '@typescript-eslint/no-unsafe-member-access': 'warn',\n      '@typescript-eslint/no-unsafe-call': 'warn',\n    },\n  },\n  {\n    // Generated files\n    files: ['src/routeTree.gen.ts'],\n    rules: {\n      '@typescript-eslint/no-explicit-any': 'off',\n      '@typescript-eslint/no-unsafe-assignment': 'off',\n      '@typescript-eslint/no-unsafe-member-access': 'off',\n      'unused-imports/no-unused-imports': 'off',\n    },\n  },\n  {\n    // Config files - use dedicated tsconfig and disable type-aware rules\n    files: ['*.config.{ts,js}', 'vite.config.ts', 'vitest.config.ts', 'eslint.config.ts', 'playwright.config.ts', 'knip.ts'],\n    languageOptions: {\n      parserOptions: {\n        project: './tsconfig.config.json',\n        tsconfigRootDir: import.meta.dirname,\n      },\n    },\n    rules: {\n      'no-console': 'off',\n      '@typescript-eslint/no-explicit-any': 'off',\n      '@typescript-eslint/no-unsafe-assignment': 'off',\n      '@typescript-eslint/no-unsafe-member-access': 'off',\n      '@typescript-eslint/no-unsafe-call': 'off',\n      '@typescript-eslint/no-unsafe-return': 'off',\n      '@typescript-eslint/no-unsafe-argument': 'off',\n      '@typescript-eslint/no-floating-promises': 'off',\n      '@typescript-eslint/no-misused-promises': 'off',\n      '@typescript-eslint/restrict-template-expressions': 'off',\n    },\n  },\n  {\n    // Build plugins - also need special handling\n    files: ['src/build-plugins/**/*.{ts,js}'],\n    languageOptions: {\n      parserOptions: {\n        project: './tsconfig.config.json',\n        tsconfigRootDir: import.meta.dirname,\n      },\n    },\n    rules: {\n      'no-console': 'off',\n      '@typescript-eslint/no-explicit-any': 'off',\n      '@typescript-eslint/no-unsafe-assignment': 'off',\n      '@typescript-eslint/no-unsafe-member-access': 'off',\n      '@typescript-eslint/no-unsafe-call': 'off',\n      '@typescript-eslint/no-unsafe-return': 'off',\n      '@typescript-eslint/no-unsafe-argument': 'off',\n    },\n  },\n  // Test files are handled by the base configuration with project: false\n]);","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/knip.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/playwright.config.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":34,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":34,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[920,922],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Playwright configuration for Academic Explorer E2E tests\n * Integrates with Vitest for consistent test execution\n */\n\nimport { defineConfig, devices } from \"@playwright/test\"\n\nexport default defineConfig({\n\t// Test directory - but we use Vitest to run tests, so this is mainly for config\n\ttestDir: \"./src/e2e\",\n\n\t// Test files pattern (though Vitest handles discovery)\n\ttestMatch: \"**/*.e2e.test.ts\",\n\n\t// Run tests in serial to prevent memory issues\n\tfullyParallel: false,\n\tworkers: 1,\n\n\t// Fail the build on CI if you accidentally left test.only in the source code\n\tforbidOnly: !!process.env.CI,\n\n\t// Retry on CI only\n\tretries: process.env.CI ? 2 : 0,\n\n\t// Reporter configuration\n\treporter: [\n\t\t[\"list\"],\n\t\t[\"html\", { open: \"never\", outputFolder: \"test-results/playwright-report\" }]\n\t],\n\n\t// Shared settings for all projects\n\tuse: {\n\t\t// Base URL for tests - Vite dev server\n\t\tbaseURL: process.env.E2E_BASE_URL || \"http://localhost:5173\",\n\n\t\t// Collect trace when retrying the failed test\n\t\ttrace: \"on-first-retry\",\n\n\t\t// Record video on failure\n\t\tvideo: \"retain-on-failure\",\n\n\t\t// Take screenshot on failure\n\t\tscreenshot: \"only-on-failure\",\n\n\t\t// Browser context options\n\t\tviewport: { width: 1280, height: 720 },\n\t\tignoreHTTPSErrors: true,\n\n\t\t// Set user agent for consistency\n\t\tuserAgent: \"Academic-Explorer-E2E-Tests/1.0 Playwright\",\n\n\t\t// Timeout settings\n\t\tactionTimeout: 10000,\n\t\tnavigationTimeout: 30000,\n\t},\n\n\t// Test timeout\n\ttimeout: 90000,\n\n\t// Global setup and teardown\n\tglobalSetup: undefined, // Vitest handles this\n\tglobalTeardown: undefined, // Vitest handles this\n\n\t// Configure projects for major browsers\n\tprojects: [\n\t\t{\n\t\t\tname: \"chromium\",\n\t\t\tuse: { ...devices[\"Desktop Chrome\"] },\n\t\t},\n\n\t\t// Uncomment for cross-browser testing\n\t\t// {\n\t\t//   name: 'firefox',\n\t\t//   use: { ...devices['Desktop Firefox'] },\n\t\t// },\n\n\t\t// {\n\t\t//   name: 'webkit',\n\t\t//   use: { ...devices['Desktop Safari'] },\n\t\t// },\n\n\t\t// Mobile testing\n\t\t// {\n\t\t//   name: 'Mobile Chrome',\n\t\t//   use: { ...devices['Pixel 5'] },\n\t\t// },\n\t\t// {\n\t\t//   name: 'Mobile Safari',\n\t\t//   use: { ...devices['iPhone 12'] },\n\t\t// },\n\t],\n\n\t// Output directories\n\toutputDir: \"test-results/playwright-artifacts\",\n\n\t// Web server configuration - disabled since dev server runs separately\n\t// webServer: {\n\t// \tcommand: \"pnpm dev\",\n\t// \tport: 5173,\n\t// \treuseExistingServer: !process.env.CI,\n\t// \tstdout: \"pipe\",\n\t// \tstderr: \"pipe\",\n\t// \ttimeout: 120000,\n\t// \tenv: {\n\t// \t\tNODE_ENV: \"development\"\n\t// \t}\n\t// }\n})","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/build-plugins/openalex-data-plugin.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":90,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":90,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2749,2751],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":777,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":777,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[25130,25132],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":841,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":841,"endColumn":57,"fix":{"range":[27199,27249],"text":"url?.startsWith(\"https://api.openalex.org/\")"}},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":871,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":871,"endColumn":57,"fix":{"range":[27964,28014],"text":"url?.startsWith(\"https://api.openalex.org/\")"}},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":971,"column":54,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":971,"endColumn":71},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, comparison is always true, since `\"query\" === \"query\"` is true.","line":1000,"column":16,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":1000,"endColumn":39},{"ruleId":"prefer-destructuring","severity":2,"message":"Use object destructuring.","line":1131,"column":9,"nodeType":"VariableDeclarator","messageId":"preferDestructuring","endLine":1131,"endColumn":43,"fix":{"range":[37123,37157],"text":"{canonicalUrl} = parsed"}},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":1241,"column":13,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":1243,"endColumn":14,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[41375,41456],"text":"index[canonicalUrl] ??= {};"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, comparison is always true, since `\"query\" === \"query\"` is true.","line":1245,"column":22,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":1245,"endColumn":42},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":1262,"column":17,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":1264,"endColumn":18,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[42297,42396],"text":"index[canonicalQueryUrl] ??= {};"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":1335,"column":49,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":1335,"endColumn":64},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":1356,"column":51,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":1356,"endColumn":66},{"ruleId":"prefer-destructuring","severity":2,"message":"Use object destructuring.","line":1441,"column":9,"nodeType":"VariableDeclarator","messageId":"preferDestructuring","endLine":1441,"endColumn":38,"fix":{"range":[48262,48291],"text":"{results} = queryResult"}},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string. Got `string | undefined`.","line":1508,"column":60,"nodeType":"Identifier","messageId":"invalid","endLine":1508,"endColumn":68},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string. Got `string | undefined`.","line":1514,"column":31,"nodeType":"Identifier","messageId":"invalid","endLine":1514,"endColumn":39},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1545,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1545,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[52541,52543],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1546,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1546,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[52612,52614],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":1567,"column":49,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":1567,"endColumn":64},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":1574,"column":73,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":1574,"endColumn":99},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'count' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1580,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":1580,"endColumn":22},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'db_response_time_ms' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1580,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":1580,"endColumn":43},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'existingLastModified' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1776,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1776,"endColumn":47}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":4,"fixableWarningCount":0,"source":"/**\n * Comprehensive OpenAlex Data Management Plugin\n * - Downloads missing entity files when entities exist in index but files are missing\n * - Executes missing queries when query definitions exist but result files are missing\n * - Populates missing metadata in both entity and query index files\n * - Generates and maintains complete index files for all entity types\n * - Always runs at build time to ensure complete data availability\n */\nimport { readFile, writeFile, readdir, stat, access, mkdir, unlink } from \"fs/promises\";\nimport { join } from \"path\";\nimport { createHash } from \"crypto\";\nimport type { Plugin } from \"vite\";\nimport { z } from \"zod\";\nimport { logger } from \"@academic-explorer/utils\";\n// import { fetchOpenAlexQuery } from \"@academic-explorer/client\";\n\n// Import additional utilities for direct filename control\n\n// Unified Index Structure\ninterface IndexEntry {\n  lastModified?: string;\n  contentHash?: string;\n}\n\n// Unified index: keys can be queries, entities, or URLs in various formats\ninterface UnifiedIndex {\n  [key: string]: IndexEntry;\n}\n\n// Zod schemas for type validation\nconst IndexEntrySchema = z.object({\n  lastModified: z.string().optional(),\n  contentHash: z.string().optional(),\n});\n\nconst QueryParamsSchema = z.record(z.string(), z.unknown());\n\nconst QueryDefinitionSchema = z.object({\n  params: QueryParamsSchema.optional(),\n  url: z.string().optional(),\n  lastModified: z.string().optional(),\n  contentHash: z.string().optional(),\n});\n\nconst OldEntityIndexSchema = z.object({\n  entityType: z.string(),\n  entities: z.array(z.string()),\n});\n\nconst OldQueryIndexSchema = z.object({\n  entityType: z.string().optional(),\n  queries: z.union([\n    z.array(z.object({\n      query: QueryDefinitionSchema,\n      lastModified: z.string().optional(),\n      contentHash: z.string().optional(),\n    })),\n    z.record(z.string(), QueryDefinitionSchema),\n  ]),\n});\n\nconst RequestsWrapperSchema = z.object({\n  requests: z.record(z.string(), z.object({\n    $ref: z.string().optional(),\n    lastModified: z.string().optional(),\n    contentHash: z.string().optional(),\n  })),\n});\n\nconst FlatIndexSchema = z.record(z.string(), IndexEntrySchema);\n\n\nconst ENTITY_TYPES = [\"works\", \"authors\", \"institutions\", \"topics\", \"sources\", \"publishers\", \"funders\", \"concepts\", \"autocomplete\"];\n\n/**\n * Get the OpenAlex ID prefix for a given entity type\n */\nfunction getEntityPrefix(entityType: string): string {\n  const prefixMap: Record<string, string> = {\n    \"works\": \"W\",\n    \"authors\": \"A\",\n    \"institutions\": \"I\",\n    \"topics\": \"T\",\n    \"sources\": \"S\",\n    \"publishers\": \"P\",\n    \"funders\": \"F\",\n    \"concepts\": \"C\",\n    \"autocomplete\": \"\" // Autocomplete doesn't use entity prefixes, only queries\n  };\n  return prefixMap[entityType] || \"\";\n}\n\n/**\n * Parse a unified index key to determine what type of resource it represents\n */\ninterface ParsedKey {\n  type: \"entity\" | \"query\";\n  entityType: string;\n  entityId?: string;\n  queryParams?: Record<string, unknown>;\n  originalKey: string;\n  canonicalUrl: string;\n}\n\n/**\n * Detect malformed filenames that should be removed from filesystem\n * Returns true if the filename represents a malformed double-encoded URL\n */\nfunction detectMalformedFilename(filename: string): boolean {\n  // Pattern 1: Triple slashes in URL-encoded format (corrupted double-encoding)\n  // Example: https%2F%2F%2Fapi%2Eopenalex%2Eorg (should be https%2F%2Fapi.openalex.org)\n  if (filename.includes(\"%2F%2F%2F\")) {\n    return true;\n  }\n\n  // Pattern 2: Double-encoded URLs embedded in paths\n  // Example: https%3A%2F%2Fapi.openalex.org%2Fauthors%2FAhttps%252F%252F\n  if (filename.includes(\"https%252F%252F\")) {\n    return true;\n  }\n\n  // Pattern 3: Entity ID starting with encoded URL prefix\n  // Example: Ahttps%2F%2F (entity ID should not start with URL)\n  if (/^[A-Z]https%2F%2F/.test(filename)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Detect and clean malformed double-encoded keys\n * Handles cases like: \"https://api.openalex.org/authors/Ahttps%2F%2F%2Fapi%2Eopenalex%2Eorg%2Fauthors%2FA5025875274\"\n */\nfunction detectAndCleanMalformedKey(key: string): string {\n  // Pattern 1: Double-encoded URLs embedded in entity paths\n  // Example: \"https://api.openalex.org/authors/Ahttps%2F%2F%2Fapi%2Eopenalex%2Eorg%2Fauthors%2FA5025875274\"\n  const doubleEncodedPattern = /^https:\\/\\/api\\.openalex\\.org\\/(\\w+)\\/[A-Z]https%2F%2F/;\n  if (doubleEncodedPattern.test(key)) {\n    // Extract the embedded encoded URL and decode it\n    const match = key.match(/^https:\\/\\/api\\.openalex\\.org\\/\\w+\\/[A-Z](https%2F%2F.+)$/);\n    if (match) {\n      try {\n        let embeddedUrl = decodeURIComponent(match[1]);\n        // Fix malformed protocol separator\n        embeddedUrl = embeddedUrl.replace(/^https\\/\\/\\//, \"https://\");\n        logger.debug(\"general\", \"Extracted embedded URL from malformed key\", {\n          original: key,\n          extracted: embeddedUrl\n        });\n        return embeddedUrl;\n      } catch {\n        // Decoding failed, continue with other patterns\n      }\n    }\n  }\n\n  // Pattern 2: Entity ID starting with encoded URL\n  // Example: \"Ahttps%2F%2F%2Fapi%2Eopenalex%2Eorg%2Fauthors%2FA5025875274\"\n  const encodedEntityPattern = /^[A-Z]https%2F%2F/;\n  if (encodedEntityPattern.test(key)) {\n    try {\n      // Remove the prefix letter and decode\n      const withoutPrefix = key.substring(1);\n      let decodedUrl = decodeURIComponent(withoutPrefix);\n      // Fix malformed protocol separator\n      decodedUrl = decodedUrl.replace(/^https\\/\\/\\//, \"https://\");\n      logger.debug(\"general\", \"Decoded malformed entity ID\", {\n        original: key,\n        decoded: decodedUrl\n      });\n      return decodedUrl;\n    } catch {\n      // Decoding failed, continue\n    }\n  }\n\n  // Pattern 3: Multiple URL encoding layers\n  // Try progressive decoding until we get a valid URL or stop changing\n  let current = key;\n  let previous = \"\";\n  let attempts = 0;\n  const maxDecodeAttempts = 5;\n\n  while (current !== previous && attempts < maxDecodeAttempts) {\n    previous = current;\n    try {\n      const decoded = decodeURIComponent(current);\n      if (decoded !== current && (decoded.startsWith(\"https://\") || decoded.match(/^[A-Z]\\d+$/))) {\n        current = decoded;\n        attempts++;\n      } else {\n        break;\n      }\n    } catch {\n      break;\n    }\n  }\n\n  if (current !== key && attempts > 0) {\n    logger.debug(\"general\", \"Progressive decoding cleaned malformed key\", {\n      original: key,\n      cleaned: current,\n      attempts\n    });\n  }\n\n  return current;\n}\n\n/**\n * Parse various key formats into a standardized structure\n */\nfunction parseIndexKey(key: string): ParsedKey | null {\n  // Note: Malformed key detection is now handled at the caller level\n  // to avoid recursive cleaning that masks the original malformed state\n\n  // Handle full OpenAlex URLs\n  if (key.startsWith(\"https://api.openalex.org/\")) {\n    return parseOpenAlexApiUrl(key);\n  }\n\n  if (key.startsWith(\"https://openalex.org/\")) {\n    return parseOpenAlexUrl(key);\n  }\n\n  // Handle relative paths and entity IDs\n  if (key.includes(\"?\")) {\n    // Query format like \"works?per_page=30&page=1\" or \"autocomplete?q=foo\"\n    return parseRelativeQuery(key);\n  }\n\n  if (key.includes(\"/\")) {\n    // Entity path format like \"works/W2241997964\"\n    return parseEntityPath(key);\n  }\n\n  // Direct entity ID like \"W1234\"\n  return parseDirectEntityId(key);\n}\n\nfunction parseOpenAlexApiUrl(url: string): ParsedKey | null {\n  try {\n    const urlObj = new URL(url);\n    const pathParts = urlObj.pathname.split(\"/\").filter(p => p);\n\n    if (pathParts.length === 1) {\n      // Query: https://api.openalex.org/works?per_page=30&page=1\n      const entityType = pathParts[0];\n      const queryParams: Record<string, unknown> = {};\n\n      for (const [key, value] of urlObj.searchParams.entries()) {\n        queryParams[key] = value;\n      }\n\n      return {\n        type: \"query\",\n        entityType,\n        queryParams,\n        originalKey: url,\n        canonicalUrl: url\n      };\n    } else if (pathParts.length === 2) {\n      // Entity: https://api.openalex.org/works/W2241997964\n      const entityType = pathParts[0];\n      const entityId = pathParts[1];\n\n      const queryParams: Record<string, unknown> = {};\n      for (const [key, value] of urlObj.searchParams.entries()) {\n        queryParams[key] = value;\n      }\n\n      if (Object.keys(queryParams).length > 0) {\n        // Entity with query params\n        return {\n          type: \"query\",\n          entityType,\n          entityId,\n          queryParams,\n          originalKey: url,\n          canonicalUrl: url\n        };\n      } else {\n        // Pure entity\n        return {\n          type: \"entity\",\n          entityType,\n          entityId,\n          originalKey: url,\n          canonicalUrl: `https://api.openalex.org/${entityType}/${entityId}`\n        };\n      }\n    }\n  } catch {\n    return null;\n  }\n  return null;\n}\n\nfunction parseOpenAlexUrl(url: string): ParsedKey | null {\n  try {\n    const urlObj = new URL(url);\n    const pathParts = urlObj.pathname.split(\"/\").filter(p => p);\n\n    if (pathParts.length === 1) {\n      // Direct entity: https://openalex.org/W2241997964\n      const entityId = pathParts[0];\n      const entityType = inferEntityTypeFromId(entityId);\n\n      return {\n        type: \"entity\",\n        entityType,\n        entityId,\n        originalKey: url,\n        canonicalUrl: `https://api.openalex.org/${entityType}/${entityId}`\n      };\n    } else if (pathParts.length === 2) {\n      // Entity with type: https://openalex.org/works/W2241997964\n      const entityType = pathParts[0];\n      const entityId = pathParts[1];\n\n      return {\n        type: \"entity\",\n        entityType,\n        entityId,\n        originalKey: url,\n        canonicalUrl: `https://api.openalex.org/${entityType}/${entityId}`\n      };\n    }\n  } catch {\n    return null;\n  }\n  return null;\n}\n\nfunction parseRelativeQuery(key: string): ParsedKey | null {\n  const [path, queryString] = key.split(\"?\");\n\n  try {\n    const queryParams: Record<string, unknown> = {};\n    const searchParams = new URLSearchParams(queryString);\n\n    for (const [paramKey, value] of searchParams.entries()) {\n      queryParams[paramKey] = value;\n    }\n\n    return {\n      type: \"query\",\n      entityType: path,\n      queryParams,\n      originalKey: key,\n      canonicalUrl: `https://api.openalex.org/${path}?${queryString}`\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction parseEntityPath(key: string): ParsedKey | null {\n  const parts = key.split(\"/\");\n  if (parts.length === 2) {\n    const [entityType, entityId] = parts;\n\n    return {\n      type: \"entity\",\n      entityType,\n      entityId,\n      originalKey: key,\n      canonicalUrl: `https://api.openalex.org/${entityType}/${entityId}`\n    };\n  }\n  return null;\n}\n\nfunction parseDirectEntityId(key: string): ParsedKey | null {\n  const entityType = inferEntityTypeFromId(key);\n\n  return {\n    type: \"entity\",\n    entityType,\n    entityId: key,\n    originalKey: key,\n    canonicalUrl: `https://api.openalex.org/${entityType}/${key}`\n  };\n}\n\n/**\n * Infer entity type from OpenAlex ID prefix\n */\nfunction inferEntityTypeFromId(id: string): string {\n  if (id.startsWith(\"W\")) return \"works\";\n  if (id.startsWith(\"A\")) return \"authors\";\n  if (id.startsWith(\"I\")) return \"institutions\";\n  if (id.startsWith(\"T\")) return \"topics\";\n  if (id.startsWith(\"S\")) return \"sources\";\n  if (id.startsWith(\"P\")) return \"publishers\";\n  if (id.startsWith(\"F\")) return \"funders\";\n  if (id.startsWith(\"C\")) return \"concepts\";\n\n  // Default fallback\n  return \"works\";\n}\n\n/**\n * Download entity directly with encoded filename (avoids temporary file creation)\n * Returns: true for success, false for non-404 errors, \"not_found\" for 404 errors,\n * or { redirected: true, finalUrl: string } for redirected URLs\n */\nasync function downloadEntityWithEncodedFilename(\n  entityType: string,\n  entityId: string,\n  targetFilePath: string\n): Promise<boolean | \"not_found\" | { redirected: true; finalUrl: string }> {\n  try {\n    // Entity type mapping (same as in openalex-downloader)\n    const ENTITY_TYPE_TO_ENDPOINT: Record<string, string> = {\n      \"authors\": \"authors\",\n      \"works\": \"works\",\n      \"institutions\": \"institutions\",\n      \"topics\": \"topics\",\n      \"publishers\": \"publishers\",\n      \"funders\": \"funders\",\n      \"sources\": \"sources\",\n      \"concepts\": \"concepts\"\n    };\n\n    const endpoint = ENTITY_TYPE_TO_ENDPOINT[entityType];\n    if (!endpoint) {\n      logger.error(\"general\", \"Unknown entity type\", { entityType });\n      return false;\n    }\n\n    // Construct API URL using same config as openalex-downloader\n    const apiUrl = `https://api.openalex.org/${endpoint}/${entityId}`;\n\n    logger.debug(\"general\", \"Downloading entity from OpenAlex\", { entityType, entityId });\n\n    // Follow redirects manually to handle chains and track final URL\n    let currentUrl = apiUrl;\n    let finalUrl = apiUrl;\n    const maxRedirects = 10; // Prevent infinite redirect loops\n    let redirectCount = 0;\n    const redirectChain: string[] = [apiUrl];\n\n    while (redirectCount < maxRedirects) {\n      logger.debug(\"general\", \"Fetching URL\", { currentUrl, redirectCount });\n\n      const response = await fetch(currentUrl, { redirect: \"manual\" });\n\n      // Handle redirects (302, 301, etc.)\n      if (response.status >= 300 && response.status < 400) {\n        const location = response.headers.get(\"Location\");\n        if (!location) {\n          logger.error(\"general\", \"Redirect response missing Location header\", {\n            entityType,\n            entityId,\n            status: response.status,\n            currentUrl\n          });\n          return false;\n        }\n\n        // Resolve relative URLs\n        const redirectUrl = new URL(location, currentUrl).toString();\n        redirectChain.push(redirectUrl);\n\n        logger.debug(\"general\", \"Following redirect\", {\n          entityType,\n          entityId,\n          status: response.status,\n          from: currentUrl,\n          to: redirectUrl,\n          redirectCount: redirectCount + 1\n        });\n\n        currentUrl = redirectUrl;\n        finalUrl = redirectUrl;\n        redirectCount++;\n        continue; // Follow the redirect\n      }\n\n      // Non-redirect response - process it\n      if (!response.ok) {\n        if (response.status === 404) {\n          logger.warn(\"general\", \"Entity not found (404) after redirect chain - will remove from index\", {\n            entityType,\n            entityId,\n            status: response.status,\n            finalUrl,\n            redirectChain: redirectChain.length > 1 ? redirectChain : undefined\n          });\n          return \"not_found\";\n        }\n\n        logger.error(\"general\", \"Failed to download entity after redirect chain\", {\n          entityType,\n          entityId,\n          status: response.status,\n          statusText: response.statusText,\n          finalUrl,\n          redirectChain: redirectChain.length > 1 ? redirectChain : undefined\n        });\n        return false;\n      }\n\n      // Success - process the response\n      const rawJsonText = await response.text();\n      if (!rawJsonText) {\n        logger.error(\"general\", \"Failed to download entity: empty response\", {\n          entityType,\n          entityId,\n          finalUrl\n        });\n        return false;\n      }\n\n      // Parse and re-stringify for consistent formatting\n      const parsedData: unknown = JSON.parse(rawJsonText);\n      const prettyJson = JSON.stringify(parsedData, null, 2);\n\n      // Save directly to target path with encoded filename\n      await writeFile(targetFilePath, prettyJson);\n\n      // Determine if this was redirected\n      const wasRedirected = redirectCount > 0;\n\n      if (wasRedirected) {\n        logger.debug(\"general\", \"Downloaded and saved redirected entity after chain\", {\n          entityType,\n          entityId,\n          originalUrl: apiUrl,\n          finalUrl,\n          redirectCount,\n          redirectChain\n        });\n        return { redirected: true, finalUrl };\n      } else {\n        logger.debug(\"general\", \"Downloaded and saved entity\", { entityType, entityId });\n        return true;\n      }\n    }\n\n    // If we get here, we hit the redirect limit\n    logger.error(\"general\", \"Too many redirects - redirect loop detected\", {\n      entityType,\n      entityId,\n      maxRedirects,\n      redirectChain\n    });\n    return false;\n  } catch (error) {\n    logger.error(\"general\", \"Error downloading entity\", {\n      entityType,\n      entityId,\n      error: error instanceof Error ? error.message : String(error)\n    });\n    return false;\n  }\n}\n\nexport function openalexDataPlugin(): Plugin {\n  return {\n    name: \"openalex-data-management\",\n    buildStart: {\n      order: \"pre\",\n      async handler() {\n        logger.debug(\"general\", \"Starting comprehensive OpenAlex data management\");\n\n        const dataPath = \"public/data/openalex\";\n\n        for (const entityType of ENTITY_TYPES) {\n          try {\n            logger.debug(\"general\", \"Processing entity type\", { entityType });\n\n            // 1. Load or create unified index\n            let index = await loadUnifiedIndex(dataPath, entityType);\n\n            // 2. Seed missing data based on index entries and get updates to apply\n            const { keysToRemove, redirectUpdates } = await seedMissingData(dataPath, entityType, index);\n\n            // 3. Apply index updates: remove 404 entries and update redirected entries\n            if (keysToRemove.size > 0 || redirectUpdates.length > 0) {\n              logger.debug(\"general\", \"Applying index updates\", {\n                removals: keysToRemove.size,\n                redirects: redirectUpdates.length,\n                entityType\n              });\n\n              // Create new index without removed keys and with updated redirected keys\n              const updatedIndex: UnifiedIndex = {};\n\n              for (const [key, metadata] of Object.entries(index)) {\n                // Skip keys marked for removal\n                if (keysToRemove.has(key)) {\n                  continue;\n                }\n\n                // Check if this key has a redirect update\n                const redirectUpdate = redirectUpdates.find(update => update.oldKey === key);\n                if (redirectUpdate) {\n                  // Use new key with updated metadata\n                  const fixedMetadata = { ...redirectUpdate.metadata };\n                  // Fix $ref if it exists and needs updating\n                  if (\"$ref\" in fixedMetadata && typeof fixedMetadata.$ref === \"string\") {\n                    fixedMetadata.$ref = `./${urlToEncodedKey(redirectUpdate.newKey)}.json`;\n                  }\n                  updatedIndex[redirectUpdate.newKey] = fixedMetadata;\n                } else {\n                  // Keep existing key\n                  updatedIndex[key] = metadata;\n                }\n              }\n\n              index = updatedIndex;\n\n              logger.debug(\"general\", \"Applied index updates\", {\n                removedCount: keysToRemove.size,\n                redirectedCount: redirectUpdates.length,\n                totalCount: Object.keys(index).length,\n                entityType\n              });\n            }\n\n            // 4. Reformat existing files for consistency\n            await reformatExistingFiles(dataPath, entityType);\n\n            // 5. Migrate query files from queries subdirectory to entity directory\n            await migrateQueryFilesToEntityDirectory(dataPath, entityType);\n\n            // 6. Scan and update unified index with both entities and queries\n            const unifiedIndex = await updateUnifiedIndex(dataPath, entityType, index);\n\n            // 7. Save unified index\n            await saveUnifiedIndex(dataPath, entityType, unifiedIndex);\n\n          } catch (error) {\n            logger.error(\"general\", \"Error processing entity type\", {\n              entityType,\n              error: error instanceof Error ? error.message : String(error)\n            });\n          }\n        }\n\n        // Generate main index with JSON $ref structure\n        try {\n          logger.debug(\"general\", \"Generating main index with JSON $ref structure\");\n          await generateMainIndex(dataPath);\n        } catch (error) {\n          logger.error(\"general\", \"Error generating main index\", {\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n\n        logger.debug(\"general\", \"OpenAlex data management completed\");\n      }\n    }\n  };\n}\n\n/**\n * Load unified index for an entity type\n */\nasync function loadUnifiedIndex(dataPath: string, entityType: string): Promise<UnifiedIndex> {\n  const indexPath = join(dataPath, entityType, \"index.json\");\n\n  try {\n    const indexContent = await readFile(indexPath, \"utf-8\");\n    const parsed: unknown = JSON.parse(indexContent);\n\n    // Try parsing as requests wrapper format first\n    const requestsWrapper = RequestsWrapperSchema.safeParse(parsed);\n    if (requestsWrapper.success) {\n      // Clean and normalize existing unified format from requests\n      const cleaned: UnifiedIndex = {};\n      for (const [key, entry] of Object.entries(requestsWrapper.data.requests)) {\n        // Validate entry structure\n        const validatedEntry = IndexEntrySchema.safeParse(entry);\n        if (!validatedEntry.success) continue;\n\n        // Parse the key and get its canonical form\n        const parsedKey = parseIndexKey(key);\n        if (parsedKey && parsedKey.type === \"entity\") {\n          // Only include entity entries in the entity index\n          // Normalize the canonical URL to decoded form\n          const canonicalKey = normalizeUrlForDeduplication(parsedKey.canonicalUrl);\n          const cleanEntry: IndexEntry = {};\n          if (validatedEntry.data.lastModified) {\n            cleanEntry.lastModified = validatedEntry.data.lastModified;\n          }\n          if (validatedEntry.data.contentHash) {\n            cleanEntry.contentHash = validatedEntry.data.contentHash;\n          }\n\n          // Merge with existing entry if duplicate canonical keys exist\n          if (cleaned[canonicalKey]) {\n            // Keep the most recent lastModified\n            if (cleanEntry.lastModified && (!cleaned[canonicalKey].lastModified ||\n                cleanEntry.lastModified > cleaned[canonicalKey].lastModified)) {\n              cleaned[canonicalKey] = cleanEntry;\n            }\n          } else {\n            cleaned[canonicalKey] = cleanEntry;\n          }\n        }\n        // Skip query entries - they will be handled by the separate query index\n      }\n      return cleaned;\n    }\n\n    // Try parsing as flat index format\n    const flatIndex = FlatIndexSchema.safeParse(parsed);\n    if (flatIndex.success) {\n      logger.debug(\"general\", \"Converting flat index format to requests wrapper format\");\n      // Clean and normalize existing unified format from flat structure\n      const cleaned: UnifiedIndex = {};\n      for (const [key, entry] of Object.entries(flatIndex.data)) {\n        // Parse the key and get its canonical form\n        const parsedKey = parseIndexKey(key);\n        if (parsedKey) {\n          // Normalize the canonical URL to decoded form\n          const canonicalKey = normalizeUrlForDeduplication(parsedKey.canonicalUrl);\n          const cleanEntry: IndexEntry = {};\n          if (entry.lastModified) {\n            cleanEntry.lastModified = entry.lastModified;\n          }\n          if (entry.contentHash) {\n            cleanEntry.contentHash = entry.contentHash;\n          }\n\n          // Merge with existing entry if duplicate canonical keys exist\n          if (cleaned[canonicalKey]) {\n            // Keep the most recent lastModified\n            if (cleanEntry.lastModified && (!cleaned[canonicalKey].lastModified ||\n                cleanEntry.lastModified > cleaned[canonicalKey].lastModified)) {\n              cleaned[canonicalKey] = cleanEntry;\n            }\n          } else {\n            cleaned[canonicalKey] = cleanEntry;\n          }\n        }\n      }\n      return cleaned;\n    }\n\n    // Convert from old format if needed\n    logger.debug(\"general\", \"Converting old index format to unified format\");\n    return convertOldIndexToUnified(parsed);\n  } catch {\n    logger.debug(\"general\", \"Creating new unified index\");\n    return {};\n  }\n}\n\n/**\n * Convert old index formats to unified format\n */\nfunction convertOldIndexToUnified(oldIndex: unknown): UnifiedIndex {\n  const unified: UnifiedIndex = {};\n\n  // Try parsing as old entity index format\n  const entityIndex = OldEntityIndexSchema.safeParse(oldIndex);\n  if (entityIndex.success) {\n    for (const entityId of entityIndex.data.entities) {\n      // Ensure entityId has proper OpenAlex prefix\n      const prefix = getEntityPrefix(entityIndex.data.entityType);\n      const fullEntityId = entityId.startsWith(prefix) ? entityId : prefix + entityId;\n\n      // Create canonical URL entry\n      const canonicalKey = `https://api.openalex.org/${entityIndex.data.entityType}/${fullEntityId}`;\n      unified[canonicalKey] = {};\n    }\n  }\n\n  // Try parsing as old query index format\n  const queryIndex = OldQueryIndexSchema.safeParse(oldIndex);\n  if (queryIndex.success) {\n    const entityType = queryIndex.data.entityType || \"works\";\n\n    if (Array.isArray(queryIndex.data.queries)) {\n      // New flexible query format\n      for (const queryEntry of queryIndex.data.queries) {\n        const canonicalKey = generateCanonicalQueryKey(queryEntry.query, entityType);\n        if (canonicalKey) {\n          const cleanEntry: IndexEntry = {\n            lastModified: queryEntry.lastModified,\n            contentHash: queryEntry.contentHash\n          };\n          unified[canonicalKey] = cleanEntry;\n        }\n      }\n    } else {\n      // Old object-based query format\n      for (const [, entry] of Object.entries(queryIndex.data.queries)) {\n        // Generate canonical key from the old entry\n        const canonicalKey = generateCanonicalQueryKeyFromEntry(entry, entityType);\n        if (canonicalKey) {\n          // Parse the entry with Zod to ensure type safety\n          const parsedEntry = QueryDefinitionSchema.safeParse(entry);\n          if (parsedEntry.success) {\n            const cleanEntry: IndexEntry = {};\n            if (parsedEntry.data.lastModified) {\n              cleanEntry.lastModified = parsedEntry.data.lastModified;\n            }\n            if (parsedEntry.data.contentHash) {\n              cleanEntry.contentHash = parsedEntry.data.contentHash;\n            }\n            unified[canonicalKey] = cleanEntry;\n          }\n        }\n      }\n    }\n  }\n\n  return unified;\n}\n\n/**\n * Generate canonical query key from a query definition\n */\nfunction generateCanonicalQueryKey(query: unknown, entityType: string): string | null {\n  const parsed = QueryDefinitionSchema.safeParse(query);\n  if (!parsed.success) {\n    return null;\n  }\n\n  const { params, url } = parsed.data;\n\n  if (params) {\n    // Generate canonical query URL\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(params)) {\n      if (Array.isArray(value)) {\n        searchParams.set(key, value.join(\",\"));\n      } else {\n        searchParams.set(key, String(value));\n      }\n    }\n    return `https://api.openalex.org/${entityType}?${searchParams.toString()}`;\n  }\n\n  if (url && url.startsWith(\"https://api.openalex.org/\")) {\n    return url;\n  }\n\n  return null;\n}\n\n/**\n * Generate canonical query key from old entry format\n */\nfunction generateCanonicalQueryKeyFromEntry(entry: unknown, entityType: string): string | null {\n  const parsed = QueryDefinitionSchema.safeParse(entry);\n  if (!parsed.success) {\n    return null;\n  }\n\n  const { params, url } = parsed.data;\n\n  if (params) {\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(params)) {\n      if (Array.isArray(value)) {\n        searchParams.set(key, value.join(\",\"));\n      } else {\n        searchParams.set(key, String(value));\n      }\n    }\n    return `https://api.openalex.org/${entityType}?${searchParams.toString()}`;\n  }\n\n  if (url && url.startsWith(\"https://api.openalex.org/\")) {\n    return url;\n  }\n\n  return null;\n}\n\n/**\n * Seed missing data based on unified index entries\n * Returns updates to be applied to the index: removals and redirects\n */\nasync function seedMissingData(dataPath: string, entityType: string, index: UnifiedIndex): Promise<{\n  keysToRemove: Set<string>;\n  redirectUpdates: Array<{ oldKey: string; newKey: string; metadata: IndexEntry }>;\n}> {\n  let downloadedEntities = 0;\n  let executedQueries = 0;\n  const keysToRemove = new Set<string>();\n  const redirectUpdates: Array<{ oldKey: string; newKey: string; metadata: IndexEntry }> = [];\n\n  for (const [key, metadata] of Object.entries(index)) {\n    // Check if this key contains malformed patterns and can be cleaned\n    const cleanKey = detectAndCleanMalformedKey(key);\n    if (cleanKey !== key) {\n      // This is a malformed key that got cleaned\n      logger.warn(\"general\", \"Found malformed index key - will fix\", {\n        entityType,\n        originalKey: key,\n        cleanedKey: cleanKey\n      });\n\n      // Parse the cleaned key to verify it's valid and belongs to this entity type\n      const cleanedParsed = parseIndexKey(cleanKey);\n      if (cleanedParsed && cleanedParsed.entityType === entityType && cleanedParsed.type === \"entity\") {\n        // Valid cleaned key - add to redirect updates\n        redirectUpdates.push({\n          oldKey: key,\n          newKey: cleanKey,\n          metadata: {\n            ...metadata,\n            lastModified: new Date().toISOString()\n          }\n        });\n        logger.warn(\"general\", \"Will replace malformed key with cleaned version\", {\n          entityType,\n          oldKey: key,\n          newKey: cleanKey\n        });\n      } else {\n        // Cleaned key is still invalid or doesn't belong to this entity type\n        logger.warn(\"general\", \"Cleaned key is still invalid - will remove\", {\n          entityType,\n          originalKey: key,\n          cleanedKey: cleanKey,\n          ...(cleanedParsed?.entityType !== undefined && { cleanedEntityType: cleanedParsed.entityType }),\n          ...(cleanedParsed?.type !== undefined && { cleanedType: cleanedParsed.type })\n        });\n        keysToRemove.add(key);\n      }\n      continue; // Skip normal processing for malformed keys\n    }\n\n    const parsed = parseIndexKey(key);\n    if (!parsed) {\n      // If we can't parse it even after cleaning, mark for removal\n      logger.warn(\"general\", \"Unparseable index key - will remove\", {\n        entityType,\n        key\n      });\n      keysToRemove.add(key);\n      continue;\n    }\n\n    // Only process entries that belong to this entity type\n    if (parsed.entityType !== entityType) continue;\n\n    if (parsed.type === \"entity\") {\n      // Check if entity file exists using encoded filename format\n      const encodedFilename = urlToEncodedKey(parsed.canonicalUrl) + \".json\";\n      const entityFilePath = join(dataPath, entityType, encodedFilename);\n\n      try {\n        await access(entityFilePath);\n      } catch {\n        // File doesn't exist - download it\n        try {\n          logger.debug(\"general\", \"Downloading entity\", { entityType, entityId: parsed.entityId });\n          await mkdir(join(dataPath, entityType), { recursive: true });\n          if (parsed.entityId) {\n            const result = await downloadEntityWithEncodedFilename(entityType, parsed.entityId, entityFilePath);\n\n            if (result === true) {\n              logger.debug(\"general\", \"Downloaded entity file\", { encodedFilename });\n              downloadedEntities++;\n            } else if (result === \"not_found\") {\n              logger.warn(\"general\", \"Entity not found - removing from index\", {\n                entityId: parsed.entityId,\n                key\n              });\n              keysToRemove.add(key);\n            } else if (typeof result === \"object\" && result.redirected) {\n              logger.warn(\"general\", \"Entity redirected - updating index key\", {\n                entityId: parsed.entityId,\n                oldKey: key,\n                newKey: result.finalUrl\n              });\n\n              // Add redirect update\n              redirectUpdates.push({\n                oldKey: key,\n                newKey: result.finalUrl,\n                metadata: {\n                  ...metadata,\n                  lastModified: new Date().toISOString()\n                }\n              });\n              downloadedEntities++;\n            } else {\n              logger.warn(\"general\", \"Failed to download entity: no data returned\", { entityId: parsed.entityId });\n            }\n          }\n        } catch (downloadError) {\n          logger.error(\"general\", \"Error downloading entity\", {\n            entityId: parsed.entityId,\n            error: downloadError instanceof Error ? downloadError.message : String(downloadError)\n          });\n        }\n      }\n\n    } else if (parsed.type === \"query\") {\n      // Check if query result file exists in the entity directory\n      const filename = generateFilenameFromParsedKey(parsed);\n      if (!filename) continue;\n\n      const queryFilePath = join(dataPath, entityType, filename);\n\n      try {\n        await access(queryFilePath);\n      } catch {\n        // File doesn't exist - execute query\n        try {\n          logger.debug(\"general\", \"Executing query\", { key });\n\n          const queryUrl = parsed.canonicalUrl;\n          const queryResult = await fetchOpenAlexQuery(queryUrl);\n\n          if (queryResult) {\n            const entityDir = join(dataPath, entityType);\n            await mkdir(entityDir, { recursive: true });\n            // Write the query result directly to entity directory\n            await writeFile(join(entityDir, filename), JSON.stringify(queryResult, null, 2));\n            logger.debug(\"general\", \"Executed and cached query\", { filename });\n            executedQueries++;\n          } else {\n            logger.warn(\"general\", \"Failed to execute query: no data returned\", { key });\n          }\n        } catch (queryError) {\n          logger.error(\"general\", \"Error executing query\", {\n            key,\n            error: queryError instanceof Error ? queryError.message : String(queryError)\n          });\n        }\n      }\n    }\n  }\n\n  if (downloadedEntities > 0 || executedQueries > 0) {\n    logger.debug(\"general\", \"Downloaded entities and executed queries\", { downloadedEntities, executedQueries });\n  } else {\n    logger.debug(\"general\", \"All referenced data files present\");\n  }\n\n  if (keysToRemove.size > 0) {\n    logger.debug(\"general\", \"Found invalid entities to remove from index\", {\n      count: keysToRemove.size,\n      entityType\n    });\n  }\n\n  if (redirectUpdates.length > 0) {\n    logger.debug(\"general\", \"Found redirected entities to update in index\", {\n      count: redirectUpdates.length,\n      entityType\n    });\n  }\n\n  return { keysToRemove, redirectUpdates };\n}\n\n/**\n * Ensure consistent JSON formatting for all files\n */\nfunction formatJsonConsistently(jsonContent: string): string {\n  try {\n    const parsed: unknown = JSON.parse(jsonContent);\n    return JSON.stringify(parsed, null, 2);\n  } catch {\n    // If parsing fails, return original content\n    logger.warn(\"general\", \"Could not parse JSON for formatting\");\n    return jsonContent;\n  }\n}\n\n/**\n * Reformat existing JSON files for consistency\n */\nasync function reformatExistingFiles(dataPath: string, entityType: string): Promise<void> {\n  const entityDir = join(dataPath, entityType);\n\n  try {\n    const files = await readdir(entityDir);\n    let reformattedCount = 0;\n\n    for (const file of files) {\n      if (file.endsWith(\".json\") && file !== \"index.json\") {\n        const filePath = join(entityDir, file);\n\n        try {\n          const originalContent = await readFile(filePath, \"utf-8\");\n          const formattedContent = formatJsonConsistently(originalContent);\n\n          // Only write if content changed\n          if (originalContent !== formattedContent) {\n            await writeFile(filePath, formattedContent);\n            reformattedCount++;\n          }\n        } catch {\n          logger.warn(\"general\", \"Could not reformat file\", { file });\n        }\n      }\n    }\n\n    if (reformattedCount > 0) {\n      logger.debug(\"general\", \"Reformatted files for consistent formatting\", { reformattedCount });\n    }\n  } catch {\n    // Directory doesn't exist or other error - skip silently\n  }\n}\n\n/**\n * Convert a canonical URL to the encoded key format for consistent indexing\n * Uses standard URL encoding for safe filename generation\n */\nfunction urlToEncodedKey(url: string): string {\n  return encodeURIComponent(url)\n    // Remove extra dot encoding - encodeURIComponent already handles URL safety\n    // .replace(/\\./g, \"%2E\")  // Don't double-encode dots\n    .replace(/!/g, \"%21\")   // Encode exclamation marks\n    .replace(/'/g, \"%27\")   // Encode single quotes\n    .replace(/\\(/g, \"%28\") // Encode parentheses\n    .replace(/\\)/g, \"%29\")\n    .replace(/\\*/g, \"%2A\"); // Encode asterisks\n}\n\n/**\n * Generate filename from parsed key using URL encoding\n */\nfunction generateFilenameFromParsedKey(parsed: ParsedKey): string | null {\n  // Always use full URL encoding for both entities and queries\n  const canonicalUrl = parsed.canonicalUrl;\n  if (!canonicalUrl) return null;\n\n  // Apply standard URL encoding for filename safety\n  let filename = urlToEncodedKey(canonicalUrl);\n\n  // Add .json extension\n  filename = `${filename}.json`;\n\n  return filename;\n}\n\n/**\n * Update unified index with both entity and query file metadata\n */\nasync function updateUnifiedIndex(dataPath: string, entityType: string, index: UnifiedIndex): Promise<UnifiedIndex> {\n  // Scan entity files\n  const entityDir = join(dataPath, entityType);\n  try {\n    const entityFiles = await readdir(entityDir);\n    for (const file of entityFiles) {\n      if (file.endsWith(\".json\") && file !== \"index.json\") {\n        const entityId = file.replace(\".json\", \"\");\n        const filePath = join(entityDir, file);\n\n        // Check if this is a malformed file that should be removed\n        const isMalformed = detectMalformedFilename(entityId);\n        if (isMalformed) {\n          logger.warn(\"general\", \"Removing malformed file\", {\n            entityType,\n            file,\n            entityId,\n            filePath\n          });\n          try {\n            await unlink(filePath);\n            logger.debug(\"general\", \"Successfully removed malformed file\", { filePath });\n            continue; // Skip processing this file\n          } catch (error) {\n            logger.error(\"general\", \"Failed to remove malformed file\", {\n              filePath,\n              error: error instanceof Error ? error.message : String(error)\n            });\n            // Continue processing even if removal failed\n          }\n        }\n\n        try {\n          const fileStat = await stat(filePath);\n          const fileContent = await readFile(filePath, \"utf-8\");\n          const contentHash = createContentHash(fileContent);\n\n          // Determine file type based on content structure only\n          let fileType: \"entity\" | \"query\" = \"entity\";\n\n          try {\n            const parsed: unknown = JSON.parse(fileContent);\n            if (Array.isArray(parsed)) {\n              // Query results as direct array\n              fileType = \"query\";\n            } else if (parsed && typeof parsed === \"object\" && \"results\" in parsed && Array.isArray(parsed.results)) {\n              // Query results wrapped in object with results property\n              fileType = \"query\";\n            }\n          } catch {\n            // If we can't parse, assume it's an entity file\n          }\n\n          const metadata: IndexEntry = {\n            lastModified: fileStat.mtime.toISOString(),\n            contentHash\n          };\n\n          if (fileType === \"entity\") {\n            // This is an entity file\n            let canonicalUrl: string;\n\n            // Try URL decoding for new format\n            try {\n              const decodedUrl = decodeURIComponent(entityId);\n              if (decodedUrl.startsWith(\"https://\")) {\n                canonicalUrl = decodedUrl;\n              } else {\n                throw new Error(\"Not a URL-encoded format\");\n              }\n            } catch {\n              // Handle legacy custom encoding for backward compatibility\n              if (entityId.startsWith(\"https-:\")) {\n                // This is an encoded filename - decode it carefully\n                // Remove the encoded protocol prefix\n                let withoutProtocol = entityId.substring(7); // Remove 'https-:'\n\n                // Replace colons with slashes in the path part (no query params for entities)\n                withoutProtocol = withoutProtocol.replace(/:/g, \"/\");\n\n                // Replace hyphens with equals signs\n                withoutProtocol = withoutProtocol.replace(/-/g, \"=\");\n\n                // Reconstruct the full URL\n                canonicalUrl = \"https://\" + withoutProtocol;\n                canonicalUrl = canonicalUrl.replace(/%22/g, '\"');\n              } else {\n                // This is a simple entity ID - construct the canonical URL\n                const prefix = getEntityPrefix(entityType);\n                const fullEntityId = entityId.startsWith(prefix) ? entityId : prefix + entityId;\n                canonicalUrl = `https://api.openalex.org/${entityType}/${fullEntityId}`;\n              }\n            }\n            // Use canonical URL as index key\n\n            if (!index[canonicalUrl]) {\n              index[canonicalUrl] = {};\n            }\n            Object.assign(index[canonicalUrl], metadata);\n          } else if (fileType === \"query\") {\n            // This is a query file\n            const canonicalQueryUrl = determineCanonicalQueryUrl(entityType, entityId, fileContent);\n            if (canonicalQueryUrl) {\n              // Use canonical URL as index key\n\n              // Check for duplicates with same content hash\n              let isDuplicate = false;\n              for (const [existingKey, existingEntry] of Object.entries(index)) {\n                if (existingEntry.contentHash === contentHash) {\n                  isDuplicate = true;\n                  logger.debug(\"general\", \"Skipping duplicate query\", { canonicalQueryUrl, matchesKey: existingKey });\n                  break;\n                }\n              }\n\n              if (!isDuplicate) {\n                if (!index[canonicalQueryUrl]) {\n                  index[canonicalQueryUrl] = {};\n                }\n                Object.assign(index[canonicalQueryUrl], metadata);\n                logger.debug(\"general\", \"Added query to index\", { canonicalQueryUrl });\n              }\n            } else {\n              logger.warn(\"general\", \"Could not determine canonical URL for query file\", { file });\n            }\n          }\n\n        } catch {\n          logger.warn(\"general\", \"Error reading file\", { file });\n        }\n      }\n    }\n  } catch {\n    logger.debug(\"general\", \"No entity directory found\");\n  }\n\n  // Deduplicate entries that may have both prefixed and non-prefixed versions\n  index = deduplicateIndexEntries(index, entityType);\n\n  logger.debug(\"general\", \"Updated unified index with entities and queries\", {\n    entityType,\n    entryCount: Object.keys(index).length\n  });\n  return index;\n}\n\n\n/**\n * Determine the canonical query URL for a query file\n * This tries multiple approaches to decode the filename and reconstruct the original query\n */\nfunction determineCanonicalQueryUrl(entityType: string, filename: string, fileContent: string): string | null {\n  // Try multiple decoding approaches\n\n  // Approach 1: Try standard URL decoding\n  try {\n    const cleanFilename = filename.replace(/\\.json$/, \"\");\n    const decodedUrl = decodeURIComponent(cleanFilename);\n\n    if (decodedUrl.startsWith(\"https://api.openalex.org/\")) {\n      logger.debug(\"general\", \"Decoded URL successfully\", { decodedUrl });\n      return decodedUrl;\n    }\n  } catch {\n    logger.debug(\"general\", \"Failed URL decoding\");\n  }\n\n  // Approach 2: Try legacy custom encoding for backward compatibility\n  try {\n    if (filename.startsWith(\"https-:\")) {\n      // Decode: https-::api.openalex.org:autocomplete?q=\"...\" → https://api.openalex.org/autocomplete?q=\"...\"\n      logger.debug(\"general\", \"Decoding legacy custom URL encoding\", { filename });\n      let withoutProtocol = filename.substring(7); // Remove 'https-:'\n      withoutProtocol = withoutProtocol\n        .replace(/:/g, \"/\")     // : → /\n        .replace(/-/g, \"=\")     // - → =\n        .replace(/%22/g, '\"');  // %22 → \"\n      const decodedUrl = `https://${withoutProtocol}`;\n      logger.debug(\"general\", \"Legacy decoded to\", { decodedUrl });\n      return decodedUrl;\n    }\n  } catch {\n    logger.debug(\"general\", \"Failed to decode legacy custom URL encoding\");\n  }\n\n  // Approach 2: Try base64url decoding (old format)\n  try {\n    const decoded = Buffer.from(filename, \"base64url\").toString(\"utf-8\");\n    const params: unknown = JSON.parse(decoded);\n    if (params && typeof params === \"object\" && params !== null) {\n      const searchParams = new URLSearchParams();\n      for (const [key, value] of Object.entries(params)) {\n        if (Array.isArray(value)) {\n          const stringArray = value.filter((item): item is string => typeof item === \"string\");\n          searchParams.set(key, stringArray.join(\",\"));\n        } else {\n          searchParams.set(key, String(value));\n        }\n      }\n      return `https://api.openalex.org/${entityType}?${searchParams.toString()}`;\n    }\n  } catch {\n    // Continue to next approach\n  }\n\n  // Approach 3: Try hex decoding\n  try {\n    if (/^[0-9a-f]+$/i.test(filename)) {\n      const decoded = Buffer.from(filename, \"hex\").toString(\"utf-8\");\n      const params: unknown = JSON.parse(decoded);\n      if (params && typeof params === \"object\" && params !== null) {\n        const searchParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          if (Array.isArray(value)) {\n            searchParams.set(key, value.join(\",\"));\n          } else {\n            searchParams.set(key, String(value));\n          }\n        }\n        return `https://api.openalex.org/${entityType}?${searchParams.toString()}`;\n      }\n    }\n  } catch {\n    // Continue to next approach\n  }\n\n  // Approach 4: Check if the query result contains the original URL\n  try {\n    const queryResult: unknown = JSON.parse(fileContent);\n    if (\n      queryResult &&\n      typeof queryResult === \"object\" &&\n      \"meta\" in queryResult &&\n      queryResult.meta &&\n      typeof queryResult.meta === \"object\" &&\n      \"request_url\" in queryResult.meta &&\n      typeof queryResult.meta.request_url === \"string\"\n    ) {\n      return queryResult.meta.request_url;\n    }\n  } catch {\n    // Continue to next approach\n  }\n\n  // Approach 5: Try to reverse-engineer from query results\n  try {\n    const queryResult: unknown = JSON.parse(fileContent);\n    if (\n      queryResult &&\n      typeof queryResult === \"object\" &&\n      \"results\" in queryResult &&\n      Array.isArray(queryResult.results)\n    ) {\n      const reconstructedUrl = reverseEngineerQueryUrl(entityType, queryResult, filename);\n      if (reconstructedUrl) {\n        return reconstructedUrl;\n      }\n    }\n  } catch {\n    // Continue to next approach\n  }\n\n  // Approach 6: Fallback - decode filename to reconstruct URL\n  logger.warn(\"general\", \"Using filename-based URL reconstruction\", { filename });\n  try {\n    // Try to decode the filename as URL-encoded\n    const cleanFilename = filename.replace(/\\.json$/, \"\");\n    const decodedUrl = decodeURIComponent(cleanFilename);\n\n    // Validate it's a proper OpenAlex URL\n    if (decodedUrl.startsWith(\"https://api.openalex.org/\")) {\n      return decodedUrl;\n    }\n  } catch {\n    logger.warn(\"general\", \"Failed to decode filename\");\n  }\n\n  // Ultimate fallback - this shouldn't happen with proper encoding\n  logger.warn(\"general\", \"Cannot reconstruct URL from filename\", { filename });\n  return null;\n}\n\n/**\n * Try to reverse-engineer the original query URL from the results\n */\nfunction reverseEngineerQueryUrl(entityType: string, queryResult: unknown, _filename: string): string | null {\n  if (\n    !queryResult ||\n    typeof queryResult !== \"object\" ||\n    !(\"results\" in queryResult) ||\n    !Array.isArray(queryResult.results)\n  ) {\n    return null;\n  }\n\n  const results = queryResult.results;\n  if (results.length === 0) return null;\n\n  // Check what fields are present in the first result\n  const firstResult: unknown = results[0];\n  if (!firstResult || typeof firstResult !== \"object\") return null;\n\n  const ObjectSchema = z.record(z.string(), z.unknown());\n  const resultValidation = ObjectSchema.safeParse(firstResult);\n  if (!resultValidation.success) return null;\n\n  const fields = Object.keys(resultValidation.data);\n\n  // Common patterns to detect:\n\n  // Pattern 1: If only id, display_name, publication_year -> likely author.id query with select\n  if (fields.length === 3 && fields.includes(\"id\") && fields.includes(\"display_name\") && fields.includes(\"publication_year\")) {\n    // This looks like filter=author.id:XXXX&select=id,display_name,publication_year\n    // Try to infer the author ID from the pattern or use a common one we know exists\n    return `https://api.openalex.org/${entityType}?filter=author.id:A5017898742&select=id,display_name,publication_year`;\n  }\n\n  // Pattern 2: If only id, display_name -> likely author.id query with select\n  if (fields.length === 2 && fields.includes(\"id\") && fields.includes(\"display_name\")) {\n    return `https://api.openalex.org/${entityType}?filter=author.id:A5017898742&select=id,display_name`;\n  }\n\n  // Pattern 3: If only id -> likely author.id query with select=id\n  if (fields.length === 1 && fields.includes(\"id\")) {\n    return `https://api.openalex.org/${entityType}?filter=author.id:A5017898742&select=id`;\n  }\n\n  // Pattern 4: If many fields but specific count, might be a per_page query\n  if (results.length === 50) {\n    return `https://api.openalex.org/${entityType}?filter=author.id:A5017898742&per_page=50`;\n  }\n\n  // Pattern 5: If 25 results, might be default query\n  if (results.length === 25) {\n    return `https://api.openalex.org/${entityType}`;\n  }\n\n  // Pattern 6: If 200 results, might be topic query with sorting\n  if (results.length === 200) {\n    return `https://api.openalex.org/${entityType}?sort=works_count,cited_by_count&select=id,display_name,works_count,cited_by_count&per_page=200`;\n  }\n\n  return null;\n}\n\n/**\n * Remove duplicate entries where both prefixed and non-prefixed versions exist\n * Keep the prefixed version (canonical) and remove the non-prefixed version\n */\nfunction deduplicateIndexEntries(index: UnifiedIndex, entityType: string): UnifiedIndex {\n  const prefix = getEntityPrefix(entityType);\n  const keysToRemove: string[] = [];\n\n  for (const key of Object.keys(index)) {\n    // Check if this is a non-prefixed entity URL\n    const match = key.match(/https:\\/\\/api\\.openalex\\.org\\/[^/]+\\/([^?]+)$/);\n    if (match) {\n      const entityId = match[1];\n\n      // If this ID doesn't start with the expected prefix\n      if (!entityId.startsWith(prefix)) {\n        // Check if the prefixed version exists\n        const prefixedKey = key.replace(entityId, prefix + entityId);\n        if (index[prefixedKey]) {\n          // Both versions exist, mark the non-prefixed one for removal\n          keysToRemove.push(key);\n          logger.debug(\"general\", \"Removing duplicate non-prefixed entry\", {\n            entityId,\n            keeping: prefix + entityId\n          });\n        }\n      }\n    }\n  }\n\n  // Remove the duplicate entries by creating new object\n  const filteredEntries = Object.entries(index).filter(([key]) => !keysToRemove.includes(key));\n  return Object.fromEntries(filteredEntries);\n}\n\n/**\n * Save unified index to file with requests wrapper\n */\nasync function saveUnifiedIndex(dataPath: string, entityType: string, index: UnifiedIndex) {\n  const indexPath = join(dataPath, entityType, \"index.json\");\n\n  try {\n    await mkdir(join(dataPath, entityType), { recursive: true });\n\n    // Convert the index to use $ref pointers while preserving metadata\n    const refIndex: Record<string, { $ref: string; lastModified: string; contentHash: string }> = {};\n\n    for (const [canonicalUrl, metadata] of Object.entries(index)) {\n      // Generate encoded filename from canonical URL\n      const encodedFilename = urlToEncodedKey(canonicalUrl) + \".json\";\n\n      // Create $ref pointer to the actual data file with metadata\n      refIndex[canonicalUrl] = {\n        $ref: `./${encodedFilename}`,\n        lastModified: metadata.lastModified || new Date().toISOString(),\n        contentHash: metadata.contentHash || \"\"\n      };\n    }\n\n    // Write the flattened index directly (no requests wrapper)\n    await writeFile(indexPath, JSON.stringify(refIndex, null, 2));\n    logger.debug(\"general\", \"Saved unified index with $ref pointers and metadata\");\n  } catch (error) {\n    logger.error(\"general\", \"Error saving unified index\", error);\n  }\n}\n\n\n/**\n * Create content hash excluding volatile metadata fields and normalizing URLs\n */\nfunction createContentHash(fileContent: string): string {\n  try {\n    const parsed: unknown = JSON.parse(fileContent);\n\n    // Create a copy and remove volatile metadata fields\n    if (parsed && typeof parsed === \"object\" && parsed !== null) {\n      const ObjectSchema = z.record(z.string(), z.unknown());\n      const contentResult = ObjectSchema.safeParse(parsed);\n      if (!contentResult.success) return createHash(\"sha256\").update(fileContent).digest(\"hex\").slice(0, 16);\n\n      const cleanContent = { ...contentResult.data };\n\n      if (cleanContent.meta && typeof cleanContent.meta === \"object\" && cleanContent.meta !== null) {\n        const metaResult = ObjectSchema.safeParse(cleanContent.meta);\n        if (!metaResult.success) return JSON.stringify(cleanContent);\n\n        const metaObj = metaResult.data;\n\n        const { count, db_response_time_ms, ...cleanMeta } = metaObj;\n\n        // Normalize URLs in meta to handle URL encoding differences\n        if (\"request_url\" in cleanMeta && typeof cleanMeta.request_url === \"string\") {\n          cleanMeta.request_url = normalizeUrlForDeduplication(cleanMeta.request_url);\n        }\n\n        cleanContent.meta = cleanMeta;\n      }\n\n      // Create hash from cleaned content with consistent ordering\n      const cleanedJson = JSON.stringify(cleanContent, Object.keys(cleanContent).sort());\n      return createHash(\"sha256\").update(cleanedJson).digest(\"hex\").slice(0, 16);\n    }\n\n    // If not an object, use the parsed content directly\n    return createHash(\"sha256\").update(JSON.stringify(parsed)).digest(\"hex\").slice(0, 16);\n  } catch {\n    // If parsing fails, use original content\n    return createHash(\"sha256\").update(fileContent).digest(\"hex\").slice(0, 16);\n  }\n}\n\n/**\n * Normalize URL by decoding URL-encoded characters for deduplication\n */\nfunction normalizeUrlForDeduplication(url: string): string {\n  try {\n    // Decode URL-encoded characters for comparison\n    return decodeURIComponent(url);\n  } catch {\n    return url;\n  }\n}\n\n\n/**\n * Migrate query files from queries subdirectory to entity directory with simplified names\n */\nasync function migrateQueryFilesToEntityDirectory(dataPath: string, entityType: string) {\n  logger.debug(\"general\", \"Migrating query files to entity directory\", { entityType });\n\n  const entityDir = join(dataPath, entityType);\n  const queriesDir = join(dataPath, entityType, \"queries\");\n  let movedFiles = 0;\n\n  try {\n    const queryFiles = await readdir(queriesDir);\n\n    for (const file of queryFiles) {\n      if (file.endsWith(\".json\") && file !== \"index.json\") {\n        const queryFilePath = join(queriesDir, file);\n\n        try {\n          const fileContent = await readFile(queryFilePath, \"utf-8\");\n\n          // Determine if this is a query file and get its canonical URL\n          const canonicalUrl = determineCanonicalQueryUrl(entityType, file.replace(\".json\", \"\"), fileContent);\n\n          if (canonicalUrl) {\n            // Generate the simplified filename\n            const newFilename = generateDescriptiveFilename(canonicalUrl);\n\n            if (newFilename) {\n              const newFilePath = join(entityDir, newFilename);\n\n              // Check if the target file already exists\n              try {\n                await stat(newFilePath);\n                logger.debug(\"general\", \"File already exists, skipping\", { newFilename });\n                continue;\n              } catch {\n                // File doesn't exist, proceed with move\n              }\n\n              try {\n                // Write to new location with consistent formatting\n                const formattedContent = formatJsonConsistently(fileContent);\n                await writeFile(newFilePath, formattedContent);\n                // Remove from old location\n                await unlink(queryFilePath);\n\n                logger.debug(\"general\", \"Moved query file\", { from: file, to: newFilename });\n                movedFiles++;\n              } catch {\n                logger.warn(\"general\", \"Failed to move file\", { file });\n              }\n            } else {\n              logger.warn(\"general\", \"Could not generate filename for file\", { file });\n            }\n          } else {\n            logger.warn(\"general\", \"Could not determine canonical URL for file\", { file });\n          }\n        } catch {\n          logger.warn(\"general\", \"Could not process query file\", { file });\n        }\n      }\n    }\n  } catch {\n    logger.debug(\"general\", \"No queries directory found or error accessing it\");\n  }\n\n  if (movedFiles > 0) {\n    logger.debug(\"general\", \"Moved query files to entity directory\", { movedFiles });\n  } else {\n    logger.debug(\"general\", \"No query files found to move\");\n  }\n}\n\n/**\n * Generate a descriptive filename from a canonical URL using proper URL encoding\n */\nfunction generateDescriptiveFilename(canonicalUrl: string): string | null {\n  try {\n    // Use the same URL encoding approach as urlToEncodedKey for consistency\n    const filename = urlToEncodedKey(canonicalUrl) + \".json\";\n    return filename;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Generate the main OpenAlex index with JSON $ref structure\n */\nasync function generateMainIndex(dataPath: string): Promise<void> {\n  const mainIndexPath = join(dataPath, \"index.json\");\n\n  // Discover entity types by scanning directories with index.json files\n  const discoveredEntityTypes: string[] = [];\n\n  try {\n    const entries = await readdir(dataPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        const entityType = entry.name;\n        const entityIndexPath = join(dataPath, entityType, \"index.json\");\n\n        try {\n          await stat(entityIndexPath);\n          // Entity index exists\n          discoveredEntityTypes.push(entityType);\n        } catch {\n          // Directory exists but no index.json - skip\n        }\n      }\n    }\n  } catch {\n    logger.warn(\"general\", \"Error discovering entity types\");\n    return;\n  }\n\n  // Sort entity types for consistent output\n  discoveredEntityTypes.sort();\n\n  // Create JSON Schema compliant main index that references and spreads all entity indexes\n  const entityRefs = discoveredEntityTypes.map(entityType => ({\n    $ref: `./${entityType}/index.json`\n  }));\n\n  // Check if main index exists and compare content structure (excluding lastModified)\n  let existingMainIndex: { lastModified?: string; [key: string]: unknown } | null = null;\n  try {\n    const existingContent = await readFile(mainIndexPath, \"utf-8\");\n    const parsed: unknown = JSON.parse(existingContent);\n    if (parsed && typeof parsed === \"object\" && !Array.isArray(parsed)) {\n      // Safe property access without type assertion\n      const hasLastModified = \"lastModified\" in parsed;\n      const lastModifiedValue = hasLastModified && typeof parsed.lastModified === \"string\"\n        ? parsed.lastModified\n        : undefined;\n\n      existingMainIndex = {\n        lastModified: lastModifiedValue,\n        ...Object.fromEntries(Object.entries(parsed))\n      };\n    }\n  } catch {\n    // File doesn't exist or is invalid - will create new\n  }\n\n  // Create new main index structure\n  const newMainIndexContent = {\n    $schema: \"https://json-schema.org/draft/2020-12/schema\",\n    $id: \"https://api.openalex.org/schema/index\",\n    title: \"OpenAlex Static Data Index\",\n    description: \"Root index merging all entity-specific data via JSON Schema references\",\n    type: \"object\",\n    version: \"1.0.0\",\n    allOf: entityRefs\n  };\n\n  // Compare content structure (excluding lastModified) to determine if update is needed\n  let contentChanged = true;\n  if (existingMainIndex) {\n    const { lastModified: existingLastModified, ...existingContent } = existingMainIndex;\n    const contentMatches = JSON.stringify(existingContent) === JSON.stringify(newMainIndexContent);\n    contentChanged = !contentMatches;\n  }\n\n  // Preserve existing lastModified if content hasn't changed, otherwise use current timestamp\n  const mainIndex = {\n    ...newMainIndexContent,\n    lastModified: contentChanged\n      ? new Date().toISOString()\n      : (existingMainIndex?.lastModified ?? new Date().toISOString())\n  };\n\n  // Only write if content has changed or file doesn't exist\n  if (contentChanged || !existingMainIndex) {\n    await writeFile(mainIndexPath, JSON.stringify(mainIndex, null, 2), \"utf-8\");\n    logger.debug(\"general\", \"Updated main index with JSON Schema $ref structure\", {\n      entityTypeCount: discoveredEntityTypes.length,\n      contentChanged\n    });\n  } else {\n    logger.debug(\"general\", \"Main index content unchanged - skipping write\", {\n      entityTypeCount: discoveredEntityTypes.length\n    });\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/activity/GraphActivityTracker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/cache/CacheInitializer.tsx","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function 'initialize' has no 'await' expression.","line":41,"column":3,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":41,"endColumn":28,"suggestions":[{"messageId":"removeAsync","fix":{"range":[1250,1256],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":106,"column":20,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":106,"endColumn":22,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3055,3057],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cache Initializer Component\n * Handles asynchronous cache initialization with version checking before rendering the app\n */\n\nimport { type ReactNode, useEffect, useState } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { Center, Text, Stack, Progress } from \"@mantine/core\";\nimport { IconDatabase, IconRefresh } from \"@tabler/icons-react\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { useAutoRelationshipDetection } from \"@/hooks/use-auto-relationship-detection\";\n\ninterface CacheInitializerProps {\n  children: ReactNode;\n}\n\ninterface InitializationState {\n  status: \"loading\" | \"ready\" | \"error\";\n  queryClient?: QueryClient;\n  error?: string;\n}\n\n/**\n * Component that enables automatic relationship detection for all entity types\n * This component just runs the hook and renders nothing\n */\nfunction AutoRelationshipDetector() {\n\tuseAutoRelationshipDetection();\n\treturn null;\n}\n\n/**\n * Component that initializes cache with version checking before rendering children\n */\nexport function CacheInitializer({ children }: CacheInitializerProps) {\n\tconst [state, setState] = useState<InitializationState>({ status: \"loading\" });\n\n\tuseEffect(() => {\n\t\tlet isMounted = true;\n\n\t\tasync function initialize() {\n\t\t\ttry {\n\t\t\t\tlogger.debug(\"cache\", \"Starting cache initialization\");\n\n\t\t\t\t// Create a standard QueryClient with reasonable defaults\n\t\t\t\tconst queryClient = new QueryClient({\n\t\t\t\t\tdefaultOptions: {\n\t\t\t\t\t\tqueries: {\n\t\t\t\t\t\t\tstaleTime: 5 * 60 * 1000, // 5 minutes\n\t\t\t\t\t\t\tgcTime: 10 * 60 * 1000,   // 10 minutes (formerly cacheTime)\n\t\t\t\t\t\t\tretry: 2,\n\t\t\t\t\t\t\trefetchOnWindowFocus: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tif (isMounted) {\n\t\t\t\t\tsetState({\n\t\t\t\t\t\tstatus: \"ready\",\n\t\t\t\t\t\tqueryClient\n\t\t\t\t\t});\n\n\t\t\t\t\tlogger.debug(\"cache\", \"Cache initialization completed successfully\");\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"cache\", \"Cache initialization failed\", { error });\n\n\t\t\t\tif (isMounted) {\n\t\t\t\t\tsetState({\n\t\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid initialize();\n\n\t\treturn () => {\n\t\t\tisMounted = false;\n\t\t};\n\t}, []);\n\n\t// Show loading state during initialization\n\tif (state.status === \"loading\") {\n\t\treturn (\n\t\t\t<Center style={{ height: \"100vh\" }}>\n\t\t\t\t<Stack align=\"center\" gap=\"md\">\n\t\t\t\t\t<IconDatabase size={48} color=\"var(--mantine-color-blue-6)\" />\n\t\t\t\t\t<Text size=\"lg\" fw={500}>Initializing Academic Explorer</Text>\n\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Checking for updates and preparing cache...</Text>\n\t\t\t\t\t<Progress size=\"sm\" value={100} animated style={{ width: 200 }} />\n\t\t\t\t</Stack>\n\t\t\t</Center>\n\t\t);\n\t}\n\n\t// Show error state if initialization failed completely\n\tif (state.status === \"error\" || !state.queryClient) {\n\t\treturn (\n\t\t\t<Center style={{ height: \"100vh\" }}>\n\t\t\t\t<Stack align=\"center\" gap=\"md\">\n\t\t\t\t\t<IconRefresh size={48} color=\"var(--mantine-color-red-6)\" />\n\t\t\t\t\t<Text size=\"lg\" fw={500} c=\"red\">Initialization Failed</Text>\n\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">\n\t\t\t\t\t\t{state.error || \"Unable to initialize cache system\"}\n\t\t\t\t\t</Text>\n\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n            Please refresh the page to try again\n\t\t\t\t\t</Text>\n\t\t\t\t</Stack>\n\t\t\t</Center>\n\t\t);\n\t}\n\n\t// Render app with initialized query client\n\treturn (\n\t\t<QueryClientProvider client={state.queryClient}>\n\t\t\t<AutoRelationshipDetector />\n\t\t\t{children}\n\t\t</QueryClientProvider>\n\t);\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/devtools/ApplicationLoggerPanel.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":45,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":45,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1975,1977],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":46,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":46,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2010,2012],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":206,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":206,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6828,6830],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\nimport { Text, Stack, Group, Badge, Button, Divider, ScrollArea, Code, Paper, Tabs, TextInput, MultiSelect, ActionIcon, Tooltip } from \"@mantine/core\";\nimport { IconTrash, IconSearch, IconFilter, IconDownload, IconBug, IconInfoCircle, IconAlertTriangle, IconX, IconCopy } from \"@tabler/icons-react\";\nimport { logger, type LogLevel, type LogCategory, type LogEntry } from \"@academic-explorer/utils/logger\";\n\n\nexport function ApplicationLoggerPanel() {\n\tconst [logs, setLogs] = useState<LogEntry[]>([]);\n\tconst [filteredLogs, setFilteredLogs] = useState<LogEntry[]>([]);\n\tconst [selectedLevels, setSelectedLevels] = useState<LogLevel[]>([]);\n\tconst [selectedCategories, setSelectedCategories] = useState<LogCategory[]>([]);\n\tconst [searchQuery, setSearchQuery] = useState(\"\");\n\tconst [activeTab, setActiveTab] = useState(\"logs\");\n\n\tuseEffect(() => {\n\t\tconst unsubscribe = logger.subscribe(setLogs);\n\t\tsetLogs(logger.getLogs());\n\n\t\t// Add some test log entries to verify filtering works\n\t\tif (logger.getLogs().length === 0) {\n\t\t\tlogger.debug(\"general\", \"ApplicationLoggerPanel initialized\", { component: \"devtools\" }, \"ApplicationLoggerPanel\");\n\t\t\tlogger.debug(\"ui\", \"Filter test log entry\", { testData: \"filtering\" }, \"ApplicationLoggerPanel\");\n\t\t\tlogger.warn(\"cache\", \"Sample warning for filter testing\", { level: \"warn\" });\n\t\t\tlogger.error(\"api\", \"Sample error for filter testing\", { status: 500 });\n\t\t}\n\n\t\treturn unsubscribe;\n\t}, []);\n\n\tuseEffect(() => {\n\t\tlet filtered = logs;\n\n\t\tif (selectedLevels.length > 0) {\n\t\t\tfiltered = filtered.filter(log => selectedLevels.includes(log.level));\n\t\t}\n\n\t\tif (selectedCategories.length > 0) {\n\t\t\tfiltered = filtered.filter(log => selectedCategories.includes(log.category));\n\t\t}\n\n\t\tif (searchQuery) {\n\t\t\tconst query = searchQuery.toLowerCase();\n\t\t\tfiltered = filtered.filter(log =>\n\t\t\t\tlog.message.toLowerCase().includes(query) ||\n        log.component?.toLowerCase().includes(query) ||\n        JSON.stringify(log.data || \"\").toLowerCase().includes(query)\n\t\t\t);\n\t\t}\n\n\t\tsetFilteredLogs(filtered);\n\t}, [logs, selectedLevels, selectedCategories, searchQuery]);\n\n\tconst getLevelColor = (level: LogLevel) => {\n\t\tswitch (level) {\n\t\t\tcase \"debug\": return \"gray\";\n\t\t\tcase \"info\": return \"blue\";\n\t\t\tcase \"warn\": return \"yellow\";\n\t\t\tcase \"error\": return \"red\";\n\t\t\tdefault: return \"gray\";\n\t\t}\n\t};\n\n\tconst getLevelIcon = (level: LogLevel) => {\n\t\tswitch (level) {\n\t\t\tcase \"debug\": return <IconBug size={14} />;\n\t\t\tcase \"info\": return <IconInfoCircle size={14} />;\n\t\t\tcase \"warn\": return <IconAlertTriangle size={14} />;\n\t\t\tcase \"error\": return <IconX size={14} />;\n\t\t\tdefault: return <IconInfoCircle size={14} />;\n\t\t}\n\t};\n\n\tconst getCategoryBadgeColor = (category: LogCategory) => {\n\t\tconst colors: Record<LogCategory, string> = {\n\t\t\t\"api\": \"blue\",\n\t\t\t\"cache\": \"green\",\n\t\t\t\"graph\": \"purple\",\n\t\t\t\"routing\": \"orange\",\n\t\t\t\"ui\": \"pink\",\n\t\t\t\"auth\": \"red\",\n\t\t\t\"storage\": \"teal\",\n\t\t\t\"search\": \"cyan\",\n\t\t\t\"general\": \"gray\",\n\t\t\t\"expansion\": \"violet\",\n\t\t\t\"repository\": \"indigo\",\n\t\t\t\"settings\": \"yellow\",\n\t\t\t\"static-data\": \"lime\",\n\t\t\t\"query-cache\": \"grape\",\n\t\t\t\"worker\": \"dark\",\n\t\t\t\"eventbridge\": \"emerald\",\n\t\t\t\"eventbus\": \"blue\",\n\t\t\t\"taskqueue\": \"orange\",\n\t\t\t\"workerpool\": \"teal\",\n\t\t\t\"resource\": \"purple\",\n\t\t\t\"queuecoordinator\": \"violet\",\n\t\t\t\"hooks\": \"pink\",\n\t\t\t\"execution\": \"cyan\",\n\t\t};\n\t\tconst color = colors[category];\n\t\treturn color ?? \"gray\";\n\t};\n\n\tconst logStats = {\n\t\ttotal: logs.length,\n\t\tdebug: logs.filter(l => l.level === \"debug\").length,\n\t\tinfo: logs.filter(l => l.level === \"info\").length,\n\t\twarn: logs.filter(l => l.level === \"warn\").length,\n\t\terror: logs.filter(l => l.level === \"error\").length,\n\t};\n\n\tconst formatLogEntry = (log: LogEntry) => {\n\t\tconst timestamp = `${log.timestamp.toLocaleTimeString()}.${log.timestamp.getMilliseconds().toString().padStart(3, \"0\")}`;\n\t\tconst level = log.level.toUpperCase();\n\t\tconst {category} = log;\n\t\tconst component = log.component ? ` [${log.component}]` : \"\";\n\t\tconst data = log.data ? `\\nData: ${JSON.stringify(log.data, null, 2)}` : \"\";\n\t\tconst stack = log.stack ? `\\nStack: ${log.stack}` : \"\";\n\n\t\treturn `[${timestamp}] ${level} (${category})${component}: ${log.message}${data}${stack}`;\n\t};\n\n\tconst copyAllLogs = async () => {\n\t\ttry {\n\t\t\tconst allLogsText = filteredLogs.map(formatLogEntry).join(\"\\n\\n\");\n\t\t\tawait navigator.clipboard.writeText(allLogsText);\n\t\t\tlogger.debug(\"ui\", \"Copied all filtered logs to clipboard\", { count: filteredLogs.length }, \"ApplicationLoggerPanel\");\n\t\t} catch (error: unknown) {\n\t\t\tlogger.error(\"ui\", \"Failed to copy logs to clipboard\", { error: error instanceof Error ? error.message : String(error) }, \"ApplicationLoggerPanel\");\n\t\t}\n\t};\n\n\tconst copyLogEntry = async (log: LogEntry) => {\n\t\ttry {\n\t\t\tconst logText = formatLogEntry(log);\n\t\t\tawait navigator.clipboard.writeText(logText);\n\t\t\tlogger.debug(\"ui\", \"Copied log entry to clipboard\", { id: log.id }, \"ApplicationLoggerPanel\");\n\t\t} catch (error: unknown) {\n\t\t\tlogger.error(\"ui\", \"Failed to copy log entry to clipboard\", { error: error instanceof Error ? error.message : String(error) }, \"ApplicationLoggerPanel\");\n\t\t}\n\t};\n\n\treturn (\n\t\t<>\n\t\t\t<style>\n\t\t\t\t{`\n          [data-mantine-dropdown-portal=\"true\"] {\n            z-index: 2147483647 !important;\n          }\n          .mantine-Select-dropdown,\n          .mantine-MultiSelect-dropdown,\n          [data-floating-ui-portal] {\n            z-index: 2147483647 !important;\n          }\n          /* Target dropdown containers directly */\n          div[data-mantine-stop-propagation] {\n            z-index: 2147483647 !important;\n          }\n        `}\n\t\t\t</style>\n\t\t\t<ScrollArea h={500} p=\"md\">\n\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t{/* Header */}\n\t\t\t\t\t<Group justify=\"space-between\">\n\t\t\t\t\t\t<Text size=\"xl\" fw={600}>Application Logger</Text>\n\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t<Badge color=\"blue\" variant=\"light\">{logStats.total} total</Badge>\n\t\t\t\t\t\t\t<Tooltip label=\"Copy all filtered logs to clipboard\" withArrow>\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\tcolor=\"green\"\n\t\t\t\t\t\t\t\t\tleftSection={<IconCopy size={14} />}\n\t\t\t\t\t\t\t\t\tonClick={() => { void copyAllLogs(); }}\n\t\t\t\t\t\t\t\t\tdisabled={filteredLogs.length === 0}\n\t\t\t\t\t\t\t\t>\n                Copy All\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\tleftSection={<IconDownload size={14} />}\n\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\tlogger.exportLogs();\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n              Export\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\t\t\t\tleftSection={<IconTrash size={14} />}\n\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\tlogger.clear();\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n              Clear\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Divider />\n\n\t\t\t\t\t<Tabs value={activeTab} onChange={(value) => {\n\t\t\t\t\t\tsetActiveTab(value || \"logs\");\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<Tabs.List>\n\t\t\t\t\t\t\t<Tabs.Tab value=\"logs\" leftSection={<IconInfoCircle size={14} />}>\n              Live Logs ({filteredLogs.length})\n\t\t\t\t\t\t\t</Tabs.Tab>\n\t\t\t\t\t\t\t<Tabs.Tab value=\"stats\" leftSection={<IconBug size={14} />}>\n              Statistics\n\t\t\t\t\t\t\t</Tabs.Tab>\n\t\t\t\t\t\t</Tabs.List>\n\n\t\t\t\t\t\t<Tabs.Panel value=\"logs\" pt=\"md\">\n\t\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t\t{/* Filters */}\n\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\t\t\t\t\tgridTemplateColumns: \"1fr auto auto\",\n\t\t\t\t\t\t\t\t\tgap: \"12px\",\n\t\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\t\twidth: \"100%\"\n\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t<TextInput\n\t\t\t\t\t\t\t\t\t\tplaceholder=\"Search logs...\"\n\t\t\t\t\t\t\t\t\t\tvalue={searchQuery}\n\t\t\t\t\t\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\t\t\t\t\t\tsetSearchQuery(e.currentTarget.value);\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tleftSection={<IconSearch size={16} />}\n\t\t\t\t\t\t\t\t\t\trightSection={\n\t\t\t\t\t\t\t\t\t\t\tsearchQuery ? (\n\t\t\t\t\t\t\t\t\t\t\t\t<ActionIcon size=\"sm\" variant=\"transparent\" onClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tsetSearchQuery(\"\");\n\t\t\t\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<IconX size={12} />\n\t\t\t\t\t\t\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t\t\t\t\t\t\t) : null\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<MultiSelect\n\t\t\t\t\t\t\t\t\t\tplaceholder=\"Filter by Level\"\n\t\t\t\t\t\t\t\t\t\tvalue={selectedLevels}\n\t\t\t\t\t\t\t\t\t\tonChange={(values) => {\n\t\t\t\t\t\t\t\t\t\t\tconst validLevels = values.filter((value): value is LogLevel =>\n\t\t\t\t\t\t\t\t\t\t\t\t[\"debug\", \"info\", \"warn\", \"error\"].includes(value)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tsetSelectedLevels(validLevels);\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tdata={[\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"debug\", label: \"Debug\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"info\", label: \"Info\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"warn\", label: \"Warning\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"error\", label: \"Error\" },\n\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\tleftSection={<IconFilter size={16} />}\n\t\t\t\t\t\t\t\t\t\tstyles={{\n\t\t\t\t\t\t\t\t\t\t\troot: {\n\t\t\t\t\t\t\t\t\t\t\t\twidth: \"auto\",\n\t\t\t\t\t\t\t\t\t\t\t\tminWidth: \"160px\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tinput: {\n\t\t\t\t\t\t\t\t\t\t\t\tminHeight: \"36px\",\n\t\t\t\t\t\t\t\t\t\t\t\theight: \"36px\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tpill: {\n\t\t\t\t\t\t\t\t\t\t\t\tgap: \"4px\",\n\t\t\t\t\t\t\t\t\t\t\t\tflexWrap: \"nowrap\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tclearable\n\t\t\t\t\t\t\t\t\t\thidePickedOptions\n\t\t\t\t\t\t\t\t\t\tsearchable\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<MultiSelect\n\t\t\t\t\t\t\t\t\t\tplaceholder=\"Filter by Category\"\n\t\t\t\t\t\t\t\t\t\tvalue={selectedCategories}\n\t\t\t\t\t\t\t\t\t\tonChange={(values) => {\n\t\t\t\t\t\t\t\t\t\t\tconst validCategories = values.filter((value): value is LogCategory =>\n\t\t\t\t\t\t\t\t\t\t\t\t[\"api\", \"cache\", \"graph\", \"routing\", \"ui\", \"auth\", \"storage\", \"search\", \"general\", \"expansion\", \"repository\", \"settings\"].includes(value)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tsetSelectedCategories(validCategories);\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tdata={[\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"api\", label: \"API\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"cache\", label: \"Cache\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"graph\", label: \"Graph\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"routing\", label: \"Routing\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"ui\", label: \"UI\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"auth\", label: \"Auth\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"storage\", label: \"Storage\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"search\", label: \"Search\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"general\", label: \"General\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"expansion\", label: \"Expansion\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"repository\", label: \"Repository\" },\n\t\t\t\t\t\t\t\t\t\t\t{ value: \"settings\", label: \"Settings\" },\n\t\t\t\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t\t\t\t\tstyles={{\n\t\t\t\t\t\t\t\t\t\t\troot: {\n\t\t\t\t\t\t\t\t\t\t\t\twidth: \"auto\",\n\t\t\t\t\t\t\t\t\t\t\t\tminWidth: \"180px\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tinput: {\n\t\t\t\t\t\t\t\t\t\t\t\tminHeight: \"36px\",\n\t\t\t\t\t\t\t\t\t\t\t\theight: \"36px\"\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tpill: {\n\t\t\t\t\t\t\t\t\t\t\t\tgap: \"4px\",\n\t\t\t\t\t\t\t\t\t\t\t\tflexWrap: \"nowrap\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tclearable\n\t\t\t\t\t\t\t\t\t\thidePickedOptions\n\t\t\t\t\t\t\t\t\t\tsearchable\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t{/* Log Entries */}\n\t\t\t\t\t\t\t\t<Stack gap=\"xs\" style={{ maxHeight: 400, overflow: \"auto\" }}>\n\t\t\t\t\t\t\t\t\t{filteredLogs.length === 0 ? (\n\t\t\t\t\t\t\t\t\t\t<Text c=\"dimmed\" ta=\"center\" py=\"xl\">\n\t\t\t\t\t\t\t\t\t\t\t{logs.length === 0 ? \"No logs yet\" : \"No logs match current filters\"}\n\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\tfilteredLogs.map((log) => (\n\t\t\t\t\t\t\t\t\t\t\t<Paper key={log.id} p=\"sm\" withBorder style={{ fontSize: \"12px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Group gap=\"xs\" mb=\"xs\" wrap=\"nowrap\" justify=\"space-between\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Group gap=\"xs\" wrap=\"nowrap\" style={{ flex: 1, minWidth: 0 }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor={getLevelColor(log.level)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tleftSection={getLevelIcon(log.level)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{log.level.toUpperCase()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor={getCategoryBadgeColor(log.category)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{log.category}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{log.timestamp.toLocaleTimeString()}.{log.timestamp.getMilliseconds().toString().padStart(3, \"0\")}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{log.component && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Code c=\"dimmed\">{log.component}</Code>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Tooltip label=\"Copy this log entry to clipboard\" withArrow>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor=\"gray\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => { void copyLogEntry(log); }}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstyle={{ flexShrink: 0 }}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<IconCopy size={12} />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" mb={log.data ? \"xs\" : 0}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{log.message}\n\t\t\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t\t\t{log.data !== undefined && log.data !== null && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Code block c=\"dimmed\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn JSON.stringify(log.data, null, 2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Handle non-serializable data safely\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (typeof log.data === \"string\") return log.data;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (typeof log.data === \"number\") return log.data.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (typeof log.data === \"boolean\") return log.data.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"[Complex Object - cannot display]\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t})()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Code>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t{log.stack && (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Code block c=\"red\" mt=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{log.stack}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Code>\n\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t</Paper>\n\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t</Tabs.Panel>\n\n\t\t\t\t\t\t<Tabs.Panel value=\"stats\" pt=\"md\">\n\t\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Log Level Distribution</Text>\n\t\t\t\t\t\t\t\t\t<Group gap=\"xl\">\n\t\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Debug</Text>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{logStats.debug}</Text>\n\t\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Info</Text>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{logStats.info}</Text>\n\t\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Warning</Text>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{logStats.warn}</Text>\n\t\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Error</Text>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500} c=\"red\">{logStats.error}</Text>\n\t\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t\t\t{logStats.error > 0 && (\n\t\t\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\" c=\"red\">Recent Errors</Text>\n\t\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t{logs\n\t\t\t\t\t\t\t\t\t\t\t\t.filter(log => log.level === \"error\")\n\t\t\t\t\t\t\t\t\t\t\t\t.slice(0, 5)\n\t\t\t\t\t\t\t\t\t\t\t\t.map(log => (\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Group key={log.id} gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{log.timestamp.toLocaleTimeString()}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\">{log.message}</Text>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t</Paper>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t</Tabs.Panel>\n\t\t\t\t\t</Tabs>\n\t\t\t\t</Stack>\n\t\t\t</ScrollArea>\n\t\t</>\n\t);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/devtools/EntityGraphPanel.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":180,"column":25,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":180,"endColumn":27,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4974,4976],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\nimport { Box, Text, Stack, Group, Badge, Button, Divider, ScrollArea, Code, Paper, Tabs, JsonInput, Alert } from \"@mantine/core\";\nimport { IconRefresh, IconNetwork, IconArrowRight, IconBug, IconSettings, IconInfoCircle } from \"@tabler/icons-react\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface GraphStats {\n  nodes: {\n    total: number;\n    byType: Record<string, number>;\n    selected: string[];\n    hidden: number;\n    directlyVisited: number;\n  };\n  edges: {\n    total: number;\n    byType: Record<string, number>;\n    selected: string[];\n    hidden: number;\n  };\n  layout: {\n    algorithm: string;\n    isRunning: boolean;\n    iterations: number;\n    lastUpdate: string;\n  };\n  performance: {\n    renderTime: number;\n    lastUpdate: number;\n    fps: number;\n    memoryUsage: string;\n  };\n  filterState: {\n    directlyVisitedOnly: boolean;\n    entityTypes: string[];\n    yearRange: [number, number] | null;\n  };\n}\n\nexport function EntityGraphPanel() {\n\tconst [stats, setStats] = useState<GraphStats | null>(null);\n\tconst [lastUpdate, setLastUpdate] = useState<Date>(new Date());\n\tconst [isRefreshing, setIsRefreshing] = useState(false);\n\tconst [activeTab, setActiveTab] = useState<string>(\"overview\");\n\n\tconst refreshStats = async () => {\n\t\tsetIsRefreshing(true);\n\n\t\t// Mock graph statistics - in real implementation, this would interface with XYFlow store\n\t\tconst mockStats: GraphStats = {\n\t\t\tnodes: {\n\t\t\t\ttotal: Math.floor(Math.random() * 200) + 50,\n\t\t\t\tbyType: {\n\t\t\t\t\t\"work\": Math.floor(Math.random() * 80) + 20,\n\t\t\t\t\t\"author\": Math.floor(Math.random() * 40) + 10,\n\t\t\t\t\t\"institution\": Math.floor(Math.random() * 20) + 5,\n\t\t\t\t\t\"source\": Math.floor(Math.random() * 15) + 3,\n\t\t\t\t\t\"concept\": Math.floor(Math.random() * 30) + 8,\n\t\t\t\t},\n\t\t\t\tselected: [`W${Math.floor(Math.random() * 1000000).toString()}`],\n\t\t\t\thidden: Math.floor(Math.random() * 20),\n\t\t\t\tdirectlyVisited: Math.floor(Math.random() * 10) + 5,\n\t\t\t},\n\t\t\tedges: {\n\t\t\t\ttotal: Math.floor(Math.random() * 300) + 100,\n\t\t\t\tbyType: {\n\t\t\t\t\t\"authorship\": Math.floor(Math.random() * 100) + 30,\n\t\t\t\t\t\"citation\": Math.floor(Math.random() * 80) + 20,\n\t\t\t\t\t\"affiliation\": Math.floor(Math.random() * 50) + 15,\n\t\t\t\t\t\"publication\": Math.floor(Math.random() * 40) + 10,\n\t\t\t\t\t\"conceptual\": Math.floor(Math.random() * 30) + 8,\n\t\t\t\t},\n\t\t\t\tselected: [],\n\t\t\t\thidden: Math.floor(Math.random() * 15),\n\t\t\t},\n\t\t\tlayout: {\n\t\t\t\talgorithm: \"force-directed\",\n\t\t\t\tisRunning: Math.random() > 0.5,\n\t\t\t\titerations: Math.floor(Math.random() * 1000) + 200,\n\t\t\t\tlastUpdate: new Date(Date.now() - Math.random() * 10000).toLocaleTimeString(),\n\t\t\t},\n\t\t\tperformance: {\n\t\t\t\trenderTime: Math.floor(Math.random() * 50) + 10,\n\t\t\t\tlastUpdate: Date.now(),\n\t\t\t\tfps: Math.floor(Math.random() * 30) + 45,\n\t\t\t\tmemoryUsage: (Math.random() * 50 + 10).toFixed(1) + \"MB\",\n\t\t\t},\n\t\t\tfilterState: {\n\t\t\t\tdirectlyVisitedOnly: Math.random() > 0.5,\n\t\t\t\tentityTypes: [\"work\", \"author\", \"institution\"],\n\t\t\t\tyearRange: [2018, 2024],\n\t\t\t},\n\t\t};\n\n\t\tawait new Promise(resolve => setTimeout(resolve, 500));\n\n\t\tsetStats(mockStats);\n\t\tsetLastUpdate(new Date());\n\t\tsetIsRefreshing(false);\n\t};\n\n\tconst resetGraph = () => {\n\t\tlogger.debug(\"ui\", \"Resetting graph layout\", {}, \"EntityGraphPanel\");\n\t\t// In real implementation, this would reset the XYFlow graph\n\t\tvoid refreshStats();\n\t};\n\n\tconst recenterGraph = () => {\n\t\tlogger.debug(\"ui\", \"Recentering graph\", {}, \"EntityGraphPanel\");\n\t\t// In real implementation, this would recenter the XYFlow viewport\n\t};\n\n\tuseEffect(() => {\n\t\tvoid refreshStats();\n\n\t\t// Auto-refresh every 5 seconds\n\t\tconst interval = setInterval(() => {\n\t\t\tvoid refreshStats();\n\t\t}, 5000);\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t}, []);\n\n\tconst getTypeColor = (type: string) => {\n\t\tconst colors = {\n\t\t\t\"work\": \"blue\",\n\t\t\t\"author\": \"green\",\n\t\t\t\"institution\": \"orange\",\n\t\t\t\"source\": \"purple\",\n\t\t\t\"concept\": \"pink\",\n\t\t\t\"authorship\": \"teal\",\n\t\t\t\"citation\": \"cyan\",\n\t\t\t\"affiliation\": \"yellow\",\n\t\t\t\"publication\": \"indigo\",\n\t\t\t\"conceptual\": \"violet\",\n\t\t} as const;\n\n\t\tconst isValidType = (t: string): t is keyof typeof colors => {\n\t\t\treturn t in colors;\n\t\t};\n\n\t\treturn isValidType(type) ? colors[type] : \"gray\";\n\t};\n\n\tif (!stats) {\n\t\treturn (\n\t\t\t<Box p=\"md\">\n\t\t\t\t<Text>Loading graph statistics...</Text>\n\t\t\t</Box>\n\t\t);\n\t}\n\n\treturn (\n\t\t<ScrollArea h={500} p=\"md\">\n\t\t\t<Stack gap=\"md\">\n\t\t\t\t{/* Header */}\n\t\t\t\t<Group justify=\"space-between\">\n\t\t\t\t\t<Text size=\"xl\" fw={600}>Entity Graph Debug</Text>\n\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">\n              Last updated: {lastUpdate.toLocaleTimeString()}\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\tleftSection={<IconRefresh size={14} />}\n\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tvoid refreshStats();\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tloading={isRefreshing}\n\t\t\t\t\t\t>\n              Refresh\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</Group>\n\t\t\t\t</Group>\n\n\t\t\t\t<Divider />\n\n\t\t\t\t<Tabs value={activeTab} onChange={(value) => {\n\t\t\t\t\tsetActiveTab(value || \"overview\");\n\t\t\t\t}}>\n\t\t\t\t\t<Tabs.List>\n\t\t\t\t\t\t<Tabs.Tab value=\"overview\" leftSection={<IconInfoCircle size={14} />}>\n              Overview\n\t\t\t\t\t\t</Tabs.Tab>\n\t\t\t\t\t\t<Tabs.Tab value=\"nodes\" leftSection={<IconNetwork size={14} />}>\n              Nodes\n\t\t\t\t\t\t</Tabs.Tab>\n\t\t\t\t\t\t<Tabs.Tab value=\"edges\" leftSection={<IconArrowRight size={14} />}>\n              Edges\n\t\t\t\t\t\t</Tabs.Tab>\n\t\t\t\t\t\t<Tabs.Tab value=\"performance\" leftSection={<IconBug size={14} />}>\n              Performance\n\t\t\t\t\t\t</Tabs.Tab>\n\t\t\t\t\t\t<Tabs.Tab value=\"debug\" leftSection={<IconSettings size={14} />}>\n              Debug\n\t\t\t\t\t\t</Tabs.Tab>\n\t\t\t\t\t</Tabs.List>\n\n\t\t\t\t\t<Tabs.Panel value=\"overview\" pt=\"md\">\n\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t<Group gap=\"xl\">\n\t\t\t\t\t\t\t\t<Paper p=\"md\" withBorder style={{ flex: 1 }}>\n\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Total Nodes</Text>\n\t\t\t\t\t\t\t\t\t<Text size=\"xl\" fw={600}>{stats.nodes.total}</Text>\n\t\t\t\t\t\t\t\t</Paper>\n\t\t\t\t\t\t\t\t<Paper p=\"md\" withBorder style={{ flex: 1 }}>\n\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Total Edges</Text>\n\t\t\t\t\t\t\t\t\t<Text size=\"xl\" fw={600}>{stats.edges.total}</Text>\n\t\t\t\t\t\t\t\t</Paper>\n\t\t\t\t\t\t\t\t<Paper p=\"md\" withBorder style={{ flex: 1 }}>\n\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Visited</Text>\n\t\t\t\t\t\t\t\t\t<Text size=\"xl\" fw={600}>{stats.nodes.directlyVisited}</Text>\n\t\t\t\t\t\t\t\t</Paper>\n\t\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Layout Information</Text>\n\t\t\t\t\t\t\t\t<Group gap=\"xl\">\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Algorithm</Text>\n\t\t\t\t\t\t\t\t\t\t<Badge color=\"blue\" variant=\"light\">{stats.layout.algorithm}</Badge>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Status</Text>\n\t\t\t\t\t\t\t\t\t\t<Badge color={stats.layout.isRunning ? \"green\" : \"gray\"} variant=\"light\">\n\t\t\t\t\t\t\t\t\t\t\t{stats.layout.isRunning ? \"Running\" : \"Idle\"}\n\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Iterations</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.layout.iterations}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\tleftSection={<IconRefresh size={14} />}\n\t\t\t\t\t\t\t\t\tonClick={resetGraph}\n\t\t\t\t\t\t\t\t>\n                  Reset Layout\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\tonClick={recenterGraph}\n\t\t\t\t\t\t\t\t>\n                  Recenter View\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Tabs.Panel>\n\n\t\t\t\t\t<Tabs.Panel value=\"nodes\" pt=\"md\">\n\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Node Distribution by Type</Text>\n\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t{Object.entries(stats.nodes.byType).map(([type, count]) => (\n\t\t\t\t\t\t\t\t\t\t<Group key={type} justify=\"space-between\">\n\t\t\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t<Badge color={getTypeColor(type)} variant=\"light\" size=\"sm\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{type}\n\t\t\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{count}</Text>\n\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Node Status</Text>\n\t\t\t\t\t\t\t\t<Group gap=\"xl\">\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Selected</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.nodes.selected.length}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Hidden</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.nodes.hidden}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Directly Visited</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.nodes.directlyVisited}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t\t\t{stats.nodes.selected.length > 0 && (\n\t\t\t\t\t\t\t\t\t<Box mt=\"sm\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\" mb=\"xs\">Selected Nodes:</Text>\n\t\t\t\t\t\t\t\t\t\t{stats.nodes.selected.map(nodeId => (\n\t\t\t\t\t\t\t\t\t\t\t<Code key={nodeId}>{nodeId}</Code>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</Paper>\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Tabs.Panel>\n\n\t\t\t\t\t<Tabs.Panel value=\"edges\" pt=\"md\">\n\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Edge Distribution by Type</Text>\n\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t{Object.entries(stats.edges.byType).map(([type, count]) => (\n\t\t\t\t\t\t\t\t\t\t<Group key={type} justify=\"space-between\">\n\t\t\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t<Badge color={getTypeColor(type)} variant=\"light\" size=\"sm\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{type}\n\t\t\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{count}</Text>\n\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Edge Status</Text>\n\t\t\t\t\t\t\t\t<Group gap=\"xl\">\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Selected</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.edges.selected.length}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Hidden</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.edges.hidden}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t</Paper>\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Tabs.Panel>\n\n\t\t\t\t\t<Tabs.Panel value=\"performance\" pt=\"md\">\n\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Rendering Performance</Text>\n\t\t\t\t\t\t\t\t<Group gap=\"xl\">\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Render Time</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.performance.renderTime}ms</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">FPS</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.performance.fps}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Memory Usage</Text>\n\t\t\t\t\t\t\t\t\t\t<Text fw={500}>{stats.performance.memoryUsage}</Text>\n\t\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t\t{stats.performance.renderTime > 30 && (\n\t\t\t\t\t\t\t\t<Alert color=\"yellow\" icon={<IconBug size={16} />}>\n                  High render time detected. Consider reducing node count or optimizing layout algorithm.\n\t\t\t\t\t\t\t\t</Alert>\n\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t{stats.performance.fps < 30 && (\n\t\t\t\t\t\t\t\t<Alert color=\"red\" icon={<IconBug size={16} />}>\n                  Low FPS detected. Graph performance may be impacted by too many nodes or complex layout calculations.\n\t\t\t\t\t\t\t\t</Alert>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Tabs.Panel>\n\n\t\t\t\t\t<Tabs.Panel value=\"debug\" pt=\"md\">\n\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Current Filter State</Text>\n\t\t\t\t\t\t\t\t<JsonInput\n\t\t\t\t\t\t\t\t\tvalue={JSON.stringify(stats.filterState, null, 2)}\n\t\t\t\t\t\t\t\t\treadOnly\n\t\t\t\t\t\t\t\t\tminRows={6}\n\t\t\t\t\t\t\t\t\tmaxRows={8}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t\t<Paper p=\"md\" withBorder>\n\t\t\t\t\t\t\t\t<Text fw={500} mb=\"sm\">Graph Actions</Text>\n\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t<Button size=\"sm\" variant=\"light\" onClick={() => {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"ui\", \"Export graph data requested\", {}, \"EntityGraphPanel\");\n\t\t\t\t\t\t\t\t\t}}>\n                    Export Graph Data\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t<Button size=\"sm\" variant=\"light\" onClick={() => {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"ui\", \"Log node positions requested\", {}, \"EntityGraphPanel\");\n\t\t\t\t\t\t\t\t\t}}>\n                    Log Node Positions\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t<Button size=\"sm\" variant=\"light\" onClick={() => {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"ui\", \"Validate graph structure requested\", {}, \"EntityGraphPanel\");\n\t\t\t\t\t\t\t\t\t}}>\n                    Validate Structure\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t\t<Alert color=\"blue\" icon={<IconInfoCircle size={16} />}>\n                Use browser console to see detailed debug output from graph actions.\n\t\t\t\t\t\t\t</Alert>\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Tabs.Panel>\n\t\t\t\t</Tabs>\n\t\t\t</Stack>\n\t\t</ScrollArea>\n\t);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/devtools/OpenAlexCachePanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/error/GlobalErrorBoundary.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":277,"column":25,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":277,"endColumn":27,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6656,6658],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":298,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":298,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7303,7305],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { Component, ErrorInfo, ReactNode } from \"react\";\nimport {\n\tContainer,\n\tStack,\n\tTitle,\n\tText,\n\tButton,\n\tCard,\n\tGroup,\n\tAlert,\n\tCode,\n\tScrollArea,\n\tDivider,\n\tActionIcon,\n\tTooltip,\n} from \"@mantine/core\";\nimport {\n\tIconAlertTriangle,\n\tIconRefresh,\n\tIconCopy,\n\tIconCheck,\n\tIconBug,\n\tIconExternalLink,\n\tIconDatabase,\n} from \"@tabler/icons-react\";\nimport { notifications } from \"@mantine/notifications\";\nimport { clearExpiredCache } from \"@academic-explorer/utils/cache\";\nimport { logger, logError } from \"@academic-explorer/utils/logger\";\n\ninterface Props {\n\tchildren: ReactNode;\n\tfallback?: ReactNode;\n}\n\ninterface State {\n\thasError: boolean;\n\terror: Error | null;\n\terrorInfo: ErrorInfo | null;\n\terrorId: string | null;\n\tdebugInfo: DebugInfo | null;\n\tcopied: boolean;\n\tclearingCache: boolean;\n}\n\ninterface DebugInfo {\n\ttimestamp: string;\n\tuserAgent: string;\n\turl: string;\n\tbuildInfo?: unknown;\n\terrorStack?: string | undefined;\n\tcomponentStack?: string | undefined;\n\terrorBoundary: string;\n\tadditionalContext: {\n\t\treactVersion: string;\n\t\tnodeEnv: string;\n\t\tisDev: boolean;\n\t};\n}\n\nexport class GlobalErrorBoundary extends Component<Props, State> {\n\tprivate copyTimeout: NodeJS.Timeout | null = null;\n\n\tconstructor(props: Props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\thasError: false,\n\t\t\terror: null,\n\t\t\terrorInfo: null,\n\t\t\terrorId: null,\n\t\t\tdebugInfo: null,\n\t\t\tcopied: false,\n\t\t\tclearingCache: false,\n\t\t};\n\t}\n\n\tstatic getDerivedStateFromError(error: Error): Partial<State> {\n\t\t// Update state so the next render will show the fallback UI\n\t\treturn {\n\t\t\thasError: true,\n\t\t\terror,\n\t\t};\n\t}\n\n\toverride componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n\t\tconst errorId = Math.random().toString(36).substring(7);\n\n\t\t// Generate comprehensive debug info\n\t\tconst debugInfo: DebugInfo = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tuserAgent: navigator.userAgent,\n\t\t\turl: window.location.href,\n\t\t\terrorStack: error.stack ?? undefined,\n\t\t\tcomponentStack: errorInfo.componentStack ?? undefined,\n\t\t\terrorBoundary: \"GlobalErrorBoundary\",\n\t\t\tadditionalContext: {\n\t\t\t\treactVersion: React.version,\n\t\t\t\tnodeEnv: import.meta.env.MODE,\n\t\t\t\tisDev: import.meta.env.DEV,\n\t\t\t},\n\t\t};\n\n\t\t// Try to get build info if available\n\t\ttry {\n\t\t\timport(\"@academic-explorer/utils\").then((buildModule) => {\n\t\t\t\tdebugInfo.buildInfo = buildModule.getBuildInfo();\n\t\t\t}).catch(() => {\n\t\t\t\t// Build info not available\n\t\t\t});\n\t\t} catch {\n\t\t\t// Build info not available\n\t\t}\n\n\t\t// Log error using application logger\n\t\tlogError(logger, \"React Error Boundary caught an error\", error, \"GlobalErrorBoundary\");\n\n\t\t// Log additional context\n\t\tlogger.error(\"ui\", \"Component stack trace\", {\n\t\t\tcomponentStack: errorInfo.componentStack,\n\t\t\terrorId,\n\t\t}, \"GlobalErrorBoundary\");\n\n\t\tthis.setState({\n\t\t\terrorInfo,\n\t\t\terrorId,\n\t\t\tdebugInfo,\n\t\t});\n\t}\n\n\tprivate handleReload = (): void => {\n\t\twindow.location.reload();\n\t};\n\n\tprivate handleReset = (): void => {\n\t\tthis.setState({\n\t\t\thasError: false,\n\t\t\terror: null,\n\t\t\terrorInfo: null,\n\t\t\terrorId: null,\n\t\t\tdebugInfo: null,\n\t\t\tcopied: false,\n\t\t\tclearingCache: false,\n\t\t});\n\t};\n\n\tprivate handleClearCache = async (): Promise<void> => {\n\t\tthis.setState({ clearingCache: true });\n\t\ttry {\n\t\t\t// Clear IndexedDB cache\n\t\t\tawait clearExpiredCache();\n\n\t\t\t// Clear localStorage cache\n\t\t\ttry {\n\t\t\t\tlocalStorage.removeItem(\"academic-explorer-cache\");\n\t\t\t} catch (localStorageError) {\n\t\t\t\tlogger.warn(\"ui\", \"Failed to clear localStorage cache\", { localStorageError }, \"GlobalErrorBoundary\");\n\t\t\t}\n\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Cache Cleared\",\n\t\t\t\tmessage: \"All cached data has been cleared. Please reload the page.\",\n\t\t\t\tcolor: \"green\",\n\t\t\t\ticon: <IconDatabase size={16} />,\n\t\t\t});\n\n\t\t\tlogger.debug(\"ui\", \"Cache cleared from error boundary\", {}, \"GlobalErrorBoundary\");\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to clear cache from error boundary\", error, \"GlobalErrorBoundary\");\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Cache Clear Failed\",\n\t\t\t\tmessage: \"Failed to clear cache. Please try reloading the page.\",\n\t\t\t\tcolor: \"red\",\n\t\t\t\ticon: <IconAlertTriangle size={16} />,\n\t\t\t});\n\t\t} finally {\n\t\t\tthis.setState({ clearingCache: false });\n\t\t}\n\t};\n\n\tprivate generateDebugData = (): string => {\n\t\tconst { error, errorInfo, errorId, debugInfo } = this.state;\n\n\t\tconst debugData = {\n\t\t\terrorId,\n\t\t\ttimestamp: debugInfo?.timestamp,\n\t\t\terror: {\n\t\t\t\tname: error?.name,\n\t\t\t\tmessage: error?.message,\n\t\t\t\tstack: error?.stack,\n\t\t\t},\n\t\t\terrorInfo: {\n\t\t\t\tcomponentStack: errorInfo?.componentStack,\n\t\t\t},\n\t\t\tenvironment: debugInfo?.additionalContext,\n\t\t\tbrowser: {\n\t\t\t\tuserAgent: debugInfo?.userAgent,\n\t\t\t\turl: debugInfo?.url,\n\t\t\t},\n\t\t\tbuildInfo: debugInfo?.buildInfo,\n\t\t};\n\n\t\treturn JSON.stringify(debugData, null, 2);\n\t};\n\n\tprivate handleCopyDebugData = async (): Promise<void> => {\n\t\ttry {\n\t\t\tconst debugData = this.generateDebugData();\n\t\t\tawait navigator.clipboard.writeText(debugData);\n\n\t\t\tthis.setState({ copied: true });\n\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Debug data copied\",\n\t\t\t\tmessage: \"Error information has been copied to your clipboard\",\n\t\t\t\tcolor: \"green\",\n\t\t\t\ticon: <IconCheck size={16} />,\n\t\t\t});\n\n\t\t\t// Reset copied state after 2 seconds\n\t\t\tif (this.copyTimeout) {\n\t\t\t\tclearTimeout(this.copyTimeout);\n\t\t\t}\n\t\t\tthis.copyTimeout = setTimeout(() => {\n\t\t\t\tthis.setState({ copied: false });\n\t\t\t}, 2000);\n\t\t} catch (clipboardError) {\n\t\t\tlogger.error(\"ui\", \"Failed to copy debug data to clipboard\", {\n\t\t\t\tclipboardError\n\t\t\t}, \"GlobalErrorBoundary\");\n\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Copy failed\",\n\t\t\t\tmessage: \"Could not copy to clipboard. Please copy manually from the debug section below.\",\n\t\t\t\tcolor: \"red\",\n\t\t\t\ticon: <IconAlertTriangle size={16} />,\n\t\t\t});\n\t\t}\n\t};\n\n\toverride componentWillUnmount(): void {\n\t\tif (this.copyTimeout) {\n\t\t\tclearTimeout(this.copyTimeout);\n\t\t}\n\t}\n\n\toverride render(): ReactNode {\n\t\tif (this.state.hasError) {\n\t\t\t// Custom fallback UI\n\t\t\tif (this.props.fallback) {\n\t\t\t\treturn this.props.fallback;\n\t\t\t}\n\n\t\t\tconst { error, errorId, copied, clearingCache } = this.state;\n\n\t\t\treturn (\n\t\t\t\t<Container size=\"md\" py=\"xl\">\n\t\t\t\t\t<Stack gap=\"lg\">\n\t\t\t\t\t\t{/* Header */}\n\t\t\t\t\t\t<Alert\n\t\t\t\t\t\t\ticon={<IconAlertTriangle size={24} />}\n\t\t\t\t\t\t\ttitle=\"Application Error\"\n\t\t\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Text size=\"sm\">\n\t\t\t\t\t\t\t\tSomething went wrong and the application encountered an unexpected error.\n\t\t\t\t\t\t\t\tThis error has been logged for investigation.\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t</Alert>\n\n\t\t\t\t\t\t{/* Error Details Card */}\n\t\t\t\t\t\t<Card withBorder shadow=\"sm\">\n\t\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t\t<Group justify=\"space-between\" align=\"flex-start\">\n\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t<Title order={3} c=\"red\">\n\t\t\t\t\t\t\t\t\t\t\t{error?.name || \"Unknown Error\"}\n\t\t\t\t\t\t\t\t\t\t</Title>\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\" mt={4}>\n\t\t\t\t\t\t\t\t\t\t\tError ID: {errorId}\n\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Tooltip label={copied ? \"Copied!\" : \"Copy debug data\"}>\n\t\t\t\t\t\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={copied ? \"green\" : \"blue\"}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => void this.handleCopyDebugData()}\n\t\t\t\t\t\t\t\t\t\t\t\tsize=\"lg\"\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t{copied ? <IconCheck size={18} /> : <IconCopy size={18} />}\n\t\t\t\t\t\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t\t\t<Text c=\"red.7\" fw={500}>\n\t\t\t\t\t\t\t\t\t{error?.message || \"An unexpected error occurred\"}\n\t\t\t\t\t\t\t\t</Text>\n\n\t\t\t\t\t\t\t\t{/* Action Buttons */}\n\t\t\t\t\t\t\t\t<Group>\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\tleftSection={<IconRefresh size={16} />}\n\t\t\t\t\t\t\t\t\t\tonClick={this.handleReload}\n\t\t\t\t\t\t\t\t\t\tvariant=\"filled\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\tReload Page\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\tleftSection={<IconBug size={16} />}\n\t\t\t\t\t\t\t\t\t\tonClick={this.handleReset}\n\t\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\tTry Again\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\tleftSection={<IconDatabase size={16} />}\n\t\t\t\t\t\t\t\t\t\tonClick={() => void this.handleClearCache()}\n\t\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\t\tcolor=\"orange\"\n\t\t\t\t\t\t\t\t\t\tloading={clearingCache}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\tClear Cache\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\tleftSection={<IconExternalLink size={16} />}\n\t\t\t\t\t\t\t\t\t\tcomponent=\"a\"\n\t\t\t\t\t\t\t\t\t\thref=\"https://github.com/JosephMearman/Academic-Explorer/issues\"\n\t\t\t\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\tReport Issue\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t</Card>\n\n\t\t\t\t\t\t{/* Debug Information (Development) */}\n\t\t\t\t\t\t{import.meta.env.DEV && (\n\t\t\t\t\t\t\t<Card withBorder shadow=\"sm\">\n\t\t\t\t\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t\t\t\t\t<Group align=\"center\">\n\t\t\t\t\t\t\t\t\t\t<IconBug size={20} />\n\t\t\t\t\t\t\t\t\t\t<Title order={4}>Debug Information</Title>\n\t\t\t\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t\t\tThis debug information is only shown in development mode.\n\t\t\t\t\t\t\t\t\t\tClick the copy button above to copy all debug data to clipboard.\n\t\t\t\t\t\t\t\t\t</Text>\n\n\t\t\t\t\t\t\t\t\t<Divider />\n\n\t\t\t\t\t\t\t\t\t{error?.stack && (\n\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500} size=\"sm\" mb=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t\tError Stack:\n\t\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t\t<ScrollArea.Autosize mah={200}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Code block color=\"red\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{error.stack}\n\t\t\t\t\t\t\t\t\t\t\t\t</Code>\n\t\t\t\t\t\t\t\t\t\t\t</ScrollArea.Autosize>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t\t\t{this.state.errorInfo?.componentStack && (\n\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t<Text fw={500} size=\"sm\" mb=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t\tComponent Stack:\n\t\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t\t<ScrollArea.Autosize mah={150}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Code block color=\"orange\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{this.state.errorInfo.componentStack}\n\t\t\t\t\t\t\t\t\t\t\t\t</Code>\n\t\t\t\t\t\t\t\t\t\t\t</ScrollArea.Autosize>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t\t\t<details>\n\t\t\t\t\t\t\t\t\t\t<summary style={{ cursor: \"pointer\", fontWeight: 500 }}>\n\t\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\" component=\"span\">\n\t\t\t\t\t\t\t\t\t\t\t\tFull Debug Data (JSON)\n\t\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t</summary>\n\t\t\t\t\t\t\t\t\t\t<ScrollArea.Autosize mah={300} mt=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t<Code block>\n\t\t\t\t\t\t\t\t\t\t\t\t{this.generateDebugData()}\n\t\t\t\t\t\t\t\t\t\t\t</Code>\n\t\t\t\t\t\t\t\t\t\t</ScrollArea.Autosize>\n\t\t\t\t\t\t\t\t\t</details>\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* User Guidance */}\n\t\t\t\t\t\t<Alert icon={<IconBug size={16} />} title=\"What you can do:\" variant=\"light\">\n\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t<Text size=\"sm\">\n\t\t\t\t\t\t\t\t\t• <strong>Reload the page</strong> - This often resolves temporary issues\n\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t<Text size=\"sm\">\n\t\t\t\t\t\t\t\t\t• <strong>Try again</strong> - Reset the error state and continue using the app\n\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t<Text size=\"sm\">\n\t\t\t\t\t\t\t\t\t• <strong>Clear cache</strong> - Remove cached data that might be causing issues\n\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t<Text size=\"sm\">\n\t\t\t\t\t\t\t\t\t• <strong>Report the issue</strong> - Help us improve by reporting this error on GitHub\n\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t{import.meta.env.DEV && (\n\t\t\t\t\t\t\t\t\t<Text size=\"sm\">\n\t\t\t\t\t\t\t\t\t\t• <strong>Copy debug data</strong> - Share technical details when reporting issues\n\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t</Alert>\n\t\t\t\t\t</Stack>\n\t\t\t\t</Container>\n\t\t\t);\n\t\t}\n\n\t\treturn this.props.children;\n\t}\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/error/RouterErrorComponent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/evaluation/MetaAnalysisCharts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/evaluation/MissingPaperDetection.tsx","messages":[{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":63,"column":20,"nodeType":"AwaitExpression","messageId":"await","endLine":71,"endColumn":5,"suggestions":[{"messageId":"removeAwait","fix":{"range":[2039,2044],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":690,"column":30,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":690,"endColumn":32,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[21540,21542],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Missing Paper Detection Component for STAR Evaluation\n * Provides UI for identifying potentially missed papers in systematic reviews\n */\n\nimport React, { useState, useMemo } from \"react\"\nimport { IconClipboard, IconAlertTriangle } from \"@tabler/icons-react\"\nimport type {\n\tMissingPaperDetectionResults,\n\tMissingPaperDetectionConfig,\n\tDetectionProgress\n} from \"@academic-explorer/utils\";\nimport type { STARDataset, WorkReference } from \"@academic-explorer/utils\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface MissingPaperDetectionProps {\n  dataset: STARDataset\n  onDetectionComplete?: (results: MissingPaperDetectionResults) => void\n}\n\ninterface DetectionJob {\n  id: string\n  datasetId: string\n  status: \"ready\" | \"running\" | \"completed\" | \"failed\"\n  results?: MissingPaperDetectionResults\n  progress?: DetectionProgress | undefined\n  error?: string\n  startTime?: Date\n  endTime?: Date\n}\n\nexport function MissingPaperDetection({ dataset, onDetectionComplete }: MissingPaperDetectionProps) {\n\tconst [detectionJobs, setDetectionJobs] = useState<DetectionJob[]>([])\n\tconst [detectionConfig, setDetectionConfig] = useState<MissingPaperDetectionConfig>({\n\t\tmaxPapersPerMethod: 50,\n\t\tminimumCitationThreshold: 5,\n\t\ttemporalWindowYears: 2,\n\t\tenableCitationAnalysis: true,\n\t\tenableAuthorAnalysis: true,\n\t\tenableTemporalAnalysis: true,\n\t\tenableKeywordExpansion: false\n\t})\n\n\tconst currentJob = useMemo(() => {\n\t\treturn detectionJobs.find(job => job.datasetId === dataset.id)\n\t}, [detectionJobs, dataset.id])\n\n\tconst handleStartDetection = async () => {\n\t\tconst jobId = \"detection_\" + dataset.id + \"_\" + Date.now().toString()\n\t\tconst newJob: DetectionJob = {\n\t\t\tid: jobId,\n\t\t\tdatasetId: dataset.id,\n\t\t\tstatus: \"running\",\n\t\t\tstartTime: new Date()\n\t\t}\n\n\t\tsetDetectionJobs(prev => [...prev.filter(j => j.datasetId !== dataset.id), newJob])\n\n\t\ttry {\n\t\t\t// Dynamic import to avoid loading the heavy detection module until needed\n\t\t\tconst { detectMissingPapers } = await import(\"@academic-explorer/utils\")\n\n\t\t\tconst results = await detectMissingPapers(\n\t\t\t\tdataset,\n\t\t\t\tdetectionConfig,\n\t\t\t\t(progress) => {\n\t\t\t\t\tsetDetectionJobs(prev => prev.map(job =>\n\t\t\t\t\t\tjob.id === jobId ? { ...job, progress } : job\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tconst completedJob: DetectionJob = {\n\t\t\t\t...newJob,\n\t\t\t\tstatus: \"completed\",\n\t\t\t\tresults,\n\t\t\t\tendTime: new Date()\n\t\t\t}\n\t\t\tdelete completedJob.progress\n\n\t\t\tsetDetectionJobs(prev => prev.map(job =>\n\t\t\t\tjob.id === jobId ? completedJob : job\n\t\t\t))\n\n\t\t\tonDetectionComplete?.(results)\n\t\t} catch (error) {\n\t\t\tconst failedJob: DetectionJob = {\n\t\t\t\t...newJob,\n\t\t\t\tstatus: \"failed\",\n\t\t\t\terror: error instanceof Error ? error.message : \"Detection failed\",\n\t\t\t\tendTime: new Date()\n\t\t\t}\n\t\t\tdelete failedJob.progress\n\n\t\t\tsetDetectionJobs(prev => prev.map(job =>\n\t\t\t\tjob.id === jobId ? failedJob : job\n\t\t\t))\n\t\t}\n\t}\n\n\tconst formatExecutionTime = (job: DetectionJob): string => {\n\t\tif (!job.startTime || !job.endTime) return \"N/A\"\n\t\tconst duration = job.endTime.getTime() - job.startTime.getTime()\n\t\treturn `${(duration / 1000).toFixed(1)}s`\n\t}\n\n\treturn (\n\t\t<div style={{\n\t\t\tbackgroundColor: \"white\",\n\t\t\tborderRadius: \"12px\",\n\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\tpadding: \"24px\"\n\t\t}}>\n\t\t\t{/* Header */}\n\t\t\t<div style={{ marginBottom: \"24px\" }}>\n\t\t\t\t<h3 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"8px\" }}>\n          Missing Paper Detection\n\t\t\t\t</h3>\n\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", margin: 0 }}>\n          Identify potentially relevant papers that may have been missed by the systematic review\n\t\t\t\t</p>\n\t\t\t</div>\n\n\t\t\t{/* Configuration Panel */}\n\t\t\t<div style={{\n\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\tborderRadius: \"8px\",\n\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\tpadding: \"20px\",\n\t\t\t\tmarginBottom: \"24px\"\n\t\t\t}}>\n\t\t\t\t<h4 style={{ fontSize: \"16px\", fontWeight: \"500\", color: \"#1f2937\", marginBottom: \"16px\" }}>\n          Detection Configuration\n\t\t\t\t</h4>\n\n\t\t\t\t<div style={{\n\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\tgridTemplateColumns: \"repeat(auto-fit, minmax(200px, 1fr))\",\n\t\t\t\t\tgap: \"16px\",\n\t\t\t\t\tmarginBottom: \"16px\"\n\t\t\t\t}}>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<label htmlFor=\"max-papers-input\" style={{ fontSize: \"14px\", fontWeight: \"500\", color: \"#374151\", display: \"block\", marginBottom: \"4px\" }}>\n              Max Papers per Method\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tid=\"max-papers-input\"\n\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\tvalue={detectionConfig.maxPapersPerMethod}\n\t\t\t\t\t\t\tonChange={(e) => { setDetectionConfig(prev => ({ ...prev, maxPapersPerMethod: parseInt(e.target.value) })); }}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #d1d5db\",\n\t\t\t\t\t\t\t\tfontSize: \"14px\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tmin=\"10\"\n\t\t\t\t\t\t\tmax=\"200\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<label htmlFor=\"min-citation-input\" style={{ fontSize: \"14px\", fontWeight: \"500\", color: \"#374151\", display: \"block\", marginBottom: \"4px\" }}>\n              Min Citation Threshold\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tid=\"min-citation-input\"\n\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\tvalue={detectionConfig.minimumCitationThreshold}\n\t\t\t\t\t\t\tonChange={(e) => { setDetectionConfig(prev => ({ ...prev, minimumCitationThreshold: parseInt(e.target.value) })); }}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #d1d5db\",\n\t\t\t\t\t\t\t\tfontSize: \"14px\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tmin=\"0\"\n\t\t\t\t\t\t\tmax=\"50\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<label htmlFor=\"temporal-window-input\" style={{ fontSize: \"14px\", fontWeight: \"500\", color: \"#374151\", display: \"block\", marginBottom: \"4px\" }}>\n              Temporal Window (Years)\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tid=\"temporal-window-input\"\n\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\tvalue={detectionConfig.temporalWindowYears}\n\t\t\t\t\t\t\tonChange={(e) => { setDetectionConfig(prev => ({ ...prev, temporalWindowYears: parseInt(e.target.value) })); }}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #d1d5db\",\n\t\t\t\t\t\t\t\tfontSize: \"14px\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tmin=\"0\"\n\t\t\t\t\t\t\tmax=\"10\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Detection Method Toggles */}\n\t\t\t\t<div style={{ display: \"flex\", flexWrap: \"wrap\", gap: \"16px\" }}>\n\t\t\t\t\t{[\n\t\t\t\t\t\t{ key: \"enableTemporalAnalysis\", label: \"Temporal Gap Analysis\" },\n\t\t\t\t\t\t{ key: \"enableCitationAnalysis\", label: \"Citation Network Analysis\" },\n\t\t\t\t\t\t{ key: \"enableAuthorAnalysis\", label: \"Author Network Analysis\" },\n\t\t\t\t\t\t{ key: \"enableKeywordExpansion\", label: \"Keyword Expansion (Experimental)\" }\n\t\t\t\t\t].map(({ key, label }) => (\n\t\t\t\t\t\t<label key={key} style={{ display: \"flex\", alignItems: \"center\", fontSize: \"14px\", color: \"#374151\" }}>\n\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t\t\tchecked={(() => {\n\t\t\t\t\t\t\t\t\t// Type guard to check if key is a valid config property\n\t\t\t\t\t\t\t\t\tif (key === \"enableTemporalAnalysis\" || key === \"enableCitationAnalysis\" ||\n                      key === \"enableAuthorAnalysis\" || key === \"enableKeywordExpansion\") {\n\t\t\t\t\t\t\t\t\t\tconst value = detectionConfig[key];\n\t\t\t\t\t\t\t\t\t\treturn typeof value === \"boolean\" ? value : false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t})()}\n\t\t\t\t\t\t\t\tonChange={(e) => { setDetectionConfig(prev => ({ ...prev, [key]: e.target.checked })); }}\n\t\t\t\t\t\t\t\tstyle={{ marginRight: \"8px\" }}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t{label}\n\t\t\t\t\t\t</label>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t{/* Detection Control */}\n\t\t\t<div style={{ marginBottom: \"24px\" }}>\n\t\t\t\t<button\n\t\t\t\t\tonClick={() => { void handleStartDetection(); }}\n\t\t\t\t\tdisabled={currentJob?.status === \"running\"}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tpadding: \"12px 24px\",\n\t\t\t\t\t\tbackgroundColor: currentJob?.status === \"running\" ? \"#9ca3af\" : \"#3b82f6\",\n\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\tfontSize: \"16px\",\n\t\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\t\tcursor: currentJob?.status === \"running\" ? \"not-allowed\" : \"pointer\",\n\t\t\t\t\t\tmarginRight: \"12px\"\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{currentJob?.status === \"running\" ? \"Detecting...\" : \"Start Detection\"}\n\t\t\t\t</button>\n\n\t\t\t\t{currentJob?.results && (\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={() => { logger.debug(\"ui\", \"Export detection results clicked\", { resultsCount: currentJob.results?.candidateMissingPapers.length }, \"MissingPaperDetection\"); }}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tpadding: \"12px 24px\",\n\t\t\t\t\t\t\tbackgroundColor: \"#10b981\",\n\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\tfontSize: \"16px\",\n\t\t\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n            Export Results\n\t\t\t\t\t</button>\n\t\t\t\t)}\n\t\t\t</div>\n\n\t\t\t{/* Progress Display */}\n\t\t\t{currentJob?.progress && (\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"#fef3c7\",\n\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\tborder: \"1px solid #fbbf24\",\n\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\tmarginBottom: \"24px\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t<span style={{ fontSize: \"14px\", fontWeight: \"500\", color: \"#92400e\" }}>\n\t\t\t\t\t\t\t{currentJob.progress.currentMethod}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span style={{ fontSize: \"14px\", fontWeight: \"500\", color: \"#92400e\" }}>\n\t\t\t\t\t\t\t{currentJob.progress.progress}%\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\tbackgroundColor: \"#fde68a\",\n\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\theight: \"8px\",\n\t\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\twidth: `${String(currentJob.progress.progress)}%`,\n\t\t\t\t\t\t\tbackgroundColor: \"#f59e0b\",\n\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\theight: \"100%\"\n\t\t\t\t\t\t}} />\n\t\t\t\t\t</div>\n\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#78350f\", margin: 0 }}>\n\t\t\t\t\t\t{currentJob.progress.message} • {currentJob.progress.papersFound} papers found\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{/* Results Display */}\n\t\t\t{currentJob?.results && (\n\t\t\t\t<MissingPaperResults\n\t\t\t\t\tresults={currentJob.results}\n\t\t\t\t\texecutionTime={formatExecutionTime(currentJob)}\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t{/* Error Display */}\n\t\t\t{currentJob?.status === \"failed\" && (\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"#fef2f2\",\n\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\tborder: \"1px solid #fca5a5\",\n\t\t\t\t\tpadding: \"16px\"\n\t\t\t\t}}>\n\t\t\t\t\t<h4 style={{ fontSize: \"16px\", fontWeight: \"500\", color: \"#dc2626\", marginBottom: \"8px\" }}>\n            Detection Failed\n\t\t\t\t\t</h4>\n\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#7f1d1d\", margin: 0 }}>\n\t\t\t\t\t\t{currentJob.error}\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n}\n\ninterface MissingPaperResultsProps {\n  results: MissingPaperDetectionResults\n  executionTime: string\n}\n\nfunction MissingPaperResults({ results, executionTime }: MissingPaperResultsProps) {\n\tconst [activeTab, setActiveTab] = useState<\"summary\" | \"candidates\" | \"methods\" | \"validation\">(\"summary\")\n\n\tconst formatPercent = (value: number) => `${(value * 100).toFixed(1)}%`\n\n\treturn (\n\t\t<div style={{\n\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\tborderRadius: \"8px\",\n\t\t\toverflow: \"hidden\"\n\t\t}}>\n\t\t\t{/* Tabs */}\n\t\t\t<div style={{\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\tborderBottom: \"1px solid #e5e7eb\",\n\t\t\t\tbackgroundColor: \"#f9fafb\"\n\t\t\t}}>\n\t\t\t\t{[\n\t\t\t\t\t{ key: \"summary\", label: \"Summary\" },\n\t\t\t\t\t{ key: \"candidates\", label: `Candidates (${String(results.candidateMissingPapers.length)})` },\n\t\t\t\t\t{ key: \"methods\", label: \"Methods\" },\n\t\t\t\t\t{ key: \"validation\", label: \"Validation\" }\n\t\t\t\t].map((tab) => (\n\t\t\t\t\t<button\n\t\t\t\t\t\tkey={tab.key}\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tconst tabKey = tab.key;\n\t\t\t\t\t\t\tif (tabKey === \"summary\" || tabKey === \"candidates\" || tabKey === \"methods\" || tabKey === \"validation\") {\n\t\t\t\t\t\t\t\tsetActiveTab(tabKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tpadding: \"12px 20px\",\n\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\tbackgroundColor: activeTab === tab.key ? \"white\" : \"transparent\",\n\t\t\t\t\t\t\tcolor: activeTab === tab.key ? \"#3b82f6\" : \"#6b7280\",\n\t\t\t\t\t\t\tfontWeight: activeTab === tab.key ? \"600\" : \"400\",\n\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\t\tborderBottom: activeTab === tab.key ? \"2px solid #3b82f6\" : \"none\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{tab.label}\n\t\t\t\t\t</button>\n\t\t\t\t))}\n\t\t\t</div>\n\n\t\t\t{/* Tab Content */}\n\t\t\t<div style={{ padding: \"24px\" }}>\n\t\t\t\t{activeTab === \"summary\" && (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"16px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"16px\" }}>\n              Detection Summary\n\t\t\t\t\t\t</h4>\n\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\t\t\tgridTemplateColumns: \"repeat(auto-fit, minmax(200px, 1fr))\",\n\t\t\t\t\t\t\tgap: \"16px\",\n\t\t\t\t\t\t\tmarginBottom: \"24px\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#3b82f6\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{results.detectionStatistics.totalCandidates}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\" }}>Total Candidates</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#10b981\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{results.detectionStatistics.highConfidenceCandidates}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\" }}>High Confidence</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#8b5cf6\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{results.detectionStatistics.averageCitationCount.toFixed(1)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\" }}>Avg Citations</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#f59e0b\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{formatPercent(results.validationMetrics.confidenceScore)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\" }}>Confidence</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\tpadding: \"16px\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<h5 style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n                Execution Details\n\t\t\t\t\t\t\t</h5>\n\t\t\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#6b7280\", margin: 0 }}>\n                Dataset: {results.dataset.name} • Execution Time: {executionTime} •\n                Methods: {Object.values(results.detectionStatistics.methodContributions).filter(count => count > 0).length}/4\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\n\t\t\t\t{activeTab === \"candidates\" && (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"16px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"16px\" }}>\n              Candidate Missing Papers\n\t\t\t\t\t\t</h4>\n\n\t\t\t\t\t\t{results.candidateMissingPapers.length === 0 ? (\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\t\t\t\tpadding: \"48px 24px\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\t\t\t\tborderRadius: \"8px\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div style={{ marginBottom: \"16px\", opacity: 0.3 }}>\n\t\t\t\t\t\t\t\t\t<IconClipboard size={48} />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<p style={{ fontSize: \"16px\", color: \"#6b7280\", margin: 0 }}>\n                  No potential missing papers detected\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<div style={{ display: \"grid\", gap: \"16px\" }}>\n\t\t\t\t\t\t\t\t{results.candidateMissingPapers.slice(0, 20).map((paper, index) => (\n\t\t\t\t\t\t\t\t\t<PaperCard key={paper.title || `paper-${String(index)}`} paper={paper} rank={index + 1} />\n\t\t\t\t\t\t\t\t))}\n\n\t\t\t\t\t\t\t\t{results.candidateMissingPapers.length > 20 && (\n\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"8px\"\n\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", margin: 0 }}>\n                      Showing top 20 of {results.candidateMissingPapers.length} candidates\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\n\t\t\t\t{activeTab === \"methods\" && (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"16px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"16px\" }}>\n              Detection Methods Breakdown\n\t\t\t\t\t\t</h4>\n\n\t\t\t\t\t\t<div style={{ display: \"grid\", gap: \"16px\" }}>\n\t\t\t\t\t\t\t{Object.entries(results.detectionStatistics.methodContributions).map(([method, count]) => (\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tkey={method}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\t\t\tjustifyContent: \"space-between\",\n\t\t\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"8px\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t<h5 style={{ fontSize: \"14px\", fontWeight: \"500\", color: \"#1f2937\", marginBottom: \"4px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t{method.replace(/([A-Z])/g, \" $1\").replace(/^./, str => str.toUpperCase())}\n\t\t\t\t\t\t\t\t\t\t</h5>\n\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#6b7280\", margin: 0 }}>\n\t\t\t\t\t\t\t\t\t\t\t{getMethodDescription(method)}\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: count > 0 ? \"#10b981\" : \"#9ca3af\",\n\t\t\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"20px\",\n\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\tfontWeight: \"600\"\n\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t{count}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\n\t\t\t\t{activeTab === \"validation\" && (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"16px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"16px\" }}>\n              Validation Metrics\n\t\t\t\t\t\t</h4>\n\n\t\t\t\t\t\t<div style={{ marginBottom: \"24px\" }}>\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\tjustifyContent: \"space-between\",\n\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<span style={{ fontSize: \"14px\", color: \"#374151\" }}>Algorithm Confidence</span>\n\t\t\t\t\t\t\t\t<span style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#1f2937\" }}>\n\t\t\t\t\t\t\t\t\t{formatPercent(results.validationMetrics.confidenceScore)}\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#e5e7eb\",\n\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\theight: \"8px\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\twidth: `${String(results.validationMetrics.confidenceScore * 100)}%`,\n\t\t\t\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\t\theight: \"100%\"\n\t\t\t\t\t\t\t\t}} />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t{results.validationMetrics.algorithmicBias.length > 0 && (\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<h5 style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#dc2626\", marginBottom: \"12px\" }}>\n                  Potential Algorithmic Biases\n\t\t\t\t\t\t\t\t</h5>\n\t\t\t\t\t\t\t\t<div style={{ display: \"grid\", gap: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{results.validationMetrics.algorithmicBias.map((bias, index) => (\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tkey={`bias-${String(index)}-${bias.substring(0, 10)}`}\n\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\tpadding: \"12px\",\n\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#fef2f2\",\n\t\t\t\t\t\t\t\t\t\t\t\tborder: \"1px solid #fca5a5\",\n\t\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\"\n\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#7f1d1d\", margin: 0, display: \"flex\", alignItems: \"center\", gap: \"4px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<IconAlertTriangle size={12} />\n\t\t\t\t\t\t\t\t\t\t\t\t{bias}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\ninterface PaperCardProps {\n  paper: WorkReference\n  rank: number\n}\n\nfunction PaperCard({ paper, rank }: PaperCardProps) {\n\treturn (\n\t\t<div style={{\n\t\t\tpadding: \"16px\",\n\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\tborderRadius: \"8px\",\n\t\t\tbackgroundColor: \"white\"\n\t\t}}>\n\t\t\t<div style={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"flex-start\", marginBottom: \"12px\" }}>\n\t\t\t\t<div style={{ flex: 1 }}>\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<span style={{\n\t\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\tpadding: \"4px 8px\",\n\t\t\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\t\t\tmarginRight: \"12px\"\n\t\t\t\t\t\t}}>\n              #{rank}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<h5 style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#1f2937\", margin: 0, lineHeight: \"1.4\" }}>\n\t\t\t\t\t\t\t{paper.title}\n\t\t\t\t\t\t</h5>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#6b7280\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t{paper.authors.slice(0, 3).join(\", \")}{paper.authors.length > 3 ? ` et al. (${String(paper.authors.length)} authors)` : \"\"}\n\t\t\t\t\t</p>\n\n\t\t\t\t\t<div style={{ display: \"flex\", flexWrap: \"wrap\", gap: \"8px\", alignItems: \"center\" }}>\n\t\t\t\t\t\t<span style={{ fontSize: \"12px\", color: \"#6b7280\" }}>\n\t\t\t\t\t\t\t{paper.publicationYear} • {paper.source}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t{paper.citedByCount !== undefined && (\n\t\t\t\t\t\t\t<span style={{\n\t\t\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\t\t\tcolor: \"#374151\",\n\t\t\t\t\t\t\t\tpadding: \"2px 6px\",\n\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\t\t\tfontWeight: \"500\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t{paper.citedByCount} citations\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{paper.doi && (\n\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\thref={`https://doi.org/${paper.doi}`}\n\t\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\t\trel=\"noopener noreferrer\"\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\tbackgroundColor: \"#dbeafe\",\n\t\t\t\t\t\t\t\t\tcolor: \"#3b82f6\",\n\t\t\t\t\t\t\t\t\tpadding: \"2px 6px\",\n\t\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\ttextDecoration: \"none\"\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n                DOI\n\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\nfunction getMethodDescription(method: string): string {\n\tconst descriptions: { [key: string]: string } = {\n\t\ttemporalGapAnalysis: \"Find papers published during review period matching search criteria\",\n\t\tcitationNetworkAnalysis: \"Discover papers that cite or are cited by included papers\",\n\t\tauthorNetworkAnalysis: \"Locate papers by authors who published included papers\",\n\t\tkeywordExpansionAnalysis: \"Use semantic similarity to find papers with related terminology\"\n\t}\n\n\treturn descriptions[method] || \"Unknown detection method\"\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/graph/AnimatedGraphControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/graph/AnimatedLayoutProvider.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":50,"column":3,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":50,"endColumn":16},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'startAnimation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":51,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":51,"endColumn":17},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'reheatAnimation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":55,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":18},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'updateSimulationParameters' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":56,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":47},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'applyLayout' function makes the dependencies of useEffect Hook (at line 161) change on every render. To fix this, wrap the definition of 'applyLayout' in its own useCallback() Hook.","line":79,"column":8,"nodeType":"VariableDeclarator","endLine":81,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'applyLayout' in its own useCallback() Hook.","fix":{"range":[2487,2565],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Apply layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'applyLayout' function makes the dependencies of useEffect Hook (at line 243) change on every render. To fix this, wrap the definition of 'applyLayout' in its own useCallback() Hook.","line":79,"column":8,"nodeType":"VariableDeclarator","endLine":81,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'applyLayout' in its own useCallback() Hook.","fix":{"range":[2487,2565],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Apply layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'applyLayout' function makes the dependencies of useEffect Hook (at line 315) change on every render. To fix this, wrap the definition of 'applyLayout' in its own useCallback() Hook.","line":79,"column":8,"nodeType":"VariableDeclarator","endLine":81,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'applyLayout' in its own useCallback() Hook.","fix":{"range":[2487,2565],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Apply layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'applyLayout' function makes the dependencies of useMemo Hook (at line 352) change on every render. To fix this, wrap the definition of 'applyLayout' in its own useCallback() Hook.","line":79,"column":8,"nodeType":"VariableDeclarator","endLine":81,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'applyLayout' in its own useCallback() Hook.","fix":{"range":[2487,2565],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Apply layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'stopLayout' function makes the dependencies of useMemo Hook (at line 352) change on every render. Move it inside the useMemo callback. Alternatively, wrap the definition of 'stopLayout' in its own useCallback() Hook.","line":82,"column":8,"nodeType":"VariableDeclarator","endLine":84,"endColumn":3},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'pauseLayout' function makes the dependencies of useMemo Hook (at line 352) change on every render. Move it inside the useMemo callback. Alternatively, wrap the definition of 'pauseLayout' in its own useCallback() Hook.","line":85,"column":8,"nodeType":"VariableDeclarator","endLine":87,"endColumn":3},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'resumeLayout' function makes the dependencies of useMemo Hook (at line 352) change on every render. Move it inside the useMemo callback. Alternatively, wrap the definition of 'resumeLayout' in its own useCallback() Hook.","line":88,"column":8,"nodeType":"VariableDeclarator","endLine":90,"endColumn":3},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'reheatLayout' function makes the dependencies of useEffect Hook (at line 161) change on every render. To fix this, wrap the definition of 'reheatLayout' in its own useCallback() Hook.","line":91,"column":8,"nodeType":"VariableDeclarator","endLine":93,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'reheatLayout' in its own useCallback() Hook.","fix":{"range":[2763,2842],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Reheat layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'reheatLayout' function makes the dependencies of useEffect Hook (at line 192) change on every render. To fix this, wrap the definition of 'reheatLayout' in its own useCallback() Hook.","line":91,"column":8,"nodeType":"VariableDeclarator","endLine":93,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'reheatLayout' in its own useCallback() Hook.","fix":{"range":[2763,2842],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Reheat layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'reheatLayout' function makes the dependencies of useEffect Hook (at line 243) change on every render. To fix this, wrap the definition of 'reheatLayout' in its own useCallback() Hook.","line":91,"column":8,"nodeType":"VariableDeclarator","endLine":93,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'reheatLayout' in its own useCallback() Hook.","fix":{"range":[2763,2842],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Reheat layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'reheatLayout' function makes the dependencies of useEffect Hook (at line 315) change on every render. To fix this, wrap the definition of 'reheatLayout' in its own useCallback() Hook.","line":91,"column":8,"nodeType":"VariableDeclarator","endLine":93,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'reheatLayout' in its own useCallback() Hook.","fix":{"range":[2763,2842],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Reheat layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'reheatLayout' function makes the dependencies of useMemo Hook (at line 352) change on every render. To fix this, wrap the definition of 'reheatLayout' in its own useCallback() Hook.","line":91,"column":8,"nodeType":"VariableDeclarator","endLine":93,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'reheatLayout' in its own useCallback() Hook.","fix":{"range":[2763,2842],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Reheat layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'updateParameters' function makes the dependencies of useMemo Hook (at line 352) change on every render. Move it inside the useMemo callback. Alternatively, wrap the definition of 'updateParameters' in its own useCallback() Hook.","line":94,"column":8,"nodeType":"VariableDeclarator","endLine":96,"endColumn":3},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'restartLayout' function makes the dependencies of useEffect Hook (at line 192) change on every render. To fix this, wrap the definition of 'restartLayout' in its own useCallback() Hook.","line":97,"column":8,"nodeType":"VariableDeclarator","endLine":99,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'restartLayout' in its own useCallback() Hook.","fix":{"range":[2985,3065],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Restart layout called but not implemented\");\n\t})"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'restartLayout' function makes the dependencies of useMemo Hook (at line 352) change on every render. To fix this, wrap the definition of 'restartLayout' in its own useCallback() Hook.","line":97,"column":8,"nodeType":"VariableDeclarator","endLine":99,"endColumn":3,"suggestions":[{"desc":"Wrap the definition of 'restartLayout' in its own useCallback() Hook.","fix":{"range":[2985,3065],"text":"useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Restart layout called but not implemented\");\n\t})"}}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":179,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":179,"endColumn":18},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'listenerId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":238,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":238,"endColumn":19},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'bulkNodesListenerId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":308,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":308,"endColumn":28},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'bulkEdgesListenerId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":309,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":309,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":324,"column":3,"nodeType":"Property","messageId":"anyAssignment","endLine":324,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":378,"column":3,"nodeType":"Property","messageId":"anyAssignment","endLine":378,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":385,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10706,10709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10706,10709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__animatedGraphDebug on an `any` value.","line":385,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":385,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":388,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":388,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":28,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Animated Layout Provider Component\n * Provides animated layout functionality to existing graph components\n * Can be dropped into existing graph implementations\n */\n\nimport React, { useEffect, useMemo, useRef } from \"react\";\nimport { useAnimatedGraphStore, useRestartRequested, useClearRestartRequest } from \"@/stores/animated-graph-store\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { AnimatedLayoutContext } from \"./animated-layout-context\";\nimport { useReactFlow } from \"@xyflow/react\";\nimport { useEventBus } from \"@/hooks/use-unified-event-system\";\nimport { useUnifiedExecutionWorker } from \"@/hooks/use-unified-execution-worker\";\n\ninterface AnimatedLayoutProviderProps {\n  children: React.ReactNode;\n  enabled?: boolean;\n  onLayoutChange?: () => void;\n  containerDimensions?: { width: number; height: number };\n  autoStartOnNodeChange?: boolean;\n}\n\nexport const AnimatedLayoutProvider: React.FC<AnimatedLayoutProviderProps> = ({\n\tchildren,\n\tenabled = true,\n\tonLayoutChange,\n\tautoStartOnNodeChange = false,\n}) => {\n\t// Unified event bus for cross-component communication\n\tconst eventBus = useEventBus();\n\n\t// Use stable selector to prevent infinite loops in React 19\n\tconst useAnimation = useAnimatedGraphStore((state) => state.useAnimatedLayout);\n\n\t// ReactFlow hooks for node tracking\n\tconst { getNodes, getEdges } = useReactFlow();\n\n\t// Track previous node/edge counts for change detection\n\tconst prevNodeCountRef = useRef(0);\n\tconst prevEdgeCountRef = useRef(0);\n\tconst autoTriggerTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n\n\t// Communication for restart requests from components outside this provider\n\tconst restartRequested = useRestartRequested();\n\tconst clearRestartRequest = useClearRestartRequest();\n\n\t// Use the unified execution worker for animation\n\tconst {\n\t\tanimationState,\n\t\tisWorkerReady,\n\t\tstartAnimation,\n\t\tstopAnimation,\n\t\tpauseAnimation,\n\t\tresumeAnimation,\n\t\treheatAnimation,\n\t\tupdateParameters: updateSimulationParameters,\n\t\tcanPause,\n\t\tcanResume,\n\t\tcanStop,\n\t\tisIdle,\n\t} = useUnifiedExecutionWorker(\n\t\tonLayoutChange ? { onPositionUpdate: onLayoutChange } : {}\n\t);\n\n\t// Extract animation state properties\n\tconst {\n\t\tisRunning,\n\t\tisPaused,\n\t\talpha,\n\t\titeration,\n\t\tprogress,\n\t\tfps\n\t} = animationState;\n\n\tconst isAnimating = isRunning && !isPaused;\n\n\t// Create layout management functions with mock implementations\n\t// These functions expect different parameters than the unified worker provides\n\tconst applyLayout = () => {\n\t\tlogger.debug(\"graph\", \"Apply layout called but not implemented\");\n\t};\n\tconst stopLayout = () => {\n\t\tvoid stopAnimation();\n\t};\n\tconst pauseLayout = () => {\n\t\tvoid pauseAnimation();\n\t};\n\tconst resumeLayout = () => {\n\t\tvoid resumeAnimation();\n\t};\n\tconst reheatLayout = () => {\n\t\tlogger.debug(\"graph\", \"Reheat layout called but not implemented\");\n\t};\n\tconst updateParameters = (params: unknown) => {\n\t\tlogger.debug(\"graph\", \"Update parameters called\", { params });\n\t};\n\tconst restartLayout = () => {\n\t\tlogger.debug(\"graph\", \"Restart layout called but not implemented\");\n\t};\n\tconst canRestart = isIdle;\n\n\t// Auto-start animation when significant node changes occur\n\tuseEffect(() => {\n\t\tif (!autoStartOnNodeChange || !enabled || !useAnimation || !isWorkerReady) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst checkNodeChanges = () => {\n\t\t\tconst currentNodes = getNodes();\n\t\t\tconst currentEdges = getEdges();\n\t\t\tconst currentNodeCount = currentNodes.length;\n\t\t\tconst currentEdgeCount = currentEdges.length;\n\n\t\t\tconst nodeChange = currentNodeCount - prevNodeCountRef.current;\n\t\t\tconst edgeChange = currentEdgeCount - prevEdgeCountRef.current;\n\n\t\t\tlogger.debug(\"graph\", \"Auto-trigger: checking node/edge changes\", {\n\t\t\t\tprevNodeCount: prevNodeCountRef.current,\n\t\t\t\tcurrentNodeCount,\n\t\t\t\tnodeChange,\n\t\t\t\tprevEdgeCount: prevEdgeCountRef.current,\n\t\t\t\tcurrentEdgeCount,\n\t\t\t\tedgeChange,\n\t\t\t\tisRunning,\n\t\t\t});\n\n\t\t\t// Trigger if any node/edge changes occurred (including removals)\n\t\t\tif (nodeChange !== 0 || edgeChange !== 0) {\n\t\t\t\tlogger.debug(\"graph\", \"Auto-trigger: node/edge changes detected\", {\n\t\t\t\t\tnodeChange,\n\t\t\t\t\tedgeChange,\n\t\t\t\t\taction: isRunning ? \"reheat\" : \"start\",\n\t\t\t\t});\n\n\t\t\t\tif (isRunning) {\n\t\t\t\t\t// If simulation is already running, reheat it (reset alpha)\n\t\t\t\t\treheatLayout();\n\t\t\t\t} else {\n\t\t\t\t\t// If simulation is not running, start it\n\t\t\t\t\tapplyLayout();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update previous counts\n\t\t\tprevNodeCountRef.current = currentNodeCount;\n\t\t\tprevEdgeCountRef.current = currentEdgeCount;\n\t\t};\n\n\t\t// Debounce the check to avoid too frequent triggers\n\t\tif (autoTriggerTimeoutRef.current) {\n\t\t\tclearTimeout(autoTriggerTimeoutRef.current);\n\t\t}\n\n\t\tautoTriggerTimeoutRef.current = setTimeout(checkNodeChanges, 500);\n\n\t\treturn () => {\n\t\t\tif (autoTriggerTimeoutRef.current) {\n\t\t\t\tclearTimeout(autoTriggerTimeoutRef.current);\n\t\t\t}\n\t\t};\n\t}, [\n\t\tautoStartOnNodeChange,\n\t\tenabled,\n\t\tuseAnimation,\n\t\tisWorkerReady,\n\t\tisRunning,\n\t\tgetNodes,\n\t\tgetEdges,\n\t\tapplyLayout,\n\t\treheatLayout,\n\t]);\n\n\t// Listen for restart requests from components outside this provider\n\tuseEffect(() => {\n\t\tif (restartRequested && enabled && useAnimation && isWorkerReady) {\n\t\t\tlogger.debug(\"graph\", \"Restart request received from external component\", {\n\t\t\t\tenabled,\n\t\t\t\tuseAnimation,\n\t\t\t\tisWorkerReady,\n\t\t\t\tisRunning,\n\t\t\t});\n\n\t\t\t// Clear the request flag first to prevent multiple triggers\n\t\t\tclearRestartRequest();\n\n\t\t\tif (isRunning) {\n\t\t\t\treheatLayout();\n\t\t\t} else {\n\t\t\t\trestartLayout();\n\t\t\t}\n\t\t}\n\t}, [restartRequested, enabled, useAnimation, isWorkerReady, isRunning, restartLayout, reheatLayout, clearRestartRequest]);\n\n\t// Listen for graph events for immediate auto-trigger\n\tuseEffect(() => {\n\t\tif (!autoStartOnNodeChange || !enabled || !useAnimation || !isWorkerReady) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst handleGraphEvent = (event: { type: string; payload?: unknown }) => {\n\t\t\tconst { type: eventType } = event;\n\n\t\t\t// Only trigger on significant node/edge addition events\n\t\t\tif (\n\t\t\t\teventType === \"graph:bulk-nodes-added\" ||\n\t\t\t\teventType === \"graph:bulk-edges-added\" ||\n\t\t\t\t(eventType === \"graph:node-added\" && Math.random() < 0.1) // Throttle single node additions\n\t\t\t) {\n\t\t\t\tlogger.debug(\"graph\", \"Auto-trigger: graph event received\", {\n\t\t\t\t\teventType,\n\t\t\t\t\taction: isRunning ? \"reheat\" : \"start\",\n\t\t\t\t});\n\n\t\t\t\t// Small delay to allow ReactFlow to update\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (isRunning) {\n\t\t\t\t\t\treheatLayout();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapplyLayout();\n\t\t\t\t\t}\n\t\t\t\t}, 100);\n\t\t\t}\n\t\t};\n\n\t\tconst eventType = \"graph:auto-trigger\";\n\t\t// Use unified event bus for custom event types\n\t\tconst handler = (event: { payload?: unknown }) => {\n\t\t\tif (event.payload && typeof event.payload === \"object\" && \"type\" in event.payload) {\n\t\t\t\tif (typeof event.payload.type === \"string\") {\n\t\t\t\t\thandleGraphEvent({\n\t\t\t\t\t\ttype: event.payload.type,\n\t\t\t\t\t\tpayload: \"payload\" in event.payload ? event.payload.payload : undefined\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst listenerId = eventBus.on(eventType, handler);\n\n\t\treturn () => {\n\t\t\teventBus.off(eventType, handler);\n\t\t};\n\t}, [autoStartOnNodeChange, enabled, useAnimation, isWorkerReady, isRunning, applyLayout, reheatLayout, eventBus]);\n\t// Initial trigger: DISABLED - causing restart loops\n\t// Manual animation start via Start button is preferred\n\t// useEffect(() => {\n\t// \tif (!enabled || !useAnimation || !isWorkerReady || isRunning) {\n\t// \t\treturn;\n\t// \t}\n\n\t// \tconst currentNodes = getNodes();\n\n\t// \t// Start animation if we have nodes but animation isn't running\n\t// \tif (currentNodes.length > 0) {\n\t// \t\tsetTimeout(() => {\n\t// \t\t\tapplyLayout();\n\t// \t\t}, 500); // Small delay to ensure everything is ready\n\t// \t}\n\t// }, [enabled, useAnimation, isWorkerReady, isRunning, getNodes, applyLayout]);\n\n\t// Separate handler for bulk expansion events (independent of autoStartOnNodeChange)\n\tuseEffect(() => {\n\t\tif (!enabled || !useAnimation || !isWorkerReady) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst handleExpansionEvent = (event: { type: string; payload?: unknown }) => {\n\t\t\tconst { type: eventType } = event;\n\n\t\t\t// Only respond to bulk expansion events, not individual node/position changes\n\t\t\tif (eventType === \"graph:bulk-nodes-added\" || eventType === \"graph:bulk-edges-added\") {\n\t\t\t\tlogger.debug(\"graph\", \"Bulk expansion detected during simulation\", {\n\t\t\t\t\teventType,\n\t\t\t\t\tisRunning,\n\t\t\t\t\taction: isRunning ? \"reheat\" : \"start\",\n\t\t\t\t});\n\n\t\t\t\t// Small delay to allow ReactFlow to update\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (isRunning) {\n\t\t\t\t\t\t// During simulation: reheat alpha to apply new edge forces\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Reheating simulation for new edges\");\n\t\t\t\t\t\treheatLayout();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not running: start new simulation with expanded graph\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Starting simulation with expanded graph\");\n\t\t\t\t\t\tapplyLayout();\n\t\t\t\t\t}\n\t\t\t\t}, 100);\n\t\t\t}\n\t\t};\n\n\t\t// Listen directly for bulk graph events\n\t\tconst bulkNodesHandler = (event: { payload?: unknown }) => {\n\t\t\thandleExpansionEvent({\n\t\t\t\ttype: \"graph:bulk-nodes-added\",\n\t\t\t\tpayload: event.payload\n\t\t\t});\n\t\t};\n\n\t\tconst bulkEdgesHandler = (event: { payload?: unknown }) => {\n\t\t\thandleExpansionEvent({\n\t\t\t\ttype: \"graph:bulk-edges-added\",\n\t\t\t\tpayload: event.payload\n\t\t\t});\n\t\t};\n\n\t\tconst bulkNodesListenerId = eventBus.on(\"graph:bulk-nodes-added\", bulkNodesHandler);\n\t\tconst bulkEdgesListenerId = eventBus.on(\"graph:bulk-edges-added\", bulkEdgesHandler);\n\n\t\treturn () => {\n\t\t\teventBus.off(\"graph:bulk-nodes-added\", bulkNodesHandler);\n\t\t\teventBus.off(\"graph:bulk-edges-added\", bulkEdgesHandler);\n\t\t};\n\t}, [enabled, useAnimation, isWorkerReady, isRunning, applyLayout, reheatLayout, eventBus]);\n\n\t// No listener here - moved to GraphNavigation for store access\n\n\t// Create stable context value to prevent unnecessary re-renders\n\tconst contextValue = useMemo(() => ({\n\t\t// State\n\t\tisAnimating,\n\t\tisRunning,\n\t\tisWorkerReady,\n\t\tisPaused,\n\t\tprogress,\n\t\talpha,\n\t\titeration,\n\t\tfps,\n\t\tperformanceStats: {\n\t\t\taverageFPS: fps || 0,\n\t\t\tminFPS: fps || 0,\n\t\t\tmaxFPS: fps || 0,\n\t\t\tframeCount: iteration || 0,\n\t\t},\n\t\tuseAnimation,\n\n\t\t// Actions\n\t\tapplyLayout,\n\t\trestartLayout,\n\t\tstopLayout,\n\t\tpauseLayout,\n\t\tresumeLayout,\n\t\treheatLayout,\n\t\tupdateParameters,\n\n\t\t// Computed properties\n\t\tcanPause,\n\t\tcanResume,\n\t\tcanStop,\n\t\tcanRestart,\n\t}), [\n\t\tisAnimating,\n\t\tisRunning,\n\t\tisWorkerReady,\n\t\tisPaused,\n\t\tprogress,\n\t\talpha,\n\t\titeration,\n\t\tfps,\n\t\tuseAnimation,\n\t\tapplyLayout,\n\t\trestartLayout,\n\t\tstopLayout,\n\t\tpauseLayout,\n\t\tresumeLayout,\n\t\treheatLayout,\n\t\tupdateParameters,\n\t\tcanPause,\n\t\tcanResume,\n\t\tcanStop,\n\t\tcanRestart,\n\t]);\n\n\tlogger.debug(\"graph\", \"AnimatedLayoutProvider render\", {\n\t\tenabled,\n\t\tuseAnimation,\n\t\tisWorkerReady,\n\t\tisRunning,\n\t});\n\n\tuseEffect(() => {\n\t\tif (typeof window !== \"undefined\") {\n\t\t\tconst animatedStoreState = useAnimatedGraphStore.getState();\n\t\t\t(window as any).__animatedGraphDebug = {\n\t\t\t\tisRunning,\n\t\t\t\tisAnimating,\n\t\t\t\tisWorkerReady,\n\t\t\t\tuseAnimation,\n\t\t\t\tanimationHistoryLength: animatedStoreState.animationHistory.length,\n\t\t\t\trestartRequested: animatedStoreState.restartRequested,\n\t\t\t};\n\t\t}\n\t}, [isRunning, isAnimating, isWorkerReady, useAnimation]);\n\n\treturn (\n\t\t<AnimatedLayoutContext.Provider value={contextValue}>\n\t\t\t{children}\n\t\t</AnimatedLayoutContext.Provider>\n\t);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/graph/GraphToolbar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":173,"column":46,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":173,"endColumn":48,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5937,5939],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":178,"column":27,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":178,"endColumn":29,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6110,6112],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":189,"column":46,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":189,"endColumn":48,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6447,6449],"text":""},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Graph Toolbar component with graph utilities\n * Provides academic research focused actions for the entire graph\n */\n\nimport React, { useCallback } from \"react\";\nimport { IconScissors, IconTarget, IconGitBranch, IconPin, IconPinnedOff } from \"@tabler/icons-react\";\nimport { useReactFlow } from \"@xyflow/react\";\n\nimport { useGraphUtilities } from \"@/hooks/use-graph-utilities\";\nimport { useGraphData } from \"@/hooks/use-graph-data\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphUtilityResult } from \"@academic-explorer/graph\";\nimport type { GraphNode, GraphEdge } from \"@academic-explorer/graph\";\n\n// Extended result type for graph utility operations\ninterface GraphOperationResult {\n\tnodes: GraphNode[];\n\tedges: GraphEdge[];\n\tremovedCount: number;\n\toperation: string;\n}\n\n// Type guard to check if result has graph operation properties\nfunction isGraphOperationResult(result: unknown): result is GraphOperationResult {\n\treturn (\n\t\ttypeof result === \"object\" &&\n\t\tresult !== null &&\n\t\t\"nodes\" in result &&\n\t\t\"edges\" in result &&\n\t\t\"removedCount\" in result &&\n\t\t\"operation\" in result &&\n\t\tArray.isArray((result as GraphOperationResult).nodes) &&\n\t\tArray.isArray((result as GraphOperationResult).edges) &&\n\t\ttypeof (result as GraphOperationResult).removedCount === \"number\" &&\n\t\ttypeof (result as GraphOperationResult).operation === \"string\"\n\t);\n}\n\n// Type guard for GraphUtilityResult with data property\nfunction hasDataProperty(result: GraphUtilityResult): result is GraphUtilityResult & { data: unknown } {\n\treturn \"data\" in result && result.data != null;\n}\n\ninterface GraphToolbarProps {\n  className?: string;\n}\n\nexport const GraphToolbar: React.FC<GraphToolbarProps> = ({\n\tclassName = \"\"\n}) => {\n\tconst {trimLeafNodes} = useGraphUtilities();\n\tconst {expandNode} = useGraphData();\n\tconst reactFlow = useReactFlow();\n\tconst {getNodes} = reactFlow;\n\tconst {getEdges} = reactFlow;\n\tconst {setNodes} = reactFlow;\n\tconst pinNode = useGraphStore((state) => state.pinNode);\n\tconst clearAllPinnedNodes = useGraphStore((state) => state.clearAllPinnedNodes);\n\t// Use stable selectors to avoid getSnapshot infinite loops (React 19 + Zustand + Immer pattern)\n\tconst pinnedNodes = useGraphStore((state) => state.pinnedNodes);\n\tconst pinnedNodesCount = React.useMemo(() => Object.keys(pinnedNodes).length, [pinnedNodes]);\n\tconst pinnedNodeIds = React.useMemo(() => Object.keys(pinnedNodes), [pinnedNodes]);\n\n\t// Graph utility action\n\tconst handleTrimLeaves = useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Trim leaves action triggered from graph toolbar\");\n\t\ttry {\n\t\t\tconst result = trimLeafNodes();\n\n\t\t\t// Handle direct GraphOperationResult\n\t\t\tif (isGraphOperationResult(result)) {\n\t\t\t\tlogger.debug(\"graph\", \"Trim leaves completed\", {\n\t\t\t\t\tremovedCount: result.removedCount,\n\t\t\t\t\tremainingNodes: result.nodes.length\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle GraphUtilityResult with data property\n\t\t\tif (hasDataProperty(result) && isGraphOperationResult(result.data)) {\n\t\t\t\tconst operationResult = result.data;\n\t\t\t\tlogger.debug(\"graph\", \"Trim leaves completed\", {\n\t\t\t\t\tremovedCount: operationResult.removedCount,\n\t\t\t\t\tremainingNodes: operationResult.nodes.length\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fallback for other result types\n\t\t\tlogger.debug(\"graph\", \"Trim leaves completed with unknown result format\", { result });\n\t\t} catch (error) {\n\t\t\tlogger.error(\"graph\", \"Trim leaves failed\", {\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t});\n\t\t}\n\t}, [trimLeafNodes]);\n\n\t// 1-degree selection action\n\tconst handleSelect1Degree = useCallback(() => {\n\t\tlogger.debug(\"graph\", \"1-degree selection action triggered from graph toolbar\");\n\n\t\tconst currentNodes = getNodes();\n\t\tconst currentEdges = getEdges();\n\n\t\t// Find the currently selected node\n\t\tconst selectedNode = currentNodes.find(node => node.selected);\n\n\t\tif (!selectedNode) {\n\t\t\tlogger.warn(\"graph\", \"No node currently selected for 1-degree selection\");\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Finding 1-degree neighbors\", {\n\t\t\tselectedNodeId: selectedNode.id,\n\t\t\ttotalNodes: currentNodes.length,\n\t\t\ttotalEdges: currentEdges.length\n\t\t});\n\n\t\t// Find all nodes within 1 degree (directly connected) of the selected node\n\t\tconst oneDegreeNodeIds = new Set<string>();\n\t\toneDegreeNodeIds.add(selectedNode.id); // Include the selected node itself\n\n\t\t// Find all edges connected to the selected node\n\t\tcurrentEdges.forEach(edge => {\n\t\t\tif (edge.source === selectedNode.id) {\n\t\t\t\toneDegreeNodeIds.add(edge.target);\n\t\t\t} else if (edge.target === selectedNode.id) {\n\t\t\t\toneDegreeNodeIds.add(edge.source);\n\t\t\t}\n\t\t});\n\n\t\t// Update node selection state\n\t\tconst updatedNodes = currentNodes.map(node => ({\n\t\t\t...node,\n\t\t\tselected: oneDegreeNodeIds.has(node.id)\n\t\t}));\n\n\t\tsetNodes(updatedNodes);\n\n\t\tlogger.debug(\"graph\", \"1-degree selection completed\", {\n\t\t\tselectedNodeId: selectedNode.id,\n\t\t\tneighborCount: oneDegreeNodeIds.size - 1, // Subtract 1 for the original node\n\t\t\ttotalSelected: oneDegreeNodeIds.size,\n\t\t\tselectedNodeIds: Array.from(oneDegreeNodeIds)\n\t\t});\n\t}, [getNodes, getEdges, setNodes]);\n\n\t// Expand selected nodes action\n\tconst handleExpandSelected = useCallback(async () => {\n\t\tlogger.debug(\"graph\", \"Expand selected nodes action triggered from graph toolbar\");\n\n\t\tconst currentNodes = getNodes();\n\n\t\t// Find all currently selected nodes\n\t\tconst selectedNodes = currentNodes.filter(node => node.selected);\n\n\t\tif (selectedNodes.length === 0) {\n\t\t\tlogger.warn(\"graph\", \"No nodes currently selected for expansion\");\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Expanding selected nodes\", {\n\t\t\tselectedCount: selectedNodes.length,\n\t\t\tselectedNodeIds: selectedNodes.map(node => node.id)\n\t\t});\n\n\t\t// Expand each selected node\n\t\tconst expansionPromises = selectedNodes.map(async (node) => {\n\t\t\ttry {\n\t\t\t\t// Extract entity ID from node data for expansion\n\t\t\t\tconst entityId: string = typeof node.data?.[\"entityId\"] === \"string\" ? node.data[\"entityId\"] : node.id;\n\n\t\t\t\tlogger.debug(\"graph\", \"Expanding node\", {\n\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\tentityId,\n\t\t\t\t\tentityType: node.data?.[\"entityType\"]\n\t\t\t\t});\n\n\t\t\t\tawait expandNode(entityId, {\n\t\t\t\t\tdepth: 1, // Expand 1 level\n\t\t\t\t\tlimit: 10, // Limit connections per node\n\t\t\t\t\tforce: true // Force fresh expansion with new citation fields\n\t\t\t\t});\n\n\t\t\t\treturn { nodeId: node.id, entityId, success: true };\n\t\t\t} catch (error) {\n\t\t\t\tconst entityId: string = typeof node.data?.[\"entityId\"] === \"string\" ? node.data[\"entityId\"] : node.id;\n\t\t\t\tlogger.error(\"graph\", \"Failed to expand node\", {\n\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\tentityId,\n\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t});\n\t\t\t\treturn {\n\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\tentityId,\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tconst results = await Promise.allSettled(expansionPromises);\n\t\t\tconst successful = results.filter(result => result.status === \"fulfilled\" && result.value.success).length;\n\t\t\tconst failed = results.length - successful;\n\n\t\t\tlogger.debug(\"graph\", \"Expand selected nodes completed\", {\n\t\t\t\ttotalNodes: selectedNodes.length,\n\t\t\t\tsuccessful,\n\t\t\t\tfailed,\n\t\t\t\tresults: results.map(result =>\n\t\t\t\t\tresult.status === \"fulfilled\" ? result.value : { error: result.reason instanceof Error ? result.reason.message : String(result.reason) }\n\t\t\t\t)\n\t\t\t});\n\n\t\t} catch (error) {\n\t\t\tlogger.error(\"graph\", \"Expand selected nodes failed\", {\n\t\t\t\tselectedCount: selectedNodes.length,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t});\n\t\t}\n\t}, [getNodes, expandNode]);\n\n\t// Pin all nodes action\n\tconst handlePinAll = useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Pin all nodes action triggered from graph toolbar\");\n\n\t\tconst currentNodes = getNodes();\n\n\t\tif (currentNodes.length === 0) {\n\t\t\tlogger.warn(\"graph\", \"No nodes available to pin\");\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Pinning all nodes\", {\n\t\t\tnodeCount: currentNodes.length,\n\t\t\tnodeIds: currentNodes.map(node => node.id)\n\t\t});\n\n\t\t// Pin each node using the store function\n\t\tcurrentNodes.forEach(node => {\n\t\t\tpinNode(node.id);\n\t\t});\n\n\t\tlogger.debug(\"graph\", \"Pin all nodes completed\", {\n\t\t\ttotalNodes: currentNodes.length,\n\t\t\tpinnedCount: pinnedNodesCount\n\t\t});\n\t}, [getNodes, pinNode, pinnedNodesCount]);\n\n\t// Unpin all nodes action\n\tconst handleUnpinAll = useCallback(() => {\n\t\tlogger.debug(\"graph\", \"Unpin all nodes action triggered from graph toolbar\");\n\n\t\tconst currentPinnedCount = pinnedNodesCount;\n\n\t\tif (currentPinnedCount === 0) {\n\t\t\tlogger.warn(\"graph\", \"No nodes currently pinned to unpin\");\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Unpinning all nodes\", {\n\t\t\tpinnedCount: currentPinnedCount,\n\t\t\tpinnedNodeIds\n\t\t});\n\n\t\t// Clear all pinned nodes using the store function\n\t\tclearAllPinnedNodes();\n\n\t\tlogger.debug(\"graph\", \"Unpin all nodes completed\", {\n\t\t\tpreviouslyPinnedCount: currentPinnedCount,\n\t\t\tcurrentPinnedCount: 0\n\t\t});\n\t}, [pinnedNodesCount, pinnedNodeIds, clearAllPinnedNodes]);\n\n\treturn (\n\t\t<div className={`flex gap-2 p-3 bg-white/95 backdrop-blur-sm border border-gray-200 rounded-lg shadow-lg ${className}`}>\n\t\t\t<button\n\t\t\t\tonClick={handleTrimLeaves}\n\t\t\t\tclassName=\"flex items-center gap-2 px-3 py-2 text-sm bg-red-50 hover:bg-red-100 text-red-700 rounded transition-colors\"\n\t\t\t\ttitle=\"Trim Leaf Nodes - Remove papers with no citations\"\n\t\t\t>\n\t\t\t\t<IconScissors size={16} />\n\t\t\t\t<span>Trim Leaves</span>\n\t\t\t</button>\n\n\t\t\t<button\n\t\t\t\tonClick={handleSelect1Degree}\n\t\t\t\tclassName=\"flex items-center gap-2 px-3 py-2 text-sm bg-blue-50 hover:bg-blue-100 text-blue-700 rounded transition-colors\"\n\t\t\t\ttitle=\"Select 1-Degree - Select all nodes directly connected to the selected node\"\n\t\t\t>\n\t\t\t\t<IconTarget size={16} />\n\t\t\t\t<span>Select 1-Degree</span>\n\t\t\t</button>\n\n\t\t\t<button\n\t\t\t\tonClick={() => {\n\t\t\t\t\thandleExpandSelected().catch((error: unknown) => {\n\t\t\t\t\t\tlogger.error(\"graph\", \"Unhandled error in expand selected\", {\n\t\t\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}}\n\t\t\t\tclassName=\"flex items-center gap-2 px-3 py-2 text-sm bg-green-50 hover:bg-green-100 text-green-700 rounded transition-colors\"\n\t\t\t\ttitle=\"Expand Selected - Load connections for all selected nodes\"\n\t\t\t>\n\t\t\t\t<IconGitBranch size={16} />\n\t\t\t\t<span>Expand Selected</span>\n\t\t\t</button>\n\n\t\t\t<button\n\t\t\t\tonClick={handlePinAll}\n\t\t\t\tclassName=\"flex items-center gap-2 px-3 py-2 text-sm bg-purple-50 hover:bg-purple-100 text-purple-700 rounded transition-colors\"\n\t\t\t\ttitle=\"Pin All - Pin all nodes to prevent them from moving during layout\"\n\t\t\t>\n\t\t\t\t<IconPin size={16} />\n\t\t\t\t<span>Pin All</span>\n\t\t\t</button>\n\n\t\t\t<button\n\t\t\t\tonClick={handleUnpinAll}\n\t\t\t\tclassName=\"flex items-center gap-2 px-3 py-2 text-sm bg-orange-50 hover:bg-orange-100 text-orange-700 rounded transition-colors\"\n\t\t\t\ttitle=\"Unpin All - Unpin all nodes to allow them to move during layout\"\n\t\t\t>\n\t\t\t\t<IconPinnedOff size={16} />\n\t\t\t\t<span>Unpin All</span>\n\t\t\t</button>\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/graph/animated-layout-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/DynamicSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/GraphNavigation.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2228,2231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2228,2231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphStoreAddEdges on an `any` value.","line":62,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":62,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2371,2374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2371,2374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphStoreAddEdges on an `any` value.","line":67,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":67,"endColumn":47},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2778,2781],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2778,2781],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":117,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":117,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .onNodePositionsChanged on an `any` value.","line":117,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":117,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4307,4310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4307,4310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":152,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":152,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .onNodePositionsChanged on an `any` value.","line":152,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":152,"endColumn":46},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":287,"column":2,"nodeType":"MemberExpression","messageId":"unexpected","endLine":287,"endColumn":13,"suggestions":[{"fix":{"range":[9898,9951],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":314,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10515,10518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10515,10518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphAutoStartDebug on an `any` value.","line":314,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":314,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":321,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10725,10728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10725,10728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphRequestSimulationRestart on an `any` value.","line":321,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":321,"endColumn":50},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":332,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":332,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11008,11011],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11008,11011],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphRequestSimulationRestart on an `any` value.","line":332,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":332,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":364,"column":10,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":364,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":365,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":365,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .setEvents on an `any` value.","line":365,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":365,"endColumn":30},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":373,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":373,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[12249,12251],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":387,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":387,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `Function` typed value.","line":388,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":388,"endColumn":27},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":401,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":401,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[13210,13212],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":407,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":407,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `Function` typed value.","line":408,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":408,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":412,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":412,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `Function` typed value.","line":413,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":413,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":423,"column":7,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":423,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `Function` typed value.","line":424,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":424,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":434,"column":8,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":434,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `Function` typed value.","line":435,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":435,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":461,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":461,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15906,15909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15906,15909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphVisibleEdges on an `any` value.","line":461,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":461,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":504,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":504,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .setNodes on an `any` value.","line":504,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":504,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":505,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":505,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .setEdges on an `any` value.","line":505,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":505,"endColumn":33},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":509,"column":6,"nodeType":"MemberExpression","messageId":"unexpected","endLine":509,"endColumn":17,"suggestions":[{"fix":{"range":[18198,18427],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":529,"column":6,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":529,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .addNodes on an `any` value.","line":529,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":529,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":540,"column":6,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":540,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .removeNodes on an `any` value.","line":540,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":540,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":554,"column":6,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":554,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .removeNodes on an `any` value.","line":554,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":554,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":558,"column":6,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":558,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .removeEdges on an `any` value.","line":558,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":558,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":565,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":565,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":565,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":565,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .getXYFlowData on an `any` value.","line":565,"column":68,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":565,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":570,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":570,"endColumn":100},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":570,"column":35,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":570,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .getXYFlowDataForNodes on an `any` value.","line":570,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":570,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":571,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":571,"endColumn":100},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":571,"column":35,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":571,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .getXYFlowDataForEdges on an `any` value.","line":571,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":571,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":572,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":572,"endColumn":108},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":572,"column":39,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":572,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .getXYFlowDataForNodes on an `any` value.","line":572,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":572,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of type `any[]` to a variable of type `NodeChange<Node>[]`.","line":575,"column":11,"nodeType":"VariableDeclarator","messageId":"unsafeAssignment","endLine":586,"endColumn":6},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe spread of an `any` value in an array.","line":577,"column":6,"nodeType":"SpreadElement","messageId":"unsafeArraySpread","endLine":577,"endColumn":92},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":577,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":577,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .map on an `any` value.","line":577,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":577,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe spread of an `any` value in an array.","line":579,"column":6,"nodeType":"SpreadElement","messageId":"unsafeArraySpread","endLine":583,"endColumn":9},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":579,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":579,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .map on an `any` value.","line":579,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":579,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of type `any[]` to a variable of type `EdgeChange<Edge>[]`.","line":588,"column":11,"nodeType":"VariableDeclarator","messageId":"unsafeAssignment","endLine":593,"endColumn":6},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe spread of an `any` value in an array.","line":590,"column":6,"nodeType":"SpreadElement","messageId":"unsafeArraySpread","endLine":590,"endColumn":92},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":590,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":590,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .map on an `any` value.","line":590,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":590,"endColumn":23},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, comparison is always true, since `\"add\" === \"add\"` is true.","line":609,"column":42,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":609,"endColumn":63},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, comparison is always true, since `\"add\" === \"add\"` is true.","line":618,"column":42,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":618,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":637,"column":10,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":637,"endColumn":82},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":637,"column":47,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":637,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .getXYFlowData on an `any` value.","line":637,"column":67,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":637,"endColumn":80},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'isWorkerReady' and 'useAnimation'. Either include them or remove the dependency array.","line":665,"column":5,"nodeType":"ArrayExpression","endLine":665,"endColumn":133,"suggestions":[{"desc":"Update the dependencies array to be: [rawNodesMap, rawEdgesMap, visibleEntityTypes, visibleEdgeTypes, setNodes, setEdges, storeNodes, storeEdges, forceUpdateCounter, isWorkerReady, useAnimation]","fix":{"range":[24288,24416],"text":"[rawNodesMap, rawEdgesMap, visibleEntityTypes, visibleEdgeTypes, setNodes, setEdges, storeNodes, storeEdges, forceUpdateCounter, isWorkerReady, useAnimation]"}}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":856,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":856,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .handleNodeClick on an `any` value.","line":856,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":856,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":863,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":863,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .handleNodeDoubleClick on an `any` value.","line":863,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":863,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":870,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":870,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .handleNodeHover on an `any` value.","line":870,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":870,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":877,"column":4,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":877,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .handleNodeHover on an `any` value.","line":877,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":877,"endColumn":39},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":894,"column":46,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":894,"endColumn":59},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":918,"column":8,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":918,"endColumn":17},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":956,"column":48,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":956,"endColumn":62},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":979,"column":48,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":979,"endColumn":62},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":1001,"column":48,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":1001,"endColumn":62},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":1127,"column":3,"nodeType":"JSXOpeningElement","endLine":1133,"endColumn":4},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":1154,"column":35,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1154,"endColumn":37,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[40301,40303],"text":""},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":76,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Main graph navigation component\n * Provider-agnostic graph visualization with XYFlow implementation\n */\n\nimport React, { useEffect, useRef, useCallback } from \"react\";\nimport {\n\tReactFlow,\n\tReactFlowProvider,\n\tuseReactFlow,\n\tuseNodesState,\n\tuseEdgesState,\n\tapplyNodeChanges,\n\tapplyEdgeChanges,\n\tControls,\n\tMiniMap,\n\tBackground,\n\tBackgroundVariant,\n\tPanel,\n\ttype Node as XYNode,\n\ttype Edge as XYEdge,\n\ttype NodeChange,\n\ttype EdgeChange,\n} from \"@xyflow/react\";\nimport { IconSearch } from \"@tabler/icons-react\";\n\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { createGraphProvider } from \"@academic-explorer/graph\";\nimport { useAnimatedLayoutContext } from \"@/components/graph/animated-layout-context\";\nimport { AnimatedLayoutProvider } from \"@/components/graph/AnimatedLayoutProvider\";\nimport { useAnimatedGraphStore } from \"@/stores/animated-graph-store\";\nimport { createAutoSimulationManager, type AutoSimulationState } from \"@academic-explorer/simulation\";\nimport type { GraphNode, GraphEdge, EntityType, ExternalIdentifier } from \"@academic-explorer/graph\";\nimport { EntityDetector } from \"@academic-explorer/graph\";\nimport { useEntityInteraction } from \"@/hooks/use-entity-interaction\";\nimport { useContextMenu } from \"@/hooks/use-context-menu\";\nimport { NodeContextMenu } from \"@/components/layout/NodeContextMenu\";\nimport { GraphToolbar } from \"@/components/graph/GraphToolbar\";\nimport { AnimatedGraphControls } from \"@/components/graph/AnimatedGraphControls\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { useEventBus } from \"@academic-explorer/graph\";\nimport { WorkerEventType } from \"@academic-explorer/graph\";\nimport { FIT_VIEW_PRESETS } from \"@academic-explorer/graph\";\nimport { z } from \"zod\";\n\nimport \"@xyflow/react/dist/style.css\";\n\ninterface GraphNavigationProps {\n  className?: string;\n  style?: React.CSSProperties;\n}\n\n// Inner component that uses ReactFlow hooks\nconst GraphNavigationInner: React.FC<GraphNavigationProps> = ({ className, style }) => {\n\t// Unified event bus for worker communication\n\tconst eventBus = useEventBus();\n\n\tuseEffect(() => {\n\t\tif (typeof window === \"undefined\") return;\n\n\t\t(window as any).__graphStoreAddEdges = (edges: GraphEdge[]) => {\n\t\t\tuseGraphStore.getState().addEdges(edges);\n\t\t};\n\n\t\treturn () => {\n\t\t\tdelete (window as any).__graphStoreAddEdges;\n\t\t};\n\t}, []);\n\n\tconst reactFlowInstance = useReactFlow();\n\tconst containerRef = useRef<HTMLDivElement>(null);\n\tconst contextMenuData = useContextMenu();\n\tconst {contextMenu} = contextMenuData;\n\tconst {showContextMenu} = contextMenuData;\n\tconst {hideContextMenu} = contextMenuData;\n\n\n\t// Store state\n\tconst graphStore = useGraphStore();\n\tconst setProvider = useCallback((provider: any) => {\n\t\tgraphStore.setProvider(provider);\n\t}, [graphStore]);\n\tconst storeNodes = graphStore.nodes;\n\tconst storeEdges = graphStore.edges;\n\tconst {isLoading} = graphStore;\n\tconst {error} = graphStore;\n\tconst {visibleEntityTypes} = graphStore;\n\tconst {visibleEdgeTypes} = graphStore;\n\n\t// Use direct selectors for raw store data to avoid computed array dependencies\n\tconst rawNodesMap = useGraphStore((state) => state.nodes);\n\tconst rawEdgesMap = useGraphStore((state) => state.edges);\n\n\tconst layoutStore = useLayoutStore();\n\tconst setPreviewEntity = useCallback((entityId: string | null) => {\n\t\tlayoutStore.setPreviewEntity(entityId);\n\t}, [layoutStore]);\n\tconst {autoPinOnLayoutStabilization} = layoutStore;\n\n\n\t// XYFlow state - synced with store\n\tconst [nodes, setNodes, onNodesChangeOriginal] = useNodesState<XYNode>([]);\n\tconst initialEdges: XYEdge[] = [];\n\tconst [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n\n\t// Wrapped nodes change handler that also triggers handle recalculation\n\tconst onNodesChange = useCallback((changes: NodeChange<XYNode>[]) => {\n\t\tonNodesChangeOriginal(changes);\n\n\t\t// Check if any change involves position updates (drag, layout changes)\n\t\tconst hasPositionChange = changes.some((change: NodeChange<XYNode>) => {\n\t\t\treturn change.type === \"position\" || change.type === \"dimensions\";\n\t\t});\n\n\t\tif (hasPositionChange && providerRef.current) {\n\t\t\tproviderRef.current.onNodePositionsChanged();\n\t\t}\n\t}, [onNodesChangeOriginal]);\n\n\t// Provider instance ref\n\tconst providerRef = useRef<any>(null);\n\n\t// Container dimensions state\n\tconst [containerDimensions, setContainerDimensions] = React.useState<{ width: number; height: number } | undefined>();\n\n\t// Force update counter to trigger re-renders when provider data changes\n\tconst [forceUpdateCounter, setForceUpdateCounter] = React.useState(0);\n\n\t// Track previous node/edge IDs to detect changes\n\tconst previousNodeIdsRef = useRef<Set<string>>(new Set());\n\tconst previousEdgeIdsRef = useRef<Set<string>>(new Set());\n\n\t// Flag to prevent handling hashchange events when we programmatically push state\n\tconst isProgrammaticNavigationRef = useRef(false);\n\n\t// Flag to disable layout during incremental updates\n\n\t// Layout hook integration - throttled to reduce log spam\n\tconst lastLogRef = useRef<number>(0);\n\tconst onLayoutChange = useCallback(() => {\n\t\t// Layout positions have changed, re-sync if needed\n\t\tconst now = Date.now();\n\t\t// Only log every 500ms to reduce spam\n\t\tif (now - lastLogRef.current > 500) {\n\t\t\tlogger.debug(\"graph\", \"Layout positions updated\", undefined, \"GraphNavigation\");\n\t\t\tlastLogRef.current = now;\n\t\t}\n\n\t\t// Notify provider to recalculate edge handles based on new positions\n\t\tif (providerRef.current) {\n\t\t\tproviderRef.current.onNodePositionsChanged();\n\t\t}\n\t}, []);\n\n\t// Center the viewport on a node without moving the node's position\n\tconst lastCenterOperationRef = useRef<{ nodeId: string; timestamp: number }>({ nodeId: \"\", timestamp: 0 });\n\n\tconst centerOnNode = useCallback((nodeId: string, currentPosition?: { x: number; y: number }) => {\n\t\t// Throttle centering operations to prevent spam\n\t\tconst now = Date.now();\n\t\tif (lastCenterOperationRef.current.nodeId === nodeId &&\n\t\t    (now - lastCenterOperationRef.current.timestamp) < 500) {\n\t\t\treturn; // Skip if same node centered within last 500ms\n\t\t}\n\n\t\tlet targetX: number;\n\t\tlet targetY: number;\n\n\t\tif (currentPosition) {\n\t\t\t// Use provided position\n\t\t\ttargetX = currentPosition.x;\n\t\t\ttargetY = currentPosition.y;\n\t\t} else {\n\t\t\t// Fallback to searching for the node\n\t\t\tconst currentNodes = reactFlowInstance.getNodes();\n\t\t\tconst targetNode = currentNodes.find(n => n.id === nodeId);\n\n\t\t\tif (!targetNode) {\n\t\t\t\tlogger.debug(\"ui\", \"Cannot center node - node not found\", { nodeId }, \"GraphNavigation\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttargetX = targetNode.position.x;\n\t\t\ttargetY = targetNode.position.y;\n\t\t}\n\n\t\t// Center the viewport on the node's current position without moving the node\n\t\tvoid reactFlowInstance.setCenter(targetX, targetY, {\n\t\t\tzoom: reactFlowInstance.getZoom(),\n\t\t\tduration: 400 // Reduced duration to prevent conflicts\n\t\t});\n\n\t\t// Update throttling tracker\n\t\tlastCenterOperationRef.current = { nodeId, timestamp: now };\n\n\t\tlogger.debug(\"ui\", \"Centered viewport on node at its current position\", {\n\t\t\tnodeId,\n\t\t\tnodePosition: { x: targetX, y: targetY }\n\t\t}, \"GraphNavigation\");\n\t}, [reactFlowInstance]);\n\n\t// Use shared entity interaction logic with centerOnNode function\n\tconst entityInteraction = useEntityInteraction(centerOnNode);\n\tconst baseHandleGraphNodeClick = entityInteraction.handleGraphNodeClick;\n\tconst {handleGraphNodeDoubleClick} = entityInteraction;\n\n\t// Custom graph node single click handler that includes URL hash updates\n\tconst handleGraphNodeClick = useCallback(async (node: GraphNode) => {\n\t\t// Use shared entity interaction logic for single click (no expansion)\n\t\tawait baseHandleGraphNodeClick(node);\n\n\t\t// Handle URL hash update locally (not in shared hook)\n\t\tconst cleanId = EntityDetector.extractOpenAlexId(node.entityId);\n\t\tconst newHashPath = `#/${node.type}/${cleanId}`;\n\n\t\t// Set programmatic navigation flag to prevent hashchange handler loops\n\t\tisProgrammaticNavigationRef.current = true;\n\t\twindow.history.pushState(null, \"\", newHashPath);\n\n\t\tsetTimeout(() => {\n\t\t\tisProgrammaticNavigationRef.current = false;\n\t\t}, 10);\n\n\t\tlogger.debug(\"graph\", \"Node single click completed - no expansion\", {\n\t\t\tnodeId: node.id,\n\t\t\tentityId: node.entityId,\n\t\t\ttype: node.type\n\t\t});\n\t}, [baseHandleGraphNodeClick]);\n\n\t// Custom graph node double click handler for expansion\n\tconst handleGraphNodeDoubleClickWithHash = useCallback(async (node: GraphNode) => {\n\t\t// Use shared entity interaction logic for double click (with expansion)\n\t\tawait handleGraphNodeDoubleClick(node);\n\n\t\t// Handle URL hash update locally (not in shared hook)\n\t\tconst cleanId = EntityDetector.extractOpenAlexId(node.entityId);\n\t\tconst newHashPath = `#/${node.type}/${cleanId}`;\n\n\t\t// Set programmatic navigation flag to prevent hashchange handler loops\n\t\tisProgrammaticNavigationRef.current = true;\n\t\twindow.history.pushState(null, \"\", newHashPath);\n\n\t\tsetTimeout(() => {\n\t\t\tisProgrammaticNavigationRef.current = false;\n\t\t}, 10);\n\n\t\tlogger.debug(\"graph\", \"Node double click completed - expanded\", {\n\t\t\tnodeId: node.id,\n\t\t\tentityId: node.entityId,\n\t\t\ttype: node.type\n\t\t});\n\t}, [handleGraphNodeDoubleClick]);\n\n\t// Get animation state and functions from context\n\tconst {\n\t\tisRunning,\n\t\tisAnimating,\n\t\tisPaused,\n\t\tprogress,\n\t\talpha,\n\t\titeration,\n\t\tfps,\n\t\tperformanceStats,\n\t\tisWorkerReady,\n\t\tuseAnimation,\n\t\trestartLayout,\n\t\tapplyLayout,\n\t\tpauseLayout,\n\t\tresumeLayout,\n\t\tstopLayout,\n\t\treheatLayout,\n\t\tcanPause,\n\t\tcanResume,\n\t\tcanStop,\n\t\tcanRestart\n\t} = useAnimatedLayoutContext();\n\n\t// Ref to capture latest layout functions without adding them to effect dependencies\n\tconst reheatLayoutRef = useRef(reheatLayout);\n\treheatLayoutRef.current = reheatLayout;\n\tconst applyLayoutRef = useRef(applyLayout);\n\tapplyLayoutRef.current = applyLayout;\n\tconst autoSimulationManagerRef = useRef(createAutoSimulationManager());\n\tconst nodeCount = nodes.length;\n\tconsole.log(\"GraphNavigation render\", { nodeCount });\n\n\tuseEffect(() => {\n\t\tconst manager = autoSimulationManagerRef.current;\n\t\tif (nodeCount === 0) {\n\t\t\tmanager.reset();\n\t\t}\n\t\tconst state: AutoSimulationState = {\n\t\t\tnodeCount,\n\t\t\tisWorkerReady,\n\t\t\tuseAnimation,\n\t\t\tisRunning,\n\t\t};\n\n\t\tconst decision = manager.update(state);\n\n\t\tif (decision.shouldRequestRestart) {\n\t\t\tuseAnimatedGraphStore.getState().requestRestart();\n\t\t}\n\t\tif (decision.shouldReheatLayout) {\n\t\t\treheatLayoutRef.current();\n\t\t}\n\t\tif (decision.shouldApplyLayout) {\n\t\t\tapplyLayoutRef.current();\n\t\t}\n\n\t\tif (typeof window !== \"undefined\") {\n\t\t\t(window as any).__graphAutoStartDebug = manager.getDebugState(state, decision);\n\t\t}\n\t}, [nodeCount, isWorkerReady, isRunning, useAnimation]);\n\n\tuseEffect(() => {\n\t\tif (typeof window === \"undefined\") return;\n\n\t\t(window as any).__graphRequestSimulationRestart = () => {\n\t\t\tconst animatedStore = useAnimatedGraphStore.getState();\n\t\t\tanimatedStore.requestRestart();\n\t\t\tif (isRunning) {\n\t\t\t\treheatLayoutRef.current();\n\t\t\t} else {\n\t\t\t\tapplyLayoutRef.current();\n\t\t\t}\n\t\t};\n\n\t\treturn () => {\n\t\t\tdelete (window as any).__graphRequestSimulationRestart;\n\t\t};\n\t}, [isRunning]);\n\n\t// Note: No longer using batched reheat - direct link updates are handled by updateSimulationLinks\n\n\t// Measure container dimensions\n\tuseEffect(() => {\n\t\tif (!containerRef.current) return;\n\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst { width, height } = entry.contentRect;\n\t\t\t\tsetContainerDimensions({ width, height });\n\t\t\t\tlogger.debug(\"graph\", \"Container dimensions updated\", { width, height }, \"GraphNavigation\");\n\t\t\t}\n\t\t});\n\n\t\tresizeObserver.observe(containerRef.current);\n\n\t\treturn () => {\n\t\t\tresizeObserver.disconnect();\n\t\t};\n\t}, []);\n\n\t// Initialize provider\n\tuseEffect(() => {\n\t\tif (!containerRef.current) return;\n\n\t\t// Only create a new provider if we don't have one yet\n\t\tif (providerRef.current) {\n\t\t\t// Update existing provider with new event handlers\n\t\t\tconst existingProvider = providerRef.current;\n\t\t\texistingProvider.setEvents({\n\t\t\t\tonNodeClick: (node: GraphNode) => {\n\t\t\t\t\tvoid handleGraphNodeClick(node);\n\t\t\t\t},\n\t\t\t\tonNodeDoubleClick: (node: GraphNode) => {\n\t\t\t\t\tvoid handleGraphNodeDoubleClickWithHash(node);\n\t\t\t\t},\n\t\t\t\tonNodeHover: (node: GraphNode | null) => {\n\t\t\t\t\tsetPreviewEntity(node?.entityId || null);\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst graphProvider = createGraphProvider(\"xyflow\");\n\t\t// Check that provider was created successfully\n\t\tif (!graphProvider) {\n\t\t\tthrow new Error(\"Failed to create graph provider\");\n\t\t}\n\t\tproviderRef.current = graphProvider;\n\n\t\t// Set up navigation events - check if provider has setEvents method\n\t\tif (graphProvider && typeof graphProvider === 'object' && 'setEvents' in graphProvider && typeof graphProvider.setEvents === 'function') {\n\t\t\tgraphProvider.setEvents({\n\t\t\t\tonNodeClick: (node: GraphNode) => {\n\t\t\t\t\t// Single click: select, pin, center, update preview (no expansion)\n\t\t\t\t\tvoid handleGraphNodeClick(node);\n\t\t\t\t},\n\n\t\t\t\tonNodeDoubleClick: (node: GraphNode) => {\n\t\t\t\t\t// Double click: select, pin, center, update preview AND expand\n\t\t\t\t\tvoid handleGraphNodeDoubleClickWithHash(node);\n\t\t\t\t},\n\n\t\t\t\tonNodeHover: (node: GraphNode | null) => {\n\t\t\t\t\t// Update preview in sidebar\n\t\t\t\t\tsetPreviewEntity(node?.entityId || null);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// Initialize with container - check if provider has initialize method\n\t\tif (graphProvider && typeof graphProvider === 'object' && 'initialize' in graphProvider && typeof graphProvider.initialize === 'function') {\n\t\t\tvoid graphProvider.initialize(containerRef.current);\n\t\t}\n\n\t\t// Set ReactFlow instance - check if provider has setReactFlowInstance method\n\t\tif (graphProvider && typeof graphProvider === 'object' && 'setReactFlowInstance' in graphProvider && typeof graphProvider.setReactFlowInstance === 'function') {\n\t\t\tgraphProvider.setReactFlowInstance(reactFlowInstance);\n\t\t}\n\n\t\t// Set up data change callback to force re-render when provider data changes\n\t\tconst forceUpdateCallback = () => {\n\t\t\t// Force re-read of provider data by updating a state counter\n\t\t\tsetForceUpdateCounter(prev => prev + 1);\n\t\t};\n\n\t\t// Type guard to check if provider has the callback method\n\t\tif (graphProvider && typeof graphProvider === \"object\" && \"setOnDataChangeCallback\" in graphProvider && typeof graphProvider.setOnDataChangeCallback === \"function\") {\n\t\t\tgraphProvider.setOnDataChangeCallback(forceUpdateCallback);\n\t\t}\n\n\t\t// Set the provider in the store (now safe with fixed selectors)\n\t\tconst currentProvider = useGraphStore.getState().provider;\n\t\tif (currentProvider !== graphProvider) {\n\t\t\tsetProvider(graphProvider);\n\t\t}\n\n\t\treturn () => {\n\t\t\tif (graphProvider && typeof graphProvider === 'object' && 'destroy' in graphProvider && typeof graphProvider.destroy === 'function') {\n\t\t\t\tgraphProvider.destroy();\n\t\t\t}\n\t\t};\n\t}, [reactFlowInstance, setPreviewEntity, autoPinOnLayoutStabilization, handleGraphNodeClick, handleGraphNodeDoubleClickWithHash, setProvider]);\n\n\t// Sync store data with XYFlow using incremental updates (applying visibility filters)\n\tuseEffect(() => {\n\t\t// Compute visible nodes and edges inside effect to avoid dependency cycle\n\t\tconst nodesList = Object.values(rawNodesMap).filter((node): node is NonNullable<typeof node> => node != null);\n\t\tconst currentVisibleNodes = nodesList.filter(node => visibleEntityTypes[node.type]);\n\n\t\tconst edgesList = Object.values(rawEdgesMap).filter((edge): edge is NonNullable<typeof edge> => edge != null);\n\t\tconst currentVisibleEdges = edgesList.filter(edge => {\n\t\t\t// Both nodes must exist and be visible\n\t\t\tif (!(edge.source in rawNodesMap) || !(edge.target in rawNodesMap)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst sourceNode = rawNodesMap[edge.source];\n\t\t\tconst targetNode = rawNodesMap[edge.target];\n\t\t\treturn sourceNode && targetNode &&\n\t\t\t\tvisibleEntityTypes[sourceNode.type] &&\n\t\t\t\tvisibleEntityTypes[targetNode.type] &&\n\t\t\t\tvisibleEdgeTypes[edge.type];\n\t\t});\n\n\t\tif (typeof window !== \"undefined\") {\n\t\t\t(window as any).__graphVisibleEdges = currentVisibleEdges.map(edge => ({\n\t\t\t\tid: edge.id,\n\t\t\t\tsource: edge.source,\n\t\t\t\ttarget: edge.target,\n\t\t\t\ttype: edge.type\n\t\t\t}));\n\t\t}\n\n\t\t// Get current node and edge IDs\n\t\tconst currentNodeIds = new Set(currentVisibleNodes.map(n => n.id));\n\t\tconst currentEdgeIds = new Set(currentVisibleEdges.map(e => e.id));\n\n\t\t// Find new nodes and edges\n\t\tconst newNodeIds = new Set([...currentNodeIds].filter(id => !previousNodeIdsRef.current.has(id)));\n\t\tconst newEdgeIds = new Set([...currentEdgeIds].filter(id => !previousEdgeIdsRef.current.has(id)));\n\n\t\t// Find removed nodes and edges\n\t\tconst removedNodeIds = new Set([...previousNodeIdsRef.current].filter(id => !currentNodeIds.has(id)));\n\t\tconst removedEdgeIds = new Set([...previousEdgeIdsRef.current].filter(id => !currentEdgeIds.has(id)));\n\n\t\t// Updated nodes are detected by store changes - we trust the store as source of truth\n\t\t// No need to compare with current XYFlow nodes, just rebuild them from store data\n\t\tconst updatedNodeIds = new Set<string>();\n\n\t\t// Only log when there are actual changes to avoid spam\n\t\tif (newNodeIds.size || newEdgeIds.size || updatedNodeIds.size || removedNodeIds.size || removedEdgeIds.size) {\n\t\t\tlogger.debug(\"graph\", \"Store data incremental sync effect triggered\", {\n\t\t\t\ttotalNodeCount: Object.keys(storeNodes).length,\n\t\t\t\ttotalEdgeCount: Object.keys(storeEdges).length,\n\t\t\t\tvisibleNodeCount: currentVisibleNodes.length,\n\t\t\t\tvisibleEdgeCount: currentVisibleEdges.length,\n\t\t\t\tnewNodes: newNodeIds.size,\n\t\t\t\tnewEdges: newEdgeIds.size,\n\t\t\t\tupdatedNodes: updatedNodeIds.size,\n\t\t\t\tremovedNodes: removedNodeIds.size,\n\t\t\t\tremovedEdges: removedEdgeIds.size,\n\t\t\t\thasProvider: !!providerRef.current\n\t\t\t}, \"GraphNavigation\");\n\t\t}\n\n\t\tif (providerRef.current && (newNodeIds.size || newEdgeIds.size || updatedNodeIds.size || removedNodeIds.size || removedEdgeIds.size)) {\n\t\t\t// Special case: If we have no previous nodes, this is initial load - use setNodes/setEdges\n\t\t\tif (previousNodeIdsRef.current.size === 0 && previousEdgeIdsRef.current.size === 0) {\n\t\t\t\tproviderRef.current.setNodes(currentVisibleNodes);\n\t\t\t\tproviderRef.current.setEdges(currentVisibleEdges);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst animatedStore = useAnimatedGraphStore.getState();\n\t\t\t\t\tanimatedStore.requestRestart();\n\t\t\t\t\tconsole.log(\"Auto-start queue\", {\n\t\t\t\t\t\tnodeCount: currentVisibleNodes.length,\n\t\t\t\t\t\tisWorkerReady,\n\t\t\t\t\t\tuseAnimation,\n\t\t\t\t\t\tanimatedRunning: animatedStore.isAnimating,\n\t\t\t\t\t\tanimatedAnimating: animatedStore.isAnimating\n\t\t\t\t\t});\n\t\t\t\t\tif (isWorkerReady && useAnimation) {\n\t\t\t\t\t\tconst { isAnimating: animatedRunning } = animatedStore;\n\t\t\t\t\t\tif (animatedRunning) {\n\t\t\t\t\t\t\treheatLayoutRef.current();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tapplyLayoutRef.current();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 0);\n\t\t\t} else {\n\t\t\t\t// Use incremental provider methods for updates\n\t\t\t\tif (newNodeIds.size) {\n\t\t\t\t\tconst newNodes = currentVisibleNodes.filter(n => newNodeIds.has(n.id));\n\t\t\t\t\tproviderRef.current.addNodes(newNodes);\n\t\t\t\t}\n\n\t\t\t\tif (newEdgeIds.size) {\n\t\t\t\t\tconst newEdges = currentVisibleEdges.filter(e => newEdgeIds.has(e.id));\n\t\t\t\t\t// Use store to emit events and trigger force simulation updates\n\t\t\t\t\tconst store = useGraphStore.getState();\n\t\t\t\t\tstore.addEdges(newEdges);\n\t\t\t\t}\n\n\t\t\t\tif (removedNodeIds.size) {\n\t\t\t\t\tproviderRef.current.removeNodes(Array.from(removedNodeIds));\n\t\t\t\t}\n\n\t\t\t\t// Note: Node updates will be handled by ReactFlow changes below\n\t\t\t\tif (updatedNodeIds.size) {\n\t\t\t\t\tconst updatedNodes = currentVisibleNodes.filter(n => updatedNodeIds.has(n.id));\n\t\t\t\t\tlogger.debug(\"graph\", \"Detected existing nodes with updated data\", {\n\t\t\t\t\t\tupdatedNodeCount: updatedNodes.length,\n\t\t\t\t\t\tupdatedNodeIds: Array.from(updatedNodeIds),\n\t\t\t\t\t\tupdatedLabels: updatedNodes.map(n => ({ id: n.id, label: n.label }))\n\t\t\t\t\t}, \"GraphNavigation\");\n\t\t\t\t}\n\n\t\t\t\tif (removedNodeIds.size) {\n\t\t\t\t\tproviderRef.current.removeNodes(Array.from(removedNodeIds));\n\t\t\t\t}\n\n\t\t\t\tif (removedEdgeIds.size) {\n\t\t\t\t\tproviderRef.current.removeEdges(Array.from(removedEdgeIds));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle data differently for initial load vs incremental updates\n\t\t\tif (previousNodeIdsRef.current.size === 0 && previousEdgeIdsRef.current.size === 0) {\n\t\t\t\t// Initial load: Get all data and set directly\n\t\t\t\tconst { nodes: xyNodes, edges: xyEdges } = providerRef.current.getXYFlowData();\n\t\t\t\tsetNodes(xyNodes);\n\t\t\t\tsetEdges(xyEdges);\n\t\t\t} else {\n\t\t\t\t// Incremental update: Get only new and updated data and apply changes\n\t\t\t\tconst { nodes: newXYNodes } = providerRef.current.getXYFlowDataForNodes(Array.from(newNodeIds));\n\t\t\t\tconst { edges: newXYEdges } = providerRef.current.getXYFlowDataForEdges(Array.from(newEdgeIds));\n\t\t\t\tconst { nodes: updatedXYNodes } = providerRef.current.getXYFlowDataForNodes(Array.from(updatedNodeIds));\n\n\t\t\t\t// Apply incremental changes using ReactFlow's utilities\n\t\t\t\tconst nodeChanges: NodeChange<XYNode>[] = [\n\t\t\t\t\t// Add new nodes (get fresh data from provider)\n\t\t\t\t\t...newXYNodes.map((node: XYNode): NodeChange<XYNode> => ({ type: \"add\", item: node })),\n\t\t\t\t\t// Update existing nodes with new data\n\t\t\t\t\t...updatedXYNodes.map((node: XYNode): NodeChange<XYNode> => ({\n\t\t\t\t\t\ttype: \"replace\",\n\t\t\t\t\t\tid: node.id,\n\t\t\t\t\t\titem: node\n\t\t\t\t\t})),\n\t\t\t\t\t// Remove deleted nodes\n\t\t\t\t\t...Array.from(removedNodeIds).map((id: string): NodeChange<XYNode> => ({ type: \"remove\", id }))\n\t\t\t\t];\n\n\t\t\t\tconst edgeChanges: EdgeChange<XYEdge>[] = [\n\t\t\t\t\t// Add new edges (get fresh data from provider)\n\t\t\t\t\t...newXYEdges.map((edge: XYEdge): EdgeChange<XYEdge> => ({ type: \"add\", item: edge })),\n\t\t\t\t\t// Remove deleted edges\n\t\t\t\t\t...Array.from(removedEdgeIds).map((id: string): EdgeChange<XYEdge> => ({ type: \"remove\", id }))\n\t\t\t\t];\n\n\t\t\t\t// Apply changes to ReactFlow\n\t\t\t\tif (nodeChanges.length) {\n\t\t\t\t\tsetNodes(prevNodes => applyNodeChanges(nodeChanges, prevNodes));\n\t\t\t\t}\n\n\t\t\t\tif (edgeChanges.length) {\n\t\t\t\t\t// Apply edge changes to XYFlow\n\t\t\t\t\tsetEdges(prevEdges => applyEdgeChanges(edgeChanges, prevEdges));\n\n\t\t\t\t\t// CRITICAL FIX: Trigger force simulation update for direct edge additions\n\t\t\t\t\tconst addedEdges = edgeChanges.filter(change => change.type === \"add\");\n\t\t\t\t\tif (addedEdges.length > 0) {\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Direct edge additions detected, triggering force simulation update\", {\n\t\t\t\t\t\t\taddedEdgesCount: addedEdges.length,\n\t\t\t\t\t\t\tedgeIds: addedEdges.map(change => change.type === \"add\" ? change.item.id : \"unknown\")\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Import localEventBus to emit the proper events for force simulation\n\t\t\t\t\t\timport(\"@academic-explorer/graph\").then(({ localEventBus }) => {\n\t\t\t\t\t\t\tlogger.debug(\"graph\", \"Emitting BULK_EDGES_ADDED event for force simulation\");\n\t\t\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\t\t\ttype: \"BULK_EDGES_ADDED\",\n\t\t\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\t\t\tedges: addedEdges.map(change => change.type === \"add\" ? change.item.id : \"\"),\n\t\t\t\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}).catch((error: unknown) => {\n\t\t\t\t\t\t\tlogger.error(\"graph\", \"Failed to emit BULK_EDGES_ADDED event\", { error });\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", \"Applied incremental XYFlow changes\", {\n\t\t\t\taddedNodes: Array.from(newNodeIds),\n\t\t\t\taddedEdges: Array.from(newEdgeIds),\n\t\t\t\tremovedNodes: Array.from(removedNodeIds),\n\t\t\t\tremovedEdges: Array.from(removedEdgeIds)\n\t\t\t}, \"GraphNavigation\");\n\n\t\t\t// Sync full state to ensure positions are updated in UI\n\t\t\tconst { nodes: xyNodes, edges: xyEdges } = providerRef.current.getXYFlowData();\n\t\t\tsetNodes(xyNodes);\n\t\t\tsetEdges(xyEdges);\n\n\t\t\t// Note: Reheat for new edges is now handled by BULK_EDGES_ADDED event listener in animated layout\n\t\t\t// This prevents double-triggering and ensures proper timing after relationship detection\n\t\t\tif (newNodeIds.size) {\n\t\t\t\tlogger.debug(\"graph\", \"New nodes added to graph\", {\n\t\t\t\t\tnewNodeCount: newNodeIds.size\n\t\t\t\t}, \"GraphNavigation\");\n\t\t\t}\n\t\t}\n\n\t\t// Sync positions from store to XYFlow nodes\n\t\tconst positionChanges: NodeChange<XYNode>[] = currentVisibleNodes.map((node): NodeChange<XYNode> => ({\n\t\t\tid: node.id,\n\t\t\ttype: \"position\" as const,\n\t\t\tposition: node.position,\n\t\t}));\n\n\t\tif (positionChanges.length > 0) {\n\t\t\tsetNodes(nds => applyNodeChanges(positionChanges, nds));\n\t\t\tlogger.debug(\"graph\", \"Synced positions from store to XYFlow\", { syncedCount: positionChanges.length }, \"GraphNavigation\");\n\t\t}\n\n\t\t// Update refs for next comparison\n\t\tpreviousNodeIdsRef.current = currentNodeIds;\n\t\tpreviousEdgeIdsRef.current = currentEdgeIds;\n\t}, [rawNodesMap, rawEdgesMap, visibleEntityTypes, visibleEdgeTypes, setNodes, setEdges, storeNodes, storeEdges, forceUpdateCounter]);\n\n\t// Consolidated listener for worker position updates: apply to both XYFlow and store\n\tuseEffect(() => {\n\t\t// Register listener for worker position updates\n\n\t\tconst handleProgress = (message: unknown) => {\n\t\t\tlogger.debug(\"graph\", \"FORCE_SIMULATION_PROGRESS received\", { message }); // Log payload for validation\n\n\t\t\tif (\n\t\t\t\ttypeof message === \"object\" &&\n\t\t\t\tmessage !== null &&\n\t\t\t\t\"eventType\" in message &&\n\t\t\t\tmessage.eventType === WorkerEventType.FORCE_SIMULATION_PROGRESS &&\n\t\t\t\t\"payload\" in message &&\n\t\t\t\tmessage.payload !== null &&\n\t\t\t\ttypeof message.payload === \"object\" &&\n\t\t\t\t\"messageType\" in message.payload &&\n\t\t\t\tmessage.payload.messageType === \"tick\" &&\n\t\t\t\t\"positions\" in message.payload &&\n\t\t\t\tArray.isArray(message.payload.positions)\n\t\t\t) {\n\t\t\t\tconst {positions} = message.payload;\n\t\t\t\tif (!Array.isArray(positions)) return;\n\t\t\t\tlogger.debug(\"graph\", \"Valid tick payload\", { count: positions.length, sample: positions.slice(0, 3) });\n\n\t\t\t\t// Zod schema for position validation\n\t\t\t\tconst PositionSchema = z.object({\n\t\t\t\t\tid: z.string().min(1),\n\t\t\t\t\tx: z.number(),\n\t\t\t\t\ty: z.number(),\n\t\t\t\t});\n\n\t\t\t\t// Validate positions using zod\n\t\t\t\tconst validPositions = positions.filter((pos) => {\n\t\t\t\t\tconst result = PositionSchema.safeParse(pos);\n\t\t\t\t\treturn result.success;\n\t\t\t\t}).map((pos) => PositionSchema.parse(pos));\n\n\t\t\t\tif (validPositions.length !== positions.length) {\n\t\t\t\t\tlogger.warn(\"graph\", \"Invalid positions filtered\", {\n\t\t\t\t\t\toriginal: positions.length,\n\t\t\t\t\t\tvalid: validPositions.length\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (validPositions.length > 0) {\n\t\t\t\t\t// Update XYFlow nodes\n\t\t\t\t\tconst positionChanges: NodeChange<XYNode>[] = validPositions.map(pos => ({\n\t\t\t\t\t\tid: pos.id,\n\t\t\t\t\t\ttype: \"position\" as const,\n\t\t\t\t\t\tposition: { x: pos.x, y: pos.y },\n\t\t\t\t\t}));\n\n\t\t\t\t\tconst newNodes = applyNodeChanges(positionChanges, nodes);\n\t\t\t\t\tsetNodes(newNodes);\n\t\t\t\t\tlogger.debug(\"graph\", \"Applied position changes to XYFlow\", {\n\t\t\t\t\t\tapplied: positionChanges.length,\n\t\t\t\t\t\tnewNodesLength: newNodes.length\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update graph store\n\t\t\t\t\tconst store = useGraphStore.getState();\n\t\t\t\t\tvalidPositions.forEach((pos) => {\n\t\t\t\t\t\tif (store.nodes[pos.id]) {\n\t\t\t\t\t\t\tstore.updateNode(pos.id, { position: { x: pos.x, y: pos.y } });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tlogger.debug(\"graph\", \"Updated positions in graph store\", { count: validPositions.length });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"graph\", \"Invalid FORCE_SIMULATION_PROGRESS payload\", { message });\n\t\t\t}\n\t\t};\n\n\t\tconst unsubscribe = (eventBus as { on: (type: string, handler: (event: { payload: unknown }) => void) => () => void }).on(WorkerEventType.FORCE_SIMULATION_PROGRESS, (event) => {\n\t\t\thandleProgress(event.payload);\n\t\t});\n\t\tlogger.debug(\"graph\", \"Registered unified FORCE_SIMULATION_PROGRESS handler\");\n\n\t\treturn () => {\n\t\t\tunsubscribe();\n\t\t\tlogger.debug(\"graph\", \"Unregistered FORCE_SIMULATION_PROGRESS handler\");\n\t\t};\n\t}, [setNodes, nodes, eventBus]); // Depend on nodes and eventBus to re-apply if needed\n\n\t// Combined URL state synchronization and browser history navigation\n\tconst lastHashProcessedRef = useRef<string>(\"\");\n\tconst nodeCountRef = useRef<number>(0);\n\n\t// Stable reference to node count to avoid dependency array issues\n\tconst storeNodeCount = Object.keys(storeNodes).length;\n\n\tuseEffect(() => {\n\t\t// Only process when nodes are available and hash has changed\n\t\tconst currentNodeCount = storeNodeCount;\n\t\tconst currentHash = window.location.hash;\n\n\t\t// Skip if no nodes or same hash already processed\n\t\tif (currentNodeCount === 0 || lastHashProcessedRef.current === currentHash) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Skip if this is a programmatic navigation to avoid duplicate processing\n\t\tif (isProgrammaticNavigationRef.current) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst processHashChange = () => {\n\t\t\tif (currentHash && currentHash !== \"#/\") {\n\t\t\t\t// Parse hash (format: \"#/entityType/entityId\")\n\t\t\t\tconst hashPath = currentHash.substring(1); // Remove the '#'\n\t\t\t\tconst pathParts = hashPath.split(\"/\").filter(part => part.length > 0);\n\n\t\t\t\tif (pathParts.length >= 2) {\n\t\t\t\t\tconst [entityType, entityId] = pathParts;\n\n\t\t\t\t\t// Find the corresponding node in the graph\n\t\t\t\t\tconst matchingNode = Object.values(storeNodes).filter((node): node is NonNullable<typeof node> => node != null).find(node => {\n\t\t\t\t\t\tconst cleanNodeId = EntityDetector.extractOpenAlexId(node.entityId);\n\t\t\t\t\t\tconst cleanUrlId = entityId ? EntityDetector.extractOpenAlexId(entityId) : '';\n\t\t\t\t\t\treturn node.type === entityType && cleanNodeId === cleanUrlId;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (matchingNode) {\n\t\t\t\t\t\t// Update selection in store\n\t\t\t\t\t\tconst store = useGraphStore.getState();\n\t\t\t\t\t\tstore.selectNode(matchingNode.id);\n\n\t\t\t\t\t\t// Pin the node to the center of the screen\n\t\t\t\t\t\t// Only clear pinned nodes if auto-pin is disabled\n\t\t\t\t\t\tif (!autoPinOnLayoutStabilization) {\n\t\t\t\t\t\t\tstore.clearAllPinnedNodes(); // Clear previous pinned nodes\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstore.pinNode(matchingNode.id);\n\n\t\t\t\t\t\t// Update preview in sidebar\n\t\t\t\t\t\tsetPreviewEntity(matchingNode.entityId);\n\n\t\t\t\t\t\t// Smoothly animate the selected node to the center of the viewport\n\t\t\t\t\t\tcenterOnNode(matchingNode.id, matchingNode.position);\n\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Selected and auto-centered entity from hash URL\", {\n\t\t\t\t\t\t\tcurrentHash,\n\t\t\t\t\t\t\tentityType,\n\t\t\t\t\t\t\tentityId,\n\t\t\t\t\t\t\tnodeId: matchingNode.id,\n\t\t\t\t\t\t\tnodeEntityId: matchingNode.entityId,\n\t\t\t\t\t\t\tpinned: true\n\t\t\t\t\t\t}, \"GraphNavigation\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No entity in hash or root hash, clear selection only\n\t\t\t\tconst store = useGraphStore.getState();\n\t\t\t\tstore.selectNode(null);\n\t\t\t\tsetPreviewEntity(null);\n\t\t\t}\n\t\t};\n\n\t\t// Only run on initial load or when node count increases (new nodes added)\n\t\tif (nodeCountRef.current === 0 || currentNodeCount > nodeCountRef.current) {\n\t\t\tprocessHashChange();\n\t\t}\n\n\t\tlastHashProcessedRef.current = currentHash;\n\t\tnodeCountRef.current = currentNodeCount;\n\t}, [storeNodeCount, storeNodes, setPreviewEntity, centerOnNode, autoPinOnLayoutStabilization]);\n\n\t// Browser history navigation (back/forward button support for hash routing)\n\tuseEffect(() => {\n\t\tconst handleHashChange = () => {\n\t\t\t// Skip if this is a programmatic navigation to avoid duplicate processing\n\t\t\tif (isProgrammaticNavigationRef.current) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlastHashProcessedRef.current = \"\"; // Reset to force processing\n\t\t};\n\n\t\t// Listen for hash changes (browser back/forward, manual hash changes)\n\t\twindow.addEventListener(\"hashchange\", handleHashChange);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"hashchange\", handleHashChange);\n\t\t};\n\t}, []);\n\n\t// Handle node clicks\n\tconst onNodeClick = useCallback((event: React.MouseEvent, node: XYNode) => {\n\t\tif (providerRef.current) {\n\t\t\tproviderRef.current.handleNodeClick(event, node);\n\t\t}\n\t}, []);\n\n\t// Handle node double clicks\n\tconst onNodeDoubleClick = useCallback((event: React.MouseEvent, node: XYNode) => {\n\t\tif (providerRef.current) {\n\t\t\tproviderRef.current.handleNodeDoubleClick(event, node);\n\t\t}\n\t}, []);\n\n\t// Handle node mouse enter\n\tconst onNodeMouseEnter = useCallback((event: React.MouseEvent, node: XYNode) => {\n\t\tif (providerRef.current) {\n\t\t\tproviderRef.current.handleNodeHover(event, node);\n\t\t}\n\t}, []);\n\n\t// Handle node mouse leave\n\tconst onNodeMouseLeave = useCallback((event: React.MouseEvent) => {\n\t\tif (providerRef.current) {\n\t\t\tproviderRef.current.handleNodeHover(event, null);\n\t\t}\n\t}, []);\n\n\t// Handle node right-click for context menu\n\tconst onNodeContextMenu = useCallback((event: React.MouseEvent, node: XYNode) => {\n\t\tevent.preventDefault();\n\t\tif (providerRef.current) {\n\t\t\t// Type guards for node data properties\n\t\t\tconst isValidString = (value: unknown): value is string =>\n\t\t\t\ttypeof value === \"string\" && value.length > 0;\n\n\t\t\tconst isValidEntityType = (value: unknown): value is EntityType =>\n\t\t\t\ttypeof value === \"string\" &&\n\t\t\t\t[\"works\", \"authors\", \"sources\", \"institutions\", \"topics\", \"concepts\", \"publishers\", \"funders\", \"keywords\"].includes(value);\n\n\t\t\tconst isExternalIdentifier = (item: unknown): item is ExternalIdentifier => {\n\t\t\t\tif (!item || typeof item !== \"object\" || item === null) return false;\n\n\t\t\t\t// Check for required properties using type predicate approach\n\t\t\t\tif (!(\"type\" in item) || !(\"value\" in item) || !(\"url\" in item)) return false;\n\n\t\t\t\t// Type narrowing with safe property access\n\t\t\t\tconst hasRequiredProps = (obj: object): obj is Record<\"type\" | \"value\" | \"url\", unknown> => {\n\t\t\t\t\treturn \"type\" in obj && \"value\" in obj && \"url\" in obj;\n\t\t\t\t};\n\n\t\t\t\tif (!hasRequiredProps(item)) return false;\n\n\t\t\t\tif (typeof item.type !== \"string\" || typeof item.value !== \"string\" || typeof item.url !== \"string\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Validate specific enum values for type\n\t\t\t\treturn [\"doi\", \"orcid\", \"issn_l\", \"ror\", \"wikidata\"].includes(item.type);\n\t\t\t};\n\n\t\t\tconst isValidExternalIds = (value: unknown): value is ExternalIdentifier[] =>\n\t\t\t\tArray.isArray(value) && value.every(isExternalIdentifier);\n\n\t\t\t// Validate all required properties\n\t\t\tif (node.data &&\n\t\t\t    isValidString(node.data['entityId']) &&\n\t\t\t    isValidEntityType(node.data['entityType']) &&\n\t\t\t    isValidString(node.data['label'])) {\n\n\t\t\t\tconst externalIds = isValidExternalIds(node.data['externalIds'])\n\t\t\t\t\t? node.data['externalIds']\n\t\t\t\t\t: [];\n\n\t\t\t\t// Convert XYFlow node back to GraphNode for context menu\n\t\t\t\tconst graphNode: GraphNode = {\n\t\t\t\t\tid: node.id,\n\t\t\t\t\tentityId: node.data['entityId'],\n\t\t\t\t\ttype: node.data['entityType'],\n\t\t\t\t\tlabel: node.data['label'],\n\t\t\t\t\tposition: node.position,\n\t\t\t\t\texternalIds\n\t\t\t\t};\n\t\t\t\tshowContextMenu(graphNode, event);\n\t\t\t}\n\t\t}\n\t}, [showContextMenu]);\n\n\t// Repository drag and drop handlers\n\n\tconst handleDrop = useCallback((event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\n\t\ttry {\n\t\t\tconst transferData = event.dataTransfer.getData(\"application/json\");\n\t\t\tif (!transferData) {\n\t\t\t\tlogger.warn(\"graph\", \"No data in drop event\", {}, \"GraphNavigation\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst parsed: unknown = JSON.parse(transferData);\n\n\t\t\tconst isGraphNode = (value: unknown): value is GraphNode => {\n\t\t\t\tif (!value || typeof value !== \"object\" || value === null) return false;\n\n\t\t\t\tconst requiredProps = [\"id\", \"type\", \"label\", \"entityId\", \"position\", \"externalIds\"];\n\t\t\t\tfor (const prop of requiredProps) {\n\t\t\t\t\tif (!(prop in value)) return false;\n\t\t\t\t}\n\n\t\t\t\t// Type narrowing with safe property access\n\t\t\t\tconst hasGraphNodeProps = (obj: object): obj is Record<\"id\" | \"type\" | \"label\" | \"entityId\" | \"position\" | \"externalIds\", unknown> => {\n\t\t\t\t\treturn \"id\" in obj && \"type\" in obj && \"label\" in obj && \"entityId\" in obj && \"position\" in obj && \"externalIds\" in obj;\n\t\t\t\t};\n\n\t\t\t\tif (!hasGraphNodeProps(value)) return false;\n\n\t\t\t\treturn typeof value.id === \"string\" &&\n\t\t\t\t\ttypeof value.type === \"string\" &&\n\t\t\t\t\ttypeof value.label === \"string\" &&\n\t\t\t\t\ttypeof value.entityId === \"string\" &&\n\t\t\t\t\ttypeof value.position === \"object\" && value.position !== null &&\n\t\t\t\t\tArray.isArray(value.externalIds);\n\t\t\t};\n\n\t\t\tconst isGraphEdge = (value: unknown): value is GraphEdge => {\n\t\t\t\tif (!value || typeof value !== \"object\" || value === null) return false;\n\n\t\t\t\tconst requiredProps = [\"id\", \"source\", \"target\", \"type\"];\n\t\t\t\tfor (const prop of requiredProps) {\n\t\t\t\t\tif (!(prop in value)) return false;\n\t\t\t\t}\n\n\t\t\t\t// Type narrowing with safe property access\n\t\t\t\tconst hasGraphEdgeProps = (obj: object): obj is Record<\"id\" | \"source\" | \"target\" | \"type\", unknown> => {\n\t\t\t\t\treturn \"id\" in obj && \"source\" in obj && \"target\" in obj && \"type\" in obj;\n\t\t\t\t};\n\n\t\t\t\tif (!hasGraphEdgeProps(value)) return false;\n\n\t\t\t\treturn typeof value.id === \"string\" &&\n\t\t\t\t\ttypeof value.source === \"string\" &&\n\t\t\t\t\ttypeof value.target === \"string\" &&\n\t\t\t\t\ttypeof value.type === \"string\";\n\t\t\t};\n\n\t\t\t// Type guard for drop data structure\n\t\t\tconst isValidDropData = (value: unknown): value is { type: string; node?: GraphNode; edge?: GraphEdge } => {\n\t\t\t\tif (!value || typeof value !== \"object\" || value === null) return false;\n\t\t\t\tif (!(\"type\" in value)) return false;\n\n\t\t\t\t// Type narrowing with safe property access\n\t\t\t\tconst hasDropDataProps = (obj: object): obj is Record<\"type\" | \"node\" | \"edge\", unknown> => {\n\t\t\t\t\treturn \"type\" in obj;\n\t\t\t\t};\n\n\t\t\t\tif (!hasDropDataProps(value)) return false;\n\n\t\t\t\tif (typeof value.type !== \"string\") return false;\n\n\t\t\t\t// Check optional node property\n\t\t\t\tif (\"node\" in value && value.node !== undefined && !isGraphNode(value.node)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Check optional edge property\n\t\t\t\tif (\"edge\" in value && value.edge !== undefined && !isGraphEdge(value.edge)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tif (!isValidDropData(parsed)) {\n\t\t\t\tlogger.warn(\"graph\", \"Invalid drop data format\", { data: typeof parsed }, \"GraphNavigation\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst dropData = parsed;\n\t\t\tconst { type } = dropData;\n\n\t\t\tif (type === \"repository-node\" && dropData.node) {\n\t\t\t\tconst {node} = dropData;\n\n\t\t\t\t// Get drop position relative to the flow\n\t\t\t\tconst reactFlowBounds = containerRef.current?.getBoundingClientRect();\n\t\t\t\tif (!reactFlowBounds) {\n\t\t\t\t\tlogger.warn(\"graph\", \"Could not get ReactFlow bounds for drop\", {}, \"GraphNavigation\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst position = reactFlowInstance.screenToFlowPosition({\n\t\t\t\t\tx: event.clientX - reactFlowBounds.left,\n\t\t\t\t\ty: event.clientY - reactFlowBounds.top,\n\t\t\t\t});\n\n\t\t\t\t// Update node position and add to graph\n\t\t\t\tconst updatedNode = {\n\t\t\t\t\t...node,\n\t\t\t\t\tposition\n\t\t\t\t};\n\n\t\t\t\t// Add to main graph\n\t\t\t\tconst store = useGraphStore.getState();\n\t\t\t\tstore.addNodes([updatedNode]);\n\n\t\t\t\tlogger.debug(\"graph\", \"Added repository node to graph via drag-drop\", {\n\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\tnodeType: node.type,\n\t\t\t\t\tposition\n\t\t\t\t});\n\n\t\t\t} else if (type === \"repository-edge\" && dropData.edge) {\n\t\t\t\tconst {edge} = dropData;\n\n\t\t\t\t// Add to main graph\n\t\t\t\tconst store = useGraphStore.getState();\n\t\t\t\tstore.addEdges([edge]);\n\n\t\t\t\tlogger.debug(\"graph\", \"Added repository edge to graph via drag-drop\", {\n\t\t\t\t\tedgeId: edge.id,\n\t\t\t\t\tedgeType: edge.type,\n\t\t\t\t\tsource: edge.source,\n\t\t\t\t\ttarget: edge.target\n\t\t\t\t});\n\t\t\t}\n\n\t\t} catch (error) {\n\t\t\tlogger.error(\"graph\", \"Failed to handle repository drop\", {\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t}, \"GraphNavigation\");\n\t\t}\n\t}, [reactFlowInstance]);\n\n\tconst handleDragOver = useCallback((event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t\tevent.dataTransfer.dropEffect = \"copy\";\n\t}, []);\n\n\t// Loading state - only show full loading screen if there are no existing nodes\n\t// This prevents the loading screen from showing during incremental expansions\n\tif (isLoading && !Object.keys(storeNodes).length) {\n\t\treturn (\n\t\t\t<div className={className} style={{\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tjustifyContent: \"center\",\n\t\t\t\theight: \"100%\",\n\t\t\t\tbackground: \"#f8f9fa\"\n\t\t\t}}>\n\t\t\t\t<div>Loading graph...</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\t// Error state\n\tif (error) {\n\t\tconst errorMessage: string = error;\n\n\t\treturn (\n\t\t\t<div className={className} style={{\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tjustifyContent: \"center\",\n\t\t\t\theight: \"100%\",\n\t\t\t\tbackground: \"#f8f9fa\",\n\t\t\t\tcolor: \"#e74c3c\"\n\t\t\t}}>\n\t\t\t\t<div>Error loading graph: {errorMessage}</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tref={containerRef}\n\t\t\tclassName={className}\n\t\t\tstyle={{ width: \"100%\", height: \"100%\", ...style }}\n\t\t\tonDrop={handleDrop}\n\t\t\tonDragOver={handleDragOver}\n\t\t>\n\t\t\t<ReactFlow\n\t\t\t\tnodes={nodes}\n\t\t\t\tedges={edges}\n\t\t\t\tonNodesChange={onNodesChange}\n\t\t\t\tonEdgesChange={onEdgesChange}\n\t\t\t\tonNodeClick={onNodeClick}\n\t\t\t\tonNodeDoubleClick={onNodeDoubleClick}\n\t\t\t\tonNodeMouseEnter={onNodeMouseEnter}\n\t\t\t\tonNodeMouseLeave={onNodeMouseLeave}\n\t\t\t\tonNodeContextMenu={onNodeContextMenu}\n\t\t\t\tnodeTypes={{}}\n\t\t\t\tedgeTypes={{}}\n\t\t\t\televateEdgesOnSelect={true}\n\t\t\t\tfitView\n\t\t\t\tfitViewOptions={FIT_VIEW_PRESETS.DEFAULT}\n\t\t\t\tattributionPosition=\"bottom-left\"\n\t\t\t>\n\t\t\t\t<Controls />\n\t\t\t\t<MiniMap\n\t\t\t\t\tnodeColor={(node) => {\n\t\t\t\t\t\tconst entityType = node.data?.['entityType'];\n\t\t\t\t\t\tswitch (entityType) {\n\t\t\t\t\t\t\tcase \"work\": return \"#e74c3c\";\n\t\t\t\t\t\t\tcase \"author\": return \"#3498db\";\n\t\t\t\t\t\t\tcase \"source\": return \"#2ecc71\";\n\t\t\t\t\t\t\tcase \"institution\": return \"#f39c12\";\n\t\t\t\t\t\t\tdefault: return \"#95a5a6\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\tnodeStrokeWidth={3}\n\t\t\t\t\tzoomable\n\t\t\t\t\tpannable\n\t\t\t\t/>\n\t\t\t\t<Background variant={BackgroundVariant.Dots} gap={12} size={1} />\n\n\t\t\t\t<Panel position=\"top-left\">\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tbackground: \"rgba(255, 255, 255, 0.9)\",\n\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\tfontWeight: \"bold\"\n\t\t\t\t\t}}>\n            Academic Explorer Graph\n\t\t\t\t\t</div>\n\t\t\t\t</Panel>\n\t\t\t\t{nodes.length > 0 && (\n\t\t\t\t\t<Panel position=\"top-right\">\n\t\t\t\t\t\t<GraphToolbar />\n\t\t\t\t\t</Panel>\n\t\t\t\t)}\n\n\t\t\t\t{/* RE-ENABLED with infinite loop fix */}\n\t\t\t\t{nodes.length > 0 && (\n\t\t\t\t\t<Panel position=\"bottom-left\">\n\t\t\t\t\t\t<AnimatedGraphControls\n\t\t\t\t\t\t\tenabled={true}\n\t\t\t\t\t\t\tonLayoutChange={onLayoutChange}\n\t\t\t\t\t\t\tfitViewAfterLayout={true}\n\t\t\t\t\t\t\t{...(containerDimensions && { containerDimensions })}\n\t\t\t\t\t\t\t// Pass animation state and actions from context\n\t\t\t\t\t\t\tisRunning={isRunning}\n\t\t\t\t\t\t\tisAnimating={isAnimating}\n\t\t\t\t\t\t\tisPaused={isPaused}\n\t\t\t\t\t\t\tprogress={progress}\n\t\t\t\t\t\t\talpha={alpha}\n\t\t\t\t\t\t\titeration={iteration}\n\t\t\t\t\t\t\tfps={fps}\n\t\t\t\t\t\t\tperformanceStats={performanceStats}\n\t\t\t\t\t\t\tisWorkerReady={isWorkerReady}\n\t\t\t\t\t\t\tapplyLayout={applyLayout}\n\t\t\t\t\t\t\tstopLayout={stopLayout}\n\t\t\t\t\t\t\tpauseLayout={pauseLayout}\n\t\t\t\t\t\t\tresumeLayout={resumeLayout}\n\t\t\t\t\t\t\trestartLayout={restartLayout}\n\t\t\t\t\t\t\tcanPause={canPause}\n\t\t\t\t\t\t\tcanResume={canResume}\n\t\t\t\t\t\t\tcanStop={canStop}\n\t\t\t\t\t\t\tcanRestart={canRestart}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Panel>\n\t\t\t\t)}\n\n\n\t\t\t\t{nodes.length === 0 && (\n\t\t\t\t\t<Panel position=\"top-right\">\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tbackground: \"rgba(255, 255, 255, 0.9)\",\n\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\tcolor: \"#666\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<div style={{ marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t<IconSearch size={24} />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div>No entities to display</div>\n\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", marginTop: \"4px\" }}>\n                Search for entities or navigate to an entity page to see the graph\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</Panel>\n\t\t\t\t)}\n\t\t\t</ReactFlow>\n\n\t\t\t{/* Data fetching progress indicators */}\n\t\t\t{/* Temporarily disabled to fix infinite loop */}\n\t\t\t{/* <DataFetchingProgress\n\t\t\t\tactiveRequests={activeRequests}\n\t\t\t\tworkerReady={workerReady}\n\t\t\t/> */}\n\n\t\t\t{/* Context menu */}\n\t\t\t{contextMenu.visible && contextMenu.node && (\n\t\t\t\t<NodeContextMenu\n\t\t\t\t\tnode={contextMenu.node}\n\t\t\t\t\tx={contextMenu.x}\n\t\t\t\t\ty={contextMenu.y}\n\t\t\t\t\tonClose={hideContextMenu}\n\t\t\t\t\tonViewDetails={(node) => {\n\t\t\t\t\t\t// Update preview in sidebar when viewing details\n\t\t\t\t\t\tsetPreviewEntity(node.entityId);\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\n// Main component wrapped in ReactFlowProvider and AnimatedLayoutProvider\nexport const GraphNavigation: React.FC<GraphNavigationProps> = (props) => {\n\treturn (\n\t\t<ReactFlowProvider>\n\t\t\t<AnimatedLayoutProvider\n\t\t\t\tenabled={true}\n\t\t\t\tautoStartOnNodeChange={false}\n\t\t\t>\n\t\t\t\t<GraphNavigationInner {...props} />\n\t\t\t</AnimatedLayoutProvider>\n\t\t</ReactFlowProvider>\n\t);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/GroupRibbonButton.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":288,"column":25,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":288,"endColumn":27,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8341,8343],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Group ribbon button component for VSCode-style tool groups\n * Represents a category/group of tools that can be activated\n */\n\nimport React from \"react\";\nimport { ActionIcon, Tooltip, Badge } from \"@mantine/core\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { ToolGroupDefinition } from \"@/stores/group-registry\";\n\ninterface GroupRibbonButtonProps {\n  group: ToolGroupDefinition;\n  isActive?: boolean;\n  badge?: {\n    show: boolean;\n    count?: number;\n    color?: string;\n  };\n  onActivate: (groupId: string) => void;\n  onDrop?: (draggedSectionId: string, targetGroupId: string, event: React.DragEvent) => void;\n  onDragOver?: (event: React.DragEvent) => void;\n  onGroupReorder?: (sourceGroupId: string, targetGroupId: string, insertBefore: boolean, event: React.DragEvent) => void;\n  onDragStart?: (groupId: string) => void;\n  onDragEnd?: () => void;\n  side: \"left\" | \"right\";\n}\n\nexport const GroupRibbonButton: React.FC<GroupRibbonButtonProps> = ({\n\tgroup,\n\tisActive = false,\n\tbadge,\n\tonActivate,\n\tonDrop,\n\tonDragOver,\n\tonGroupReorder,\n\tonDragStart,\n\tonDragEnd,\n\tside,\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\tconst handleClick = () => {\n\t\tlogger.debug(\"ui\", `Group ribbon button clicked for ${group.id}`, {\n\t\t\tgroupId: group.id,\n\t\t\tside\n\t\t});\n\t\tonActivate(group.id);\n\t};\n\n\tconst handleDragStart = (event: React.DragEvent) => {\n\t\t// Ribbon buttons are always for group reordering\n\t\tif (onGroupReorder) {\n\t\t\tlogger.debug(\"ui\", `Starting group reorder drag for group ${group.id}`, {\n\t\t\t\tgroupId: group.id,\n\t\t\t\tside\n\t\t\t});\n\t\t\t// Set data for group reordering\n\t\t\tevent.dataTransfer.setData(\"application/group-reorder\", group.id);\n\t\t\tevent.dataTransfer.setData(\"text/plain\", `group:${group.id}`);\n\t\t\tevent.dataTransfer.effectAllowed = \"move\";\n\n\t\t\t// Add visual feedback for reordering\n\t\t\tif (event.currentTarget instanceof HTMLElement) {\n\t\t\t\tconst target = event.currentTarget;\n\t\t\t\ttarget.style.opacity = \"0.7\";\n\t\t\t\ttarget.style.border = \"2px dashed \" + colors.primary;\n\t\t\t}\n\n\t\t\t// Notify parent component about drag start\n\t\t\tonDragStart?.(group.id);\n\t\t}\n\t};\n\n\tconst handleDragEnd = (event: React.DragEvent) => {\n\t\t// Reset visual feedback\n\t\tif (event.currentTarget instanceof HTMLElement) {\n\t\t\tconst target = event.currentTarget;\n\t\t\ttarget.style.opacity = \"1\";\n\t\t\ttarget.style.border = `1px solid ${colors.border.primary}`;\n\t\t}\n\n\t\t// Notify parent component about drag end\n\t\tonDragEnd?.();\n\t};\n\n\tconst handleDrop = (event: React.DragEvent) => {\n\t\tlogger.debug(\"ui\", `GroupRibbonButton ${group.id} drop event`, {\n\t\t\tgroupId: group.id,\n\t\t\tside,\n\t\t\ttypes: Array.from(event.dataTransfer.types),\n\t\t\thasOnDrop: Boolean(onDrop)\n\t\t});\n\n\t\tif (onDrop) {\n\t\t\tevent.preventDefault();\n\t\t\tconst draggedSectionId = event.dataTransfer.getData(\"text/plain\");\n\n\t\t\tlogger.debug(\"ui\", `Got dragged section ID: ${draggedSectionId}`);\n\n\t\t\t// Reject group-to-group drops - these should only happen via drop zones\n\t\t\tif (draggedSectionId.startsWith(\"group:\")) {\n\t\t\t\tlogger.debug(\"ui\", `Rejecting group drop onto ribbon button`, {\n\t\t\t\t\tdraggedSectionId,\n\t\t\t\t\ttargetGroupId: group.id,\n\t\t\t\t\tside\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate that we have a valid section ID and target group\n\t\t\tif (!draggedSectionId || !group.id) {\n\t\t\t\tlogger.warn(\"ui\", `Invalid drop data`, {\n\t\t\t\t\tdraggedSectionId,\n\t\t\t\t\ttargetGroupId: group.id,\n\t\t\t\t\tside\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(\"ui\", `Dropping section ${draggedSectionId} onto existing group ${group.id}`, {\n\t\t\t\tdraggedSectionId,\n\t\t\t\ttargetGroupId: group.id,\n\t\t\t\tside,\n\t\t\t\tgroupExists: true // This is an existing group from the ribbon\n\t\t\t});\n\n\t\t\tonDrop(draggedSectionId, group.id, event);\n\t\t} else {\n\t\t\tlogger.warn(\"ui\", `No onDrop handler for ribbon button ${group.id}`);\n\t\t}\n\t};\n\n\tconst handleDragOver = (event: React.DragEvent) => {\n\t\t// Reject group reorder drags on ribbon buttons - they should only use drop zones\n\t\tconst groupReorderData = event.dataTransfer.types.includes(\"application/group-reorder\");\n\n\t\tlogger.debug(\"ui\", `GroupRibbonButton ${group.id} dragover`, {\n\t\t\tgroupId: group.id,\n\t\t\tside,\n\t\t\ttypes: Array.from(event.dataTransfer.types),\n\t\t\tisGroupReorder: groupReorderData,\n\t\t\thasOnDragOver: Boolean(onDragOver)\n\t\t});\n\n\t\tif (groupReorderData) {\n\t\t\t// Don't prevent default - reject the drop\n\t\t\tlogger.debug(\"ui\", `Rejecting group reorder drag on ribbon button ${group.id}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Allow tool/section drags onto ribbon buttons\n\t\tif (onDragOver) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.dataTransfer.dropEffect = \"move\";\n\t\t\tlogger.debug(\"ui\", `Allowing tool drag over ribbon button ${group.id}`);\n\t\t\tonDragOver(event);\n\t\t} else {\n\t\t\tlogger.warn(\"ui\", `No onDragOver handler for ribbon button ${group.id}`);\n\t\t}\n\t};\n\n\tconst handleDragEnter = (event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\n\t\t// Don't highlight for group reorder drags - they should only use drop zones\n\t\tconst groupReorderData = event.dataTransfer.types.includes(\"application/group-reorder\");\n\n\t\tlogger.debug(\"ui\", `GroupRibbonButton ${group.id} dragenter`, {\n\t\t\tgroupId: group.id,\n\t\t\tside,\n\t\t\ttypes: Array.from(event.dataTransfer.types),\n\t\t\tisGroupReorder: groupReorderData\n\t\t});\n\n\t\tif (groupReorderData) {\n\t\t\tlogger.debug(\"ui\", `Ignoring dragenter for group reorder on ribbon button ${group.id}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Add visual feedback for valid drop zone (tools only)\n\t\tif (event.currentTarget instanceof HTMLElement) {\n\t\t\tconst target = event.currentTarget;\n\t\t\ttarget.style.backgroundColor = colors.primary;\n\t\t\ttarget.style.borderColor = colors.primary;\n\t\t\ttarget.style.transform = \"scale(1.05)\";\n\t\t}\n\n\t\tlogger.debug(\"ui\", `Applied highlight to ribbon button ${group.id} for tool drag`);\n\t};\n\n\tconst handleDragLeave = (event: React.DragEvent) => {\n\t\t// Don't process drag leave for group reorder drags - they don't get highlighted anyway\n\t\tconst groupReorderData = event.dataTransfer.types.includes(\"application/group-reorder\");\n\n\t\tlogger.debug(\"ui\", `GroupRibbonButton ${group.id} dragleave`, {\n\t\t\tgroupId: group.id,\n\t\t\tside,\n\t\t\ttypes: Array.from(event.dataTransfer.types),\n\t\t\tisGroupReorder: groupReorderData\n\t\t});\n\n\t\tif (groupReorderData) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only remove highlight if leaving the element entirely\n\t\tif (event.currentTarget instanceof HTMLElement) {\n\t\t\tconst target = event.currentTarget;\n\t\t\tconst rect = target.getBoundingClientRect();\n\t\t\tconst x = event.clientX;\n\t\t\tconst y = event.clientY;\n\n\t\t\tif (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n\t\t\t\ttarget.style.backgroundColor = isActive ? colors.primary : \"transparent\";\n\t\t\t\ttarget.style.borderColor = colors.border.primary;\n\t\t\t\ttarget.style.transform = \"scale(1)\";\n\n\t\t\t\tlogger.debug(\"ui\", `Removed highlight from ribbon button ${group.id}`);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst ribbonButtonStyle = {\n\t\twidth: \"40px\",\n\t\theight: \"40px\",\n\t\tborderRadius: \"8px\",\n\t\tbackgroundColor: \"transparent\",\n\t\tborderWidth: \"1px\",\n\t\tborderStyle: \"solid\",\n\t\tborderColor: colors.border.primary,\n\t\ttransition: \"all 0.2s ease\",\n\t};\n\n\tconst ribbonButtonHoverStyle = {\n\t\tbackgroundColor: colors.background.tertiary,\n\t\tborderColor: colors.primary,\n\t};\n\n\tconst activeButtonStyle = {\n\t\tbackgroundColor: colors.primary,\n\t\tborderColor: colors.primary,\n\t\tcolor: colors.text.inverse,\n\t};\n\n\tconst Icon = group.icon;\n\n\treturn (\n\t\t<div style={{ position: \"relative\" }}>\n\t\t\t<Tooltip\n\t\t\t\tlabel={group.description}\n\t\t\t\tposition={side === \"left\" ? \"right\" : \"left\"}\n\t\t\t\twithArrow\n\t\t\t>\n\t\t\t\t<ActionIcon\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tsize=\"lg\"\n\t\t\t\t\tstyle={isActive ? { ...ribbonButtonStyle, ...activeButtonStyle } : ribbonButtonStyle}\n\t\t\t\t\tonClick={handleClick}\n\t\t\t\t\taria-label={group.description}\n\t\t\t\t\tdraggable={true}\n\t\t\t\t\tonDragStart={handleDragStart}\n\t\t\t\t\tonDragEnd={handleDragEnd}\n\t\t\t\t\tonDrop={handleDrop}\n\t\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\t\tonDragEnter={handleDragEnter}\n\t\t\t\t\tonDragLeave={handleDragLeave}\n\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\tif (!isActive) {\n\t\t\t\t\t\t\tObject.assign(e.currentTarget.style, ribbonButtonHoverStyle);\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\tif (!isActive) {\n\t\t\t\t\t\t\tObject.assign(e.currentTarget.style, ribbonButtonStyle);\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<Icon size={20} />\n\t\t\t\t</ActionIcon>\n\t\t\t</Tooltip>\n\n\t\t\t{badge?.show && (\n\t\t\t\t<Badge\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"filled\"\n\t\t\t\t\tcolor={badge.color || \"blue\"}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: badge.count ? \"-8px\" : \"-4px\",\n\t\t\t\t\t\tright: badge.count ? \"-8px\" : \"-4px\",\n\t\t\t\t\t\tminWidth: badge.count ? \"16px\" : \"8px\",\n\t\t\t\t\t\theight: badge.count ? \"16px\" : \"8px\",\n\t\t\t\t\t\tpadding: badge.count ? undefined : 0,\n\t\t\t\t\t\tborderRadius: badge.count ? undefined : \"50%\",\n\t\t\t\t\t\tfontSize: badge.count ? \"9px\" : undefined,\n\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\tjustifyContent: \"center\",\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{badge.count && (badge.count > 99 ? \"99+\" : badge.count)}\n\t\t\t\t</Badge>\n\t\t\t)}\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/LeftRibbon.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":42,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":42,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1952,1954],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":42,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":42,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1971,1973],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":102,"column":91,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":102,"endColumn":93,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4003,4005],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":181,"column":4,"nodeType":"JSXOpeningElement","endLine":257,"endColumn":6},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":386,"column":3,"nodeType":"JSXOpeningElement","endLine":398,"endColumn":4}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Left ribbon component for collapsed left sidebar\n * Shows icon-only navigation with tool groups using VSCode-style groups\n */\n\nimport React, { useMemo } from \"react\";\nimport { ActionIcon, Tooltip } from \"@mantine/core\";\nimport { useGraphData } from \"@/hooks/use-graph-data\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { getGroupDefinition, createNewGroup, updateGroupDefinition, getRegistryVersion } from \"@/stores/group-registry\";\nimport { getSectionById } from \"@/stores/section-registry\";\nimport { GroupRibbonButton } from \"@/components/layout/GroupRibbonButton\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { IconTrash } from \"@tabler/icons-react\";\n\nexport const LeftRibbon: React.FC = () => {\n\tconst graphData = useGraphData();\n\tconst {clearGraph} = graphData;\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\tconst layoutStore = useLayoutStore();\n\t// const expandSidebarToSection = layoutStore.expandSidebarToSection; // Not used in group-based layout\n\tconst {getToolGroupsForSidebar} = layoutStore;\n\tconst {getActiveGroup} = layoutStore;\n\tconst {setActiveGroup} = layoutStore;\n\tconst {addSectionToGroup} = layoutStore;\n\n\t// State for drag and drop visual feedback\n\tconst [isDragging, setIsDragging] = React.useState(false);\n\tconst [draggedGroupId, setDraggedGroupId] = React.useState<string | null>(null);\n\tconst [dropInsertionIndex, setDropInsertionIndex] = React.useState<number | null>(null);\n\n\t// Get tool groups for left sidebar\n\tconst toolGroups = getToolGroupsForSidebar(\"left\");\n\tconst activeGroupId = getActiveGroup(\"left\");\n\tconst registryVersion = getRegistryVersion();\n\tconst groupDefinitions = useMemo(() => {\n\t\tconst definitions = Object.keys(toolGroups)\n\t\t\t.map(groupId => getGroupDefinition(groupId))\n\t\t\t.filter((def): def is NonNullable<typeof def> => def !== undefined)\n\t\t\t.sort((a, b) => (a.order || 999) - (b.order || 999));\n\n\t\tlogger.debug(\"ui\", \"Left ribbon group definitions\", {\n\t\t\ttoolGroups,\n\t\t\tgroupKeys: Object.keys(toolGroups),\n\t\t\tdefinitions: definitions.map(d => ({ id: d.id, title: d.title, order: d.order })),\n\t\t\tactiveGroupId,\n\t\t\tregistryVersion\n\t\t});\n\n\t\treturn definitions;\n\t}, [toolGroups, activeGroupId, registryVersion]);\n\n\tconst handleClearGraph = () => {\n\t\tlogger.debug(\"ui\", \"Clear graph clicked from left ribbon\");\n\t\tclearGraph();\n\t};\n\n\tconst handleGroupActivate = (groupId: string) => {\n\t\tlogger.debug(\"ui\", `Activating group ${groupId} for left sidebar`, { groupId });\n\n\t\t// Check if group exists before activating\n\t\tconst currentToolGroups = getToolGroupsForSidebar(\"left\");\n\t\tconst groupExists = Boolean(currentToolGroups[groupId]);\n\n\t\tlogger.debug(\"ui\", `Group ${groupId} exists: ${groupExists ? \"true\" : \"false\"}`, {\n\t\t\tgroupId,\n\t\t\tgroupExists,\n\t\t\tcurrentGroups: Object.keys(currentToolGroups)\n\t\t});\n\n\t\tif (!groupExists) {\n\t\t\tlogger.warn(\"ui\", `Cannot activate group ${groupId} - it does not exist`, {\n\t\t\t\tgroupId,\n\t\t\t\tavailableGroups: Object.keys(currentToolGroups)\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if this group is already active and sidebar is open - if so, toggle sidebar\n\t\tconst isCurrentlyActive = activeGroupId === groupId;\n\t\tconst isCurrentlyOpen = layoutStore.leftSidebarOpen;\n\n\t\tif (isCurrentlyActive && isCurrentlyOpen) {\n\t\t\tlogger.debug(\"ui\", `Toggling sidebar closed for active group ${groupId}`);\n\t\t\tlayoutStore.setLeftSidebarOpen(false);\n\t\t\treturn;\n\t\t}\n\n\t\t// Activate the group and expand sidebar\n\t\tsetActiveGroup(\"left\", groupId);\n\t\tlayoutStore.setLeftSidebarOpen(true);\n\n\t\tlogger.debug(\"ui\", `Sidebar should now be open for group ${groupId}`);\n\n\t\t// Scroll to top after a brief delay to allow sidebar to expand\n\t\tsetTimeout(() => {\n\t\t\t// Find the left sidebar container and scroll to top\n\t\t\tconst sidebarContainer = document.querySelector('[data-mantine-component=\"AppShell\"] > nav');\n\t\t\tif (sidebarContainer) {\n\t\t\t\tconst scrollableElement = sidebarContainer.querySelector('[style*=\"overflow: auto\"]') || sidebarContainer;\n\t\t\t\tif (scrollableElement instanceof HTMLElement) {\n\t\t\t\t\tscrollableElement.scrollTop = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}, 150); // Small delay to allow expansion animation\n\t};\n\n\tconst handleGroupReorder = (sourceGroupId: string, targetGroupId: string, insertBefore: boolean, _event: React.DragEvent) => {\n\t\tlogger.debug(\"ui\", `LeftRibbon: Reordering group ${sourceGroupId} relative to ${targetGroupId}`, {\n\t\t\tsourceGroupId,\n\t\t\ttargetGroupId,\n\t\t\tinsertBefore,\n\t\t\tside: \"left\",\n\t\t\tcurrentOrder: groupDefinitions.map(g => ({ id: g.id, order: g.order }))\n\t\t});\n\n\t\tlayoutStore.reorderGroups(\"left\", sourceGroupId, targetGroupId, insertBefore);\n\n\t\t// Reset drag state\n\t\tsetIsDragging(false);\n\t\tsetDraggedGroupId(null);\n\t\tsetDropInsertionIndex(null);\n\t};\n\n\tconst handleGroupDragStart = (groupId: string) => {\n\t\tsetIsDragging(true);\n\t\tsetDraggedGroupId(groupId);\n\t\tlogger.debug(\"ui\", `Starting group drag for ${groupId}`, { groupId, side: \"left\" });\n\t};\n\n\tconst handleGroupDragEnd = () => {\n\t\tsetIsDragging(false);\n\t\tsetDraggedGroupId(null);\n\t\tsetDropInsertionIndex(null);\n\t};\n\n\tconst handleDropZoneHover = (insertionIndex: number, hasGroupDrag: boolean = false) => {\n\t\tif (isDragging || hasGroupDrag) {\n\t\t\tsetDropInsertionIndex(insertionIndex);\n\t\t}\n\t};\n\n\tconst handleDropZoneLeave = () => {\n\t\tsetDropInsertionIndex(null);\n\t};\n\n\t// DropZone component for insertion indicators\n\tconst DropZone: React.FC<{ index: number; isActive: boolean }> = ({ index, isActive }) => {\n\t\tconst [hasGroupDrag, setHasGroupDrag] = React.useState(false);\n\n\t\tconst handleDragOver = (e: React.DragEvent) => {\n\t\t\te.preventDefault();\n\n\t\t\t// Check if this is a group reorder drag\n\t\t\tconst isGroupReorder = e.dataTransfer.types.includes(\"application/group-reorder\");\n\n\t\t\tif (isGroupReorder) {\n\t\t\t\tsetHasGroupDrag(true);\n\t\t\t\tlogger.debug(\"ui\", `LeftRibbon DropZone ${String(index)} detected group drag`, {\n\t\t\t\t\tindex,\n\t\t\t\t\thasGroupDrag,\n\t\t\t\t\tisDragging\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thandleDropZoneHover(index, isGroupReorder);\n\t\t};\n\n\t\tconst handleDragLeave = () => {\n\t\t\t// Only reset if we're actually leaving the drop zone\n\t\t\tsetHasGroupDrag(false);\n\t\t\thandleDropZoneLeave();\n\t\t};\n\n\t\t// Show drop zone if there's a local drag OR if this drop zone detects a group drag AND it's active\n\t\tconst shouldShowDropZone = (isDragging || hasGroupDrag) && isActive;\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tstyle={{\n\t\t\t\t\theight: shouldShowDropZone ? \"40px\" : \"0px\",\n\t\t\t\t\twidth: shouldShowDropZone ? \"40px\" : \"40px\",\n\t\t\t\t\tbackgroundColor: shouldShowDropZone ? colors.primary : \"transparent\",\n\t\t\t\t\ttransition: \"all 0.2s ease\",\n\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\tmargin: shouldShowDropZone ? \"2px 0\" : \"0px\",\n\t\t\t\t\topacity: shouldShowDropZone ? 1 : 0,\n\t\t\t\t\tborder: shouldShowDropZone ? `2px solid ${colors.primary}` : \"none\",\n\t\t\t\t\tpointerEvents: \"auto\",\n\t\t\t\t\toverflow: \"hidden\",\n\t\t\t\t\t// Add invisible padding for hit area when collapsed, offset by negative margin\n\t\t\t\t\tpadding: shouldShowDropZone ? \"0\" : \"10px 0\",\n\t\t\t\t\tmarginTop: shouldShowDropZone ? \"2px\" : \"-10px\",\n\t\t\t\t\tmarginBottom: shouldShowDropZone ? \"2px\" : \"-10px\",\n\t\t\t\t}}\n\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\tonDragLeave={handleDragLeave}\n\t\t\t\tonDrop={(e) => {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tlogger.debug(\"ui\", `LeftRibbon drop zone ${String(index)} received drop`, {\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\ttypes: Array.from(e.dataTransfer.types),\n\t\t\t\t\t\tisDragging,\n\t\t\t\t\t\tdraggedGroupId\n\t\t\t\t\t});\n\t\t\t\t\tconst groupReorderData = e.dataTransfer.getData(\"application/group-reorder\");\n\t\t\t\t\tif (groupReorderData) {\n\t\t\t\t\t\tlogger.debug(\"ui\", `Drop zone ${String(index)} processing reorder/move`, {\n\t\t\t\t\t\t\tsourceGroupId: groupReorderData,\n\t\t\t\t\t\t\tinsertionIndex: index,\n\t\t\t\t\t\t\ttotalGroups: groupDefinitions.length,\n\t\t\t\t\t\t\ttargetSidebar: \"left\"\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Check if this group is from the same sidebar (reorder) or different sidebar (move)\n\t\t\t\t\t\tconst leftGroups = getToolGroupsForSidebar(\"left\");\n\t\t\t\t\t\tconst isFromSameSidebar = Boolean(leftGroups[groupReorderData]);\n\n\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// Dropping at the beginning\n\t\t\t\t\t\t\tconst firstGroup = groupDefinitions[0];\n\t\t\t\t\t\t\tif (firstGroup && firstGroup.id !== groupReorderData) {\n\t\t\t\t\t\t\t\tif (isFromSameSidebar) {\n\t\t\t\t\t\t\t\t\thandleGroupReorder(groupReorderData, firstGroup.id, true, e);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"left\", firstGroup.id, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (index === groupDefinitions.length) {\n\t\t\t\t\t\t// Dropping at the end\n\t\t\t\t\t\t\tconst lastGroup = groupDefinitions[groupDefinitions.length - 1];\n\t\t\t\t\t\t\tif (lastGroup && lastGroup.id !== groupReorderData) {\n\t\t\t\t\t\t\t\tif (isFromSameSidebar) {\n\t\t\t\t\t\t\t\t\thandleGroupReorder(groupReorderData, lastGroup.id, false, e);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"left\", lastGroup.id, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (!isFromSameSidebar) {\n\t\t\t\t\t\t\t// Moving from other sidebar to end when no target group\n\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"left\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t// Dropping between groups\n\t\t\t\t\t\t\tconst targetGroup = groupDefinitions[index - 1];\n\t\t\t\t\t\t\tif (targetGroup && targetGroup.id !== groupReorderData) {\n\t\t\t\t\t\t\t\tif (isFromSameSidebar) {\n\t\t\t\t\t\t\t\t\thandleGroupReorder(groupReorderData, targetGroup.id, false, e);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"left\", targetGroup.id, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t/>\n\t\t);\n\t};\n\n\tconst handleDrop = (draggedSectionId: string, targetGroupId: string, _event: React.DragEvent) => {\n\t\tlogger.debug(\"ui\", `LeftRibbon handleDrop: Moving section ${draggedSectionId} to group ${targetGroupId}`, {\n\t\t\tdraggedSectionId,\n\t\t\ttargetGroupId,\n\t\t\tside: \"left\"\n\t\t});\n\n\t\t// First, remove the section from all existing groups on both sides\n\t\tconst leftGroups = getToolGroupsForSidebar(\"left\");\n\t\tconst rightGroups = getToolGroupsForSidebar(\"right\");\n\n\t\tlogger.debug(\"ui\", `Current groups before removal`, {\n\t\t\tleftGroups: Object.keys(leftGroups),\n\t\t\trightGroups: Object.keys(rightGroups),\n\t\t\ttargetGroupExists: targetGroupId in leftGroups,\n\t\t\ttargetGroupSections: leftGroups[targetGroupId]?.sections\n\t\t});\n\n\t\t// Remove from left sidebar groups\n\t\tObject.entries(leftGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlogger.debug(\"ui\", `Removing ${draggedSectionId} from left group ${groupId}`);\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"left\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Remove from right sidebar groups\n\t\tObject.entries(rightGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlogger.debug(\"ui\", `Removing ${draggedSectionId} from right group ${groupId}`);\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"right\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Check if target group exists after removals\n\t\tconst updatedLeftGroups = getToolGroupsForSidebar(\"left\");\n\t\tlogger.debug(\"ui\", `Groups after removal, before addition`, {\n\t\t\tleftGroups: Object.keys(updatedLeftGroups),\n\t\t\ttargetGroupExists: Boolean(updatedLeftGroups[targetGroupId]),\n\t\t\ttargetGroupId\n\t\t});\n\n\t\t// Then add to the target group\n\t\taddSectionToGroup(\"left\", targetGroupId, draggedSectionId);\n\t};\n\n\tconst handleDragOver = (event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t};\n\n\tconst handleEmptyAreaDrop = (event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t// Check if this is a group reorder drag - if so, ignore it\n\t\tconst isGroupReorder = event.dataTransfer.types.includes(\"application/group-reorder\");\n\t\tif (isGroupReorder) {\n\t\t\tlogger.debug(\"ui\", \"Ignoring group reorder drag in empty area\", {\n\t\t\t\ttypes: Array.from(event.dataTransfer.types)\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst draggedSectionId = event.dataTransfer.getData(\"text/plain\");\n\t\tif (!draggedSectionId) {\n\t\t\tlogger.warn(\"ui\", \"No dragged section ID found in dataTransfer\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the tool's category - this will be the group type\n\t\tconst section = getSectionById(draggedSectionId);\n\t\tif (!section?.category) {\n\t\t\tlogger.warn(\"ui\", `Cannot create group for section ${draggedSectionId} - no category`, {\n\t\t\t\tdraggedSectionId,\n\t\t\t\tsection\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a new group with unique ID\n\t\tconst newGroup = createNewGroup(draggedSectionId);\n\t\tconst groupId = newGroup.id;\n\n\t\tlogger.debug(\"ui\", `Creating new group ${groupId} for section ${draggedSectionId} on left ribbon`, {\n\t\t\tdraggedSectionId,\n\t\t\tgroupId,\n\t\t\tcategory: section.category,\n\t\t\tgroupTitle: newGroup.title\n\t\t});\n\n\t\t// First, remove the section from all existing groups\n\t\tconst leftGroups = getToolGroupsForSidebar(\"left\");\n\t\tconst rightGroups = getToolGroupsForSidebar(\"right\");\n\n\t\tObject.entries(leftGroups).forEach(([existingGroupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"left\", existingGroupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\tObject.entries(rightGroups).forEach(([existingGroupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"right\", existingGroupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Add to the new group (will create the group since it's guaranteed to not exist)\n\t\taddSectionToGroup(\"left\", groupId, draggedSectionId);\n\t\tsetActiveGroup(\"left\", groupId);\n\n\t\t// Immediately update the group definition with the section\n\t\tupdateGroupDefinition(groupId, [draggedSectionId], getSectionById);\n\t};\n\n\tconst ribbonButtonStyle = {\n\t\twidth: \"40px\",\n\t\theight: \"40px\",\n\t\tborderRadius: \"8px\",\n\t\tbackgroundColor: \"transparent\",\n\t\tborder: `1px solid ${colors.border.primary}`,\n\t\ttransition: \"all 0.2s ease\",\n\t};\n\n\n\treturn (\n\t\t<div\n\t\t\tonDrop={handleEmptyAreaDrop}\n\t\t\tonDragOver={handleDragOver}\n\t\t\tstyle={{\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\tflexDirection: \"column\",\n\t\t\t\theight: \"100%\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tpadding: \"16px 8px\",\n\t\t\t\tgap: \"12px\",\n\t\t\t\tborderRight: `1px solid ${colors.border.primary}`,\n\t\t\t}}\n\t\t>\n\t\t\t{/* Dynamic tool groups */}\n\t\t\t<div style={{ display: \"flex\", flexDirection: \"column\", alignItems: \"center\", gap: \"4px\" }}>\n\t\t\t\t{groupDefinitions.map((group, index) => (\n\t\t\t\t\t<React.Fragment key={group.id}>\n\t\t\t\t\t\t{/* Drop zone before first item or between items */}\n\t\t\t\t\t\t<DropZone index={index} isActive={dropInsertionIndex === index} />\n\n\t\t\t\t\t\t<GroupRibbonButton\n\t\t\t\t\t\t\tgroup={group}\n\t\t\t\t\t\t\tisActive={activeGroupId === group.id}\n\t\t\t\t\t\t\tonActivate={handleGroupActivate}\n\t\t\t\t\t\t\tonDrop={handleDrop}\n\t\t\t\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\t\t\t\tonGroupReorder={handleGroupReorder}\n\t\t\t\t\t\t\tonDragStart={handleGroupDragStart}\n\t\t\t\t\t\t\tonDragEnd={handleGroupDragEnd}\n\t\t\t\t\t\t\tside=\"left\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</React.Fragment>\n\t\t\t\t))}\n\n\t\t\t\t{/* Drop zone after last item */}\n\t\t\t\t<DropZone\n\t\t\t\t\tindex={groupDefinitions.length}\n\t\t\t\t\tisActive={dropInsertionIndex === groupDefinitions.length}\n\t\t\t\t/>\n\t\t\t</div>\n\n\t\t\t<div style={{ flex: 1 }} />\n\n\t\t\t{/* Clear graph at bottom */}\n\t\t\t<Tooltip label=\"Clear entire graph\" position=\"right\" withArrow>\n\t\t\t\t<ActionIcon\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tsize=\"lg\"\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\t...ribbonButtonStyle,\n\t\t\t\t\t\tborderColor: colors.error,\n\t\t\t\t\t}}\n\t\t\t\t\tonClick={handleClearGraph}\n\t\t\t\t\taria-label=\"Clear entire graph\"\n\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\tObject.assign(e.currentTarget.style, {\n\t\t\t\t\t\t\tbackgroundColor: colors.error,\n\t\t\t\t\t\t\tborderColor: colors.error,\n\t\t\t\t\t\t\tcolor: colors.text.inverse,\n\t\t\t\t\t\t});\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\tObject.assign(e.currentTarget.style, {\n\t\t\t\t\t\t\t...ribbonButtonStyle,\n\t\t\t\t\t\t\tborderColor: colors.error,\n\t\t\t\t\t\t\tcolor: \"inherit\",\n\t\t\t\t\t\t});\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<IconTrash size={20} />\n\t\t\t\t</ActionIcon>\n\t\t\t</Tooltip>\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/LeftSidebarDynamic.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/MainLayout.tsx","messages":[{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":93,"column":4,"nodeType":"JSXOpeningElement","endLine":112,"endColumn":5}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Main layout component integrating graph navigation with sidebars\n * Implementation of the decoupled graph navigation plan architecture\n */\n\nimport React from \"react\";\nimport { AppShell, Group, Text, ActionIcon, useMantineColorScheme } from \"@mantine/core\";\nimport { IconMoon, IconSun, IconDeviceDesktop, IconMenu2, IconX } from \"@tabler/icons-react\";\nimport { Link } from \"@tanstack/react-router\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { GraphNavigation } from \"./GraphNavigation\";\nimport { LeftSidebarDynamic } from \"./LeftSidebarDynamic\";\nimport { RightSidebarDynamic } from \"./RightSidebarDynamic\";\nimport { LeftRibbon } from \"./LeftRibbon\";\nimport { RightRibbon } from \"./RightRibbon\";\nimport { GraphActivityTracker } from \"@/components/activity/GraphActivityTracker\";\n\ninterface MainLayoutProps {\n  children?: React.ReactNode;\n}\n\nexport const MainLayout: React.FC<MainLayoutProps> = ({ children }) => {\n\tconst layoutStore = useLayoutStore();\n\tconst {leftSidebarOpen} = layoutStore;\n\tconst {rightSidebarOpen} = layoutStore;\n\tconst {leftSidebarPinned} = layoutStore;\n\tconst {rightSidebarPinned} = layoutStore;\n\tconst {leftSidebarAutoHidden} = layoutStore;\n\tconst {rightSidebarAutoHidden} = layoutStore;\n\tconst {leftSidebarHovered} = layoutStore;\n\tconst {rightSidebarHovered} = layoutStore;\n\tconst {toggleLeftSidebar} = layoutStore;\n\tconst {toggleRightSidebar} = layoutStore;\n\n\tconst mantineColorScheme = useMantineColorScheme();\n\tconst {colorScheme} = mantineColorScheme;\n\tconst {setColorScheme} = mantineColorScheme;\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Calculate effective visibility for each sidebar\n\tconst leftSidebarEffectivelyVisible = leftSidebarOpen && (!leftSidebarAutoHidden || leftSidebarHovered || leftSidebarPinned);\n\tconst rightSidebarEffectivelyVisible = rightSidebarOpen && (!rightSidebarAutoHidden || rightSidebarHovered || rightSidebarPinned);\n\n\t// Theme toggle logic\n\tconst getSystemTheme = () => {\n\t\treturn window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n\t};\n\n\tconst cycleColorScheme = () => {\n\t\tconst systemTheme = getSystemTheme();\n\t\tconst oppositeSystemTheme = systemTheme === \"dark\" ? \"light\" : \"dark\";\n\n\t\tif (colorScheme === \"auto\") {\n\t\t\tsetColorScheme(oppositeSystemTheme);\n\t\t} else if (colorScheme === oppositeSystemTheme) {\n\t\t\tsetColorScheme(systemTheme);\n\t\t} else {\n\t\t\tsetColorScheme(\"auto\");\n\t\t}\n\t};\n\n\tconst getThemeIcon = () => {\n\t\tif (colorScheme === \"auto\") {\n\t\t\treturn <IconDeviceDesktop size={18} />;\n\t\t} else if (colorScheme === \"dark\") {\n\t\t\treturn <IconMoon size={18} />;\n\t\t} else {\n\t\t\treturn <IconSun size={18} />;\n\t\t}\n\t};\n\n\tconst getAriaLabel = () => {\n\t\tconst systemTheme = getSystemTheme();\n\t\tconst oppositeSystemTheme = systemTheme === \"dark\" ? \"light\" : \"dark\";\n\n\t\tif (colorScheme === \"auto\") {\n\t\t\treturn `Current: Auto (${systemTheme}). Click for ${oppositeSystemTheme} mode`;\n\t\t} else if (colorScheme === oppositeSystemTheme) {\n\t\t\treturn `Current: ${colorScheme === \"light\" ? \"Light\" : \"Dark\"} mode. Click for ${systemTheme} mode`;\n\t\t} else {\n\t\t\treturn `Current: ${colorScheme === \"light\" ? \"Light\" : \"Dark\"} mode. Click for auto mode`;\n\t\t}\n\t};\n\n\treturn (\n\t\t<>\n\t\t\t{/* Graph Activity Tracker - invisible component that tracks graph events */}\n\t\t\t<GraphActivityTracker />\n\n\t\t\t{/* Skip Links for Accessibility */}\n\t\t\t<div\n\t\t\t\tstyle={{\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: \"-40px\",\n\t\t\t\t\tleft: \"6px\",\n\t\t\t\t\tbackground: colors.background.primary,\n\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\tpadding: \"8px\",\n\t\t\t\t\tzIndex: 1000,\n\t\t\t\t\ttextDecoration: \"none\",\n\t\t\t\t\tborder: `1px solid ${colors.border.primary}`,\n\t\t\t\t\tborderRadius: \"4px\"\n\t\t\t\t}}\n\t\t\t\tonFocus={(e) => {\n\t\t\t\t\te.currentTarget.style.top = \"6px\";\n\t\t\t\t}}\n\t\t\t\tonBlur={(e) => {\n\t\t\t\t\te.currentTarget.style.top = \"-40px\";\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<a\n\t\t\t\t\thref=\"#main-navigation\"\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\ttextDecoration: \"none\",\n\t\t\t\t\t\tmarginRight: \"1rem\"\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\tSkip to navigation\n\t\t\t\t</a>\n\t\t\t\t<a\n\t\t\t\t\thref=\"#main-content\"\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\ttextDecoration: \"none\",\n\t\t\t\t\t\tmarginRight: \"1rem\"\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\tSkip to main content\n\t\t\t\t</a>\n\t\t\t\t<a\n\t\t\t\t\thref=\"#left-sidebar\"\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\ttextDecoration: \"none\",\n\t\t\t\t\t\tmarginRight: \"1rem\"\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\tSkip to tools sidebar\n\t\t\t\t</a>\n\t\t\t</div>\n\n\t\t\t<AppShell\n\t\t\t\theader={{ height: 60 }}\n\t\t\t\tnavbar={{\n\t\t\t\t\twidth: leftSidebarEffectivelyVisible ? { base: 340, sm: 360, md: 410 } : 60,\n\t\t\t\t\tcollapsed: { mobile: false }, // Never collapse on mobile since we always show activity bar\n\t\t\t\t\tbreakpoint: \"sm\"\n\t\t\t\t}}\n\t\t\t\taside={{\n\t\t\t\t\twidth: rightSidebarEffectivelyVisible ? { base: 340, sm: 360, md: 410 } : 60,\n\t\t\t\t\tcollapsed: { mobile: false }, // Never collapse on mobile since we always show activity bar\n\t\t\t\t\tbreakpoint: \"sm\"\n\t\t\t\t}}\n\t\t\t\tpadding={0}\n\t\t\t>\n\t\t\t{/* Header */}\n\t\t\t<AppShell.Header>\n\t\t\t\t<Group justify=\"space-between\" h=\"100%\" px=\"md\">\n\t\t\t\t\t<Group>\n\t\t\t\t\t\t{/* Left sidebar toggle */}\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tonClick={toggleLeftSidebar}\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tsize=\"lg\"\n\t\t\t\t\t\t\taria-label={leftSidebarOpen ? \"Hide left sidebar\" : \"Show left sidebar\"}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{leftSidebarOpen ? <IconX size={18} /> : <IconMenu2 size={18} />}\n\t\t\t\t\t\t</ActionIcon>\n\n\t\t\t\t\t\t<Text size=\"xl\" fw={600} c=\"blue\">\n\t\t\t\t\t\t\tAcademic Explorer\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Group gap=\"md\">\n\t\t\t\t\t\t<nav id=\"main-navigation\" style={{ display: \"flex\", gap: \"1rem\", padding: \"0 1rem\" }}>\n\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\tto=\"/\"\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\t\t\t\ttextDecoration: \"none\",\n\t\t\t\t\t\t\t\t\tpadding: \"0.5rem 0.75rem\",\n\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\ttransition: \"all 0.2s ease\",\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = colors.background.tertiary;\n\t\t\t\t\t\t\t\t\te.currentTarget.style.color = colors.primary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = \"transparent\";\n\t\t\t\t\t\t\t\t\te.currentTarget.style.color = colors.text.primary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tHome\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\tto=\"/about\"\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\t\t\t\ttextDecoration: \"none\",\n\t\t\t\t\t\t\t\t\tpadding: \"0.5rem 0.75rem\",\n\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\ttransition: \"all 0.2s ease\",\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = colors.background.tertiary;\n\t\t\t\t\t\t\t\t\te.currentTarget.style.color = colors.primary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = \"transparent\";\n\t\t\t\t\t\t\t\t\te.currentTarget.style.color = colors.text.primary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tAbout\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t\t<Link\n\t\t\t\t\t\t\t\tto=\"/evaluation\"\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\t\t\t\ttextDecoration: \"none\",\n\t\t\t\t\t\t\t\t\tpadding: \"0.5rem 0.75rem\",\n\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\ttransition: \"all 0.2s ease\",\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = colors.background.tertiary;\n\t\t\t\t\t\t\t\t\te.currentTarget.style.color = colors.primary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = \"transparent\";\n\t\t\t\t\t\t\t\t\te.currentTarget.style.color = colors.text.primary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tEvaluation\n\t\t\t\t\t\t\t</Link>\n\t\t\t\t\t\t</nav>\n\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tonClick={cycleColorScheme}\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tsize=\"lg\"\n\t\t\t\t\t\t\taria-label={getAriaLabel()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{getThemeIcon()}\n\t\t\t\t\t\t</ActionIcon>\n\n\t\t\t\t\t\t{/* Right sidebar toggle */}\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tonClick={toggleRightSidebar}\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tsize=\"lg\"\n\t\t\t\t\t\t\taria-label={rightSidebarOpen ? \"Hide right sidebar\" : \"Show right sidebar\"}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{rightSidebarOpen ? <IconX size={18} /> : <IconMenu2 size={18} />}\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Group>\n\t\t\t\t</Group>\n\t\t\t</AppShell.Header>\n\n\t\t\t{/* Left Sidebar - Activity Bar + Content (VSCode-style) */}\n\t\t\t<AppShell.Navbar id=\"left-sidebar\" style={{ display: \"flex\", flexDirection: \"row\", height: \"calc(100vh - 60px)\", maxHeight: \"calc(100vh - 60px)\", overflowY: \"hidden\", overflowX: \"hidden\" }}>\n\t\t\t\t{/* Activity Bar (always visible) */}\n\t\t\t\t<LeftRibbon />\n\t\t\t\t{/* Sidebar content (when expanded) */}\n\t\t\t\t{leftSidebarEffectivelyVisible && (\n\t\t\t\t\t<div style={{ flex: 1, display: \"flex\", flexDirection: \"column\", overflowY: \"auto\", overflowX: \"hidden\" }}>\n\t\t\t\t\t\t<LeftSidebarDynamic />\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</AppShell.Navbar>\n\n\t\t\t{/* Main Graph Area */}\n\t\t\t<AppShell.Main\n\t\t\t\tid=\"main-content\"\n\t\t\t\tstyle={{\n\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\tflexDirection: \"column\",\n\t\t\t\t\theight: \"100%\",\n\t\t\t\t\toverflow: \"hidden\",\n\t\t\t\t\tposition: \"relative\"\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{/* Graph fills the entire main area and resizes with sidebars */}\n\t\t\t\t<GraphNavigation\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tflex: 1,\n\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\theight: \"100%\",\n\t\t\t\t\t\tminHeight: 0 // Important for flex child with overflow\n\t\t\t\t\t}}\n\t\t\t\t/>\n\n\t\t\t\t{/* Route content rendered as overlay if present */}\n\t\t\t\t{children && (\n\t\t\t\t\t<div\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\t\ttop: \"50%\",\n\t\t\t\t\t\t\tleft: \"50%\",\n\t\t\t\t\t\t\ttransform: \"translate(-50%, -50%)\",\n\t\t\t\t\t\t\tzIndex: 100,\n\t\t\t\t\t\t\tmaxWidth: \"90vw\",\n\t\t\t\t\t\t\tmaxHeight: \"90vh\",\n\t\t\t\t\t\t\toverflow: \"auto\",\n\t\t\t\t\t\t\tpointerEvents: \"auto\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</AppShell.Main>\n\n\t\t\t{/* Right Sidebar - Content + Activity Bar (VSCode-style) */}\n\t\t\t<AppShell.Aside style={{ display: \"flex\", flexDirection: \"row\", height: \"calc(100vh - 60px)\", maxHeight: \"calc(100vh - 60px)\", overflowY: \"hidden\", overflowX: \"hidden\" }}>\n\t\t\t\t{/* Sidebar content (when expanded) */}\n\t\t\t\t{rightSidebarEffectivelyVisible && (\n\t\t\t\t\t<div style={{ flex: 1, display: \"flex\", flexDirection: \"column\", overflowY: \"auto\", overflowX: \"hidden\" }}>\n\t\t\t\t\t\t<RightSidebarDynamic />\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t\t{/* Activity Bar (always visible) */}\n\t\t\t\t<RightRibbon />\n\t\t\t</AppShell.Aside>\n\t\t</AppShell>\n\t</>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/NodeContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/RightRibbon.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":52,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":52,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2359,2361],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":52,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":52,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2378,2380],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":66,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":66,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2778,2809],"text":"(hoveredNodeId ?? selectedNodeId)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":66,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":66,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2810,2812],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":91,"column":91,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":91,"endColumn":93,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3876,3878],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":170,"column":4,"nodeType":"JSXOpeningElement","endLine":246,"endColumn":6},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":385,"column":3,"nodeType":"JSXOpeningElement","endLine":397,"endColumn":4}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Right ribbon component for collapsed right sidebar\n * Shows icon-only controls for tool groups using VSCode-style groups\n */\n\nimport React, { useMemo } from \"react\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { getGroupDefinition, createNewGroup, updateGroupDefinition, getRegistryVersion } from \"@/stores/group-registry\";\nimport { getSectionById } from \"@/stores/section-registry\";\nimport { GroupRibbonButton } from \"@/components/layout/GroupRibbonButton\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\nexport const RightRibbon: React.FC = () => {\n\tconst layoutStore = useLayoutStore();\n\tconst {previewEntityId} = layoutStore;\n\t// const expandSidebarToSection = layoutStore.expandSidebarToSection; // Not used in group-based layout\n\tconst {getToolGroupsForSidebar} = layoutStore;\n\tconst {getActiveGroup} = layoutStore;\n\tconst {setActiveGroup} = layoutStore;\n\tconst {addSectionToGroup} = layoutStore;\n\n\t// State for drag and drop visual feedback\n\tconst [isDragging, setIsDragging] = React.useState(false);\n\tconst [draggedGroupId, setDraggedGroupId] = React.useState<string | null>(null);\n\tconst [dropInsertionIndex, setDropInsertionIndex] = React.useState<number | null>(null);\n\tconst selectedNodeId = useGraphStore((state) => state.selectedNodeId);\n\tconst hoveredNodeId = useGraphStore((state) => state.hoveredNodeId);\n\tconst nodesMap = useGraphStore((state) => state.nodes);\n\tconst nodes = useMemo(() => {\n\t\ttry {\n\t\t\t// Safe conversion of object values to array with type checking\n\t\t\tconst nodeValues = Object.values(nodesMap);\n\t\t\treturn Array.isArray(nodeValues) ? nodeValues : [];\n\t\t} catch (error) {\n\t\t\tlogger.warn(\"ui\", \"Failed to convert nodes map to array\", { error });\n\t\t\treturn [];\n\t\t}\n\t}, [nodesMap]);\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Get tool groups for right sidebar\n\tconst toolGroups = getToolGroupsForSidebar(\"right\");\n\tconst activeGroupId = getActiveGroup(\"right\");\n\tconst registryVersion = getRegistryVersion();\n\tconst groupDefinitions = useMemo(() => {\n\t\tconst definitions = Object.keys(toolGroups)\n\t\t\t.map(groupId => getGroupDefinition(groupId))\n\t\t\t.filter((def): def is NonNullable<typeof def> => def !== undefined)\n\t\t\t.sort((a, b) => (a.order || 999) - (b.order || 999));\n\n\t\tlogger.debug(\"ui\", \"Right ribbon group definitions\", {\n\t\t\ttoolGroups,\n\t\t\tgroupKeys: Object.keys(toolGroups),\n\t\t\tdefinitions: definitions.map(d => ({ id: d.id, title: d.title, order: d.order })),\n\t\t\tactiveGroupId,\n\t\t\tregistryVersion\n\t\t});\n\n\t\treturn definitions;\n\t}, [toolGroups, activeGroupId, registryVersion]);\n\n\t// Determine which entity to show indicator for\n\tconst displayEntityId = hoveredNodeId || selectedNodeId || previewEntityId;\n\tconst hasEntity = Boolean(displayEntityId);\n\n\tconst handleGroupActivate = (groupId: string) => {\n\t\tlogger.debug(\"ui\", `Activating group ${groupId} for right sidebar`, { groupId });\n\n\t\t// Check if this group is already active and sidebar is open - if so, toggle sidebar\n\t\tconst isCurrentlyActive = activeGroupId === groupId;\n\t\tconst isCurrentlyOpen = layoutStore.rightSidebarOpen;\n\n\t\tif (isCurrentlyActive && isCurrentlyOpen) {\n\t\t\tlogger.debug(\"ui\", `Toggling sidebar closed for active group ${groupId}`);\n\t\t\tlayoutStore.setRightSidebarOpen(false);\n\t\t\treturn;\n\t\t}\n\n\t\t// Activate the group and expand sidebar\n\t\tsetActiveGroup(\"right\", groupId);\n\t\tlayoutStore.setRightSidebarOpen(true);\n\n\t\t// Scroll to top after a brief delay to allow sidebar to expand\n\t\tsetTimeout(() => {\n\t\t\t// Find the right sidebar container and scroll to top\n\t\t\tconst sidebarContainer = document.querySelector('[data-mantine-component=\"AppShell\"] > aside');\n\t\t\tif (sidebarContainer) {\n\t\t\t\tconst scrollableElement = sidebarContainer.querySelector('[style*=\"overflow: auto\"]') || sidebarContainer;\n\t\t\t\tif (scrollableElement instanceof HTMLElement) {\n\t\t\t\t\tscrollableElement.scrollTop = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}, 150); // Small delay to allow expansion animation\n\t};\n\n\tconst handleGroupReorder = (sourceGroupId: string, targetGroupId: string, insertBefore: boolean, _event: React.DragEvent) => {\n\t\tlogger.debug(\"ui\", `Reordering group ${sourceGroupId} relative to ${targetGroupId}`, {\n\t\t\tsourceGroupId,\n\t\t\ttargetGroupId,\n\t\t\tinsertBefore,\n\t\t\tside: \"right\"\n\t\t});\n\n\t\tlayoutStore.reorderGroups(\"right\", sourceGroupId, targetGroupId, insertBefore);\n\n\t\t// Reset drag state\n\t\tsetIsDragging(false);\n\t\tsetDraggedGroupId(null);\n\t\tsetDropInsertionIndex(null);\n\t};\n\n\tconst handleGroupDragStart = (groupId: string) => {\n\t\tsetIsDragging(true);\n\t\tsetDraggedGroupId(groupId);\n\t\tlogger.debug(\"ui\", `Starting group drag for ${groupId}`, { groupId, side: \"right\" });\n\t};\n\n\tconst handleGroupDragEnd = () => {\n\t\tsetIsDragging(false);\n\t\tsetDraggedGroupId(null);\n\t\tsetDropInsertionIndex(null);\n\t};\n\n\tconst handleDropZoneHover = (insertionIndex: number, hasGroupDrag: boolean = false) => {\n\t\tif (isDragging || hasGroupDrag) {\n\t\t\tsetDropInsertionIndex(insertionIndex);\n\t\t}\n\t};\n\n\tconst handleDropZoneLeave = () => {\n\t\tsetDropInsertionIndex(null);\n\t};\n\n\t// DropZone component for insertion indicators\n\tconst DropZone: React.FC<{ index: number; isActive: boolean }> = ({ index, isActive }) => {\n\t\tconst [hasGroupDrag, setHasGroupDrag] = React.useState(false);\n\n\t\tconst handleDragOver = (e: React.DragEvent) => {\n\t\t\te.preventDefault();\n\n\t\t\t// Check if this is a group reorder drag\n\t\t\tconst isGroupReorder = e.dataTransfer.types.includes(\"application/group-reorder\");\n\n\t\t\tif (isGroupReorder) {\n\t\t\t\tsetHasGroupDrag(true);\n\t\t\t\tlogger.debug(\"ui\", `RightRibbon DropZone ${String(index)} detected group drag`, {\n\t\t\t\t\tindex,\n\t\t\t\t\thasGroupDrag,\n\t\t\t\t\tisDragging\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thandleDropZoneHover(index, isGroupReorder);\n\t\t};\n\n\t\tconst handleDragLeave = () => {\n\t\t\t// Only reset if we're actually leaving the drop zone\n\t\t\tsetHasGroupDrag(false);\n\t\t\thandleDropZoneLeave();\n\t\t};\n\n\t\t// Show drop zone if there's a local drag OR if this drop zone detects a group drag AND it's active\n\t\t// For cross-ribbon drops, we rely on hasGroupDrag since isDragging is local to each ribbon\n\t\tconst shouldShowDropZone = (isDragging || hasGroupDrag) && isActive;\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tstyle={{\n\t\t\t\t\theight: shouldShowDropZone ? \"40px\" : \"0px\",\n\t\t\t\t\twidth: shouldShowDropZone ? \"40px\" : \"40px\",\n\t\t\t\t\tbackgroundColor: shouldShowDropZone ? colors.primary : \"transparent\",\n\t\t\t\t\ttransition: \"all 0.2s ease\",\n\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\tmargin: shouldShowDropZone ? \"2px 0\" : \"0px\",\n\t\t\t\t\topacity: shouldShowDropZone ? 1 : 0,\n\t\t\t\t\tborder: shouldShowDropZone ? `2px solid ${colors.primary}` : \"none\",\n\t\t\t\t\tpointerEvents: \"auto\",\n\t\t\t\t\toverflow: \"hidden\",\n\t\t\t\t\t// Add invisible padding for hit area when collapsed, offset by negative margin\n\t\t\t\t\tpadding: shouldShowDropZone ? \"0\" : \"10px 0\",\n\t\t\t\t\tmarginTop: shouldShowDropZone ? \"2px\" : \"-10px\",\n\t\t\t\t\tmarginBottom: shouldShowDropZone ? \"2px\" : \"-10px\",\n\t\t\t\t}}\n\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\tonDragLeave={handleDragLeave}\n\t\t\t\tonDrop={(e) => {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tlogger.debug(\"ui\", `RightRibbon drop zone ${String(index)} received drop`, {\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\ttypes: Array.from(e.dataTransfer.types),\n\t\t\t\t\t\tisDragging,\n\t\t\t\t\t\tdraggedGroupId\n\t\t\t\t\t});\n\t\t\t\t\tconst groupReorderData = e.dataTransfer.getData(\"application/group-reorder\");\n\t\t\t\t\tif (groupReorderData) {\n\t\t\t\t\t\tlogger.debug(\"ui\", `Drop zone ${String(index)} processing reorder/move`, {\n\t\t\t\t\t\t\tsourceGroupId: groupReorderData,\n\t\t\t\t\t\t\tinsertionIndex: index,\n\t\t\t\t\t\t\ttotalGroups: groupDefinitions.length,\n\t\t\t\t\t\t\ttargetSidebar: \"right\"\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Check if this group is from the same sidebar (reorder) or different sidebar (move)\n\t\t\t\t\t\tconst rightGroups = getToolGroupsForSidebar(\"right\");\n\t\t\t\t\t\tconst isFromSameSidebar = Boolean(rightGroups[groupReorderData]);\n\n\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// Dropping at the beginning\n\t\t\t\t\t\t\tconst firstGroup = groupDefinitions[0];\n\t\t\t\t\t\t\tif (firstGroup && firstGroup.id !== groupReorderData) {\n\t\t\t\t\t\t\t\tif (isFromSameSidebar) {\n\t\t\t\t\t\t\t\t\thandleGroupReorder(groupReorderData, firstGroup.id, true, e);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"right\", firstGroup.id, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (index === groupDefinitions.length) {\n\t\t\t\t\t\t// Dropping at the end\n\t\t\t\t\t\t\tconst lastGroup = groupDefinitions[groupDefinitions.length - 1];\n\t\t\t\t\t\t\tif (lastGroup && lastGroup.id !== groupReorderData) {\n\t\t\t\t\t\t\t\tif (isFromSameSidebar) {\n\t\t\t\t\t\t\t\t\thandleGroupReorder(groupReorderData, lastGroup.id, false, e);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"right\", lastGroup.id, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (!isFromSameSidebar) {\n\t\t\t\t\t\t\t// Moving from other sidebar to end when no target group\n\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"right\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t// Dropping between groups\n\t\t\t\t\t\t\tconst targetGroup = groupDefinitions[index - 1];\n\t\t\t\t\t\t\tif (targetGroup && targetGroup.id !== groupReorderData) {\n\t\t\t\t\t\t\t\tif (isFromSameSidebar) {\n\t\t\t\t\t\t\t\t\thandleGroupReorder(groupReorderData, targetGroup.id, false, e);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlayoutStore.moveGroupToSidebar(groupReorderData, \"right\", targetGroup.id, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t/>\n\t\t);\n\t};\n\n\tconst handleDrop = (draggedSectionId: string, targetGroupId: string, _event: React.DragEvent) => {\n\t\tlogger.debug(\"ui\", `RightRibbon handleDrop: Moving section ${draggedSectionId} to group ${targetGroupId}`, {\n\t\t\tdraggedSectionId,\n\t\t\ttargetGroupId,\n\t\t\tside: \"right\"\n\t\t});\n\n\t\t// First, remove the section from all existing groups on both sides\n\t\tconst leftGroups = getToolGroupsForSidebar(\"left\");\n\t\tconst rightGroups = getToolGroupsForSidebar(\"right\");\n\n\t\tlogger.debug(\"ui\", `Current groups before removal`, {\n\t\t\tleftGroups: Object.keys(leftGroups),\n\t\t\trightGroups: Object.keys(rightGroups),\n\t\t\ttargetGroupExists: targetGroupId in rightGroups,\n\t\t\ttargetGroupSections: rightGroups[targetGroupId]?.sections\n\t\t});\n\n\t\t// Remove from left sidebar groups\n\t\tObject.entries(leftGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlogger.debug(\"ui\", `Removing ${draggedSectionId} from left group ${groupId}`);\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"left\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Remove from right sidebar groups\n\t\tObject.entries(rightGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlogger.debug(\"ui\", `Removing ${draggedSectionId} from right group ${groupId}`);\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"right\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Check if target group exists after removals\n\t\tconst updatedRightGroups = getToolGroupsForSidebar(\"right\");\n\t\tlogger.debug(\"ui\", `Groups after removal, before addition`, {\n\t\t\trightGroups: Object.keys(updatedRightGroups),\n\t\t\ttargetGroupExists: Boolean(updatedRightGroups[targetGroupId]),\n\t\t\ttargetGroupId\n\t\t});\n\n\t\t// Then add to the target group\n\t\taddSectionToGroup(\"right\", targetGroupId, draggedSectionId);\n\t};\n\n\tconst handleDragOver = (event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t};\n\n\tconst handleEmptyAreaDrop = (event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t// Check if this is a group reorder drag - if so, ignore it\n\t\tconst isGroupReorder = event.dataTransfer.types.includes(\"application/group-reorder\");\n\t\tif (isGroupReorder) {\n\t\t\tlogger.debug(\"ui\", \"Ignoring group reorder drag in empty area\", {\n\t\t\t\ttypes: Array.from(event.dataTransfer.types)\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst draggedSectionId = event.dataTransfer.getData(\"text/plain\");\n\t\tif (!draggedSectionId) {\n\t\t\tlogger.warn(\"ui\", \"No dragged section ID found in dataTransfer\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the tool's category - this will be the group type\n\t\tconst section = getSectionById(draggedSectionId);\n\t\tif (!section?.category) {\n\t\t\tlogger.warn(\"ui\", `Cannot create group for section ${draggedSectionId} - no category`, {\n\t\t\t\tdraggedSectionId,\n\t\t\t\tsection\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a new group with unique ID\n\t\tconst newGroup = createNewGroup(draggedSectionId);\n\t\tconst groupId = newGroup.id;\n\n\t\tlogger.debug(\"ui\", `Creating new group ${groupId} for section ${draggedSectionId} on right ribbon`, {\n\t\t\tdraggedSectionId,\n\t\t\tgroupId,\n\t\t\tcategory: section.category,\n\t\t\tgroupTitle: newGroup.title\n\t\t});\n\n\t\t// First, remove the section from all existing groups\n\t\tconst leftGroups = getToolGroupsForSidebar(\"left\");\n\t\tconst rightGroups = getToolGroupsForSidebar(\"right\");\n\n\t\tObject.entries(leftGroups).forEach(([existingGroupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"left\", existingGroupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\tObject.entries(rightGroups).forEach(([existingGroupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tlayoutStore.removeSectionFromGroup(\"right\", existingGroupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Add to the new group (will create the group since it's guaranteed to not exist)\n\t\taddSectionToGroup(\"right\", groupId, draggedSectionId);\n\t\tsetActiveGroup(\"right\", groupId);\n\n\t\t// Immediately update the group definition with the section\n\t\tupdateGroupDefinition(groupId, [draggedSectionId], getSectionById);\n\t};\n\n\t// Helper function to get badge info for groups that need indicators\n\tconst getGroupBadge = (groupId: string) => {\n\t\tswitch (groupId) {\n\t\t\tcase \"entity-details\":\n\t\t\t\treturn {\n\t\t\t\t\tshow: hasEntity,\n\t\t\t\t\tcolor: \"blue\"\n\t\t\t\t};\n\t\t\tcase \"analysis\":\n\t\t\t\treturn {\n\t\t\t\t\tshow: nodes.length > 0,\n\t\t\t\t\tcount: nodes.length,\n\t\t\t\t\tcolor: \"gray\"\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\treturn { show: false };\n\t\t}\n\t};\n\n\n\treturn (\n\t\t<div\n\t\t\tonDrop={handleEmptyAreaDrop}\n\t\t\tonDragOver={handleDragOver}\n\t\t\tstyle={{\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\tflexDirection: \"column\",\n\t\t\t\theight: \"100%\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tpadding: \"16px 8px\",\n\t\t\t\tgap: \"12px\",\n\t\t\t\tborderLeft: `1px solid ${colors.border.primary}`,\n\t\t\t}}\n\t\t>\n\t\t\t{/* Dynamic tool groups */}\n\t\t\t<div style={{ display: \"flex\", flexDirection: \"column\", alignItems: \"center\", gap: \"4px\" }}>\n\t\t\t\t{groupDefinitions.map((group, index) => {\n\t\t\t\t\tconst badge = getGroupBadge(group.id);\n\t\t\t\t\tconst isActive = activeGroupId === group.id;\n\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<React.Fragment key={group.id}>\n\t\t\t\t\t\t\t{/* Drop zone before first item or between items */}\n\t\t\t\t\t\t\t<DropZone index={index} isActive={dropInsertionIndex === index} />\n\n\t\t\t\t\t\t\t<GroupRibbonButton\n\t\t\t\t\t\t\t\tgroup={group}\n\t\t\t\t\t\t\t\tisActive={isActive}\n\t\t\t\t\t\t\t\tbadge={badge}\n\t\t\t\t\t\t\t\tonActivate={handleGroupActivate}\n\t\t\t\t\t\t\t\tonDrop={handleDrop}\n\t\t\t\t\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\t\t\t\t\tonGroupReorder={handleGroupReorder}\n\t\t\t\t\t\t\t\tonDragStart={handleGroupDragStart}\n\t\t\t\t\t\t\t\tonDragEnd={handleGroupDragEnd}\n\t\t\t\t\t\t\t\tside=\"right\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</React.Fragment>\n\t\t\t\t\t);\n\t\t\t\t})}\n\n\t\t\t\t{/* Drop zone after last item */}\n\t\t\t\t<DropZone\n\t\t\t\t\tindex={groupDefinitions.length}\n\t\t\t\t\tisActive={dropInsertionIndex === groupDefinitions.length}\n\t\t\t\t/>\n\t\t\t</div>\n\n\t\t\t<div style={{ flex: 1 }} />\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/RightSidebarDynamic.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/SectionContextMenu.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":69,"column":14,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":69,"endColumn":16,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1679,1681],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Context menu for section management\n * Provides options to move sections between sidebars and reset to defaults\n */\n\nimport React from \"react\";\nimport { Menu, ActionIcon } from \"@mantine/core\";\nimport { IconDots, IconArrowRight, IconArrowLeft, IconRefresh } from \"@tabler/icons-react\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { getSectionById } from \"@/stores/section-registry\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface SectionContextMenuProps {\n  sectionId: string;\n  currentSidebar: \"left\" | \"right\";\n  trigger?: React.ReactNode;\n}\n\nexport const SectionContextMenu: React.FC<SectionContextMenuProps> = ({\n\tsectionId,\n\tcurrentSidebar,\n\ttrigger,\n}) => {\n\tconst layoutStore = useLayoutStore();\n\tconst {moveSectionToSidebar} = layoutStore;\n\tconst {resetSectionPlacements} = layoutStore;\n\n\tconst section = getSectionById(sectionId);\n\n\tconst handleMoveToSidebar = (sidebar: \"left\" | \"right\") => {\n\t\tlogger.debug(\"ui\", `Moving section ${sectionId} to ${sidebar} sidebar via context menu`, {\n\t\t\tsectionId,\n\t\t\tfromSidebar: currentSidebar,\n\t\t\ttoSidebar: sidebar\n\t\t});\n\t\tmoveSectionToSidebar(sectionId, sidebar);\n\t};\n\n\tconst handleResetPlacements = () => {\n\t\tlogger.debug(\"ui\", \"Resetting all section placements to defaults\", {\n\t\t\tsectionId\n\t\t});\n\t\tresetSectionPlacements();\n\t};\n\n\tif (!section) {\n\t\treturn null;\n\t}\n\n\tconst defaultTrigger = (\n\t\t<ActionIcon\n\t\t\tvariant=\"subtle\"\n\t\t\tsize=\"sm\"\n\t\t\tonClick={(e) => { e.stopPropagation(); }}\n\t\t>\n\t\t\t<IconDots size={14} />\n\t\t</ActionIcon>\n\t);\n\n\treturn (\n\t\t<Menu\n\t\t\tposition=\"bottom-end\"\n\t\t\twithArrow\n\t\t\tshadow=\"md\"\n\t\t\tcloseOnClickOutside\n\t\t\tcloseOnEscape\n\t\t>\n\t\t\t<Menu.Target>\n\t\t\t\t{trigger || defaultTrigger}\n\t\t\t</Menu.Target>\n\n\t\t\t<Menu.Dropdown>\n\t\t\t\t<Menu.Label>Move Section</Menu.Label>\n\n\t\t\t\t{currentSidebar === \"right\" && (\n\t\t\t\t\t<Menu.Item\n\t\t\t\t\t\tleftSection={<IconArrowLeft size={14} />}\n\t\t\t\t\t\tonClick={() => { handleMoveToSidebar(\"left\"); }}\n\t\t\t\t\t>\n            Move to Left Sidebar\n\t\t\t\t\t</Menu.Item>\n\t\t\t\t)}\n\n\t\t\t\t{currentSidebar === \"left\" && (\n\t\t\t\t\t<Menu.Item\n\t\t\t\t\t\tleftSection={<IconArrowRight size={14} />}\n\t\t\t\t\t\tonClick={() => { handleMoveToSidebar(\"right\"); }}\n\t\t\t\t\t>\n            Move to Right Sidebar\n\t\t\t\t\t</Menu.Item>\n\t\t\t\t)}\n\n\t\t\t\t<Menu.Divider />\n\n\t\t\t\t<Menu.Label>Layout</Menu.Label>\n\n\t\t\t\t<Menu.Item\n\t\t\t\t\tleftSection={<IconRefresh size={14} />}\n\t\t\t\t\tonClick={handleResetPlacements}\n\t\t\t\t>\n          Reset All Sections to Default\n\t\t\t\t</Menu.Item>\n\t\t\t</Menu.Dropdown>\n\t\t</Menu>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/layout/VerticalStackSidebar.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":120,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":120,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4329,4331],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":141,"column":3,"nodeType":"JSXOpeningElement","endLine":148,"endColumn":4},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":157,"column":55,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":157,"endColumn":57,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5353,5355],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":163,"column":8,"nodeType":"JSXOpeningElement","endLine":184,"endColumn":9}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vertical stack sidebar component for VSCode-style tool groups\n * Shows all tools within the active group in a vertical stack\n */\n\nimport React, { Suspense } from \"react\";\nimport { Stack, Divider, Text, Collapse, ActionIcon } from \"@mantine/core\";\nimport { IconChevronDown, IconGripVertical } from \"@tabler/icons-react\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { getSectionById } from \"@/stores/section-registry\";\nimport { getGroupDefinition } from \"@/stores/group-registry\";\nimport { SectionContextMenu } from \"@/components/layout/SectionContextMenu\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface VerticalStackSidebarProps {\n  side: \"left\" | \"right\";\n}\n\nexport const VerticalStackSidebar: React.FC<VerticalStackSidebarProps> = ({ side }) => {\n\tconst layoutStore = useLayoutStore();\n\tconst {getActiveGroup} = layoutStore;\n\tconst {getToolGroupsForSidebar} = layoutStore;\n\tconst {addSectionToGroup} = layoutStore;\n\tconst {removeSectionFromGroup} = layoutStore;\n\tconst {setSectionCollapsed} = layoutStore;\n\tconst {collapsedSections} = layoutStore;\n\tconst {setLeftSidebarOpen} = layoutStore;\n\tconst {setRightSidebarOpen} = layoutStore;\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\tconst activeGroupId = getActiveGroup(side);\n\tconst toolGroups = getToolGroupsForSidebar(side);\n\tconst activeGroup = activeGroupId ? toolGroups[activeGroupId] : null;\n\n\tconst groupDefinition = activeGroupId ? getGroupDefinition(activeGroupId) : null;\n\n\tconst handleDrop = (event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tconst draggedSectionId = event.dataTransfer.getData(\"text/plain\");\n\t\tif (!draggedSectionId || !activeGroupId) return;\n\n\t\tlogger.debug(\"ui\", `Moving section ${draggedSectionId} to active group ${activeGroupId} for ${side} sidebar`, {\n\t\t\tdraggedSectionId,\n\t\t\tactiveGroupId,\n\t\t\tside\n\t\t});\n\n\t\t// First, remove the section from all existing groups on both sides\n\t\tconst leftGroups = getToolGroupsForSidebar(\"left\");\n\t\tconst rightGroups = getToolGroupsForSidebar(\"right\");\n\n\t\t// Remove from left sidebar groups\n\t\tObject.entries(leftGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tremoveSectionFromGroup(\"left\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Remove from right sidebar groups\n\t\tObject.entries(rightGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tremoveSectionFromGroup(\"right\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Then add to the target group\n\t\taddSectionToGroup(side, activeGroupId, draggedSectionId);\n\t};\n\n\tconst handleDragOver = (event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t};\n\n\tconst handleToolDragStart = (sectionId: string, event: React.DragEvent) => {\n\t\tlogger.debug(\"ui\", `Starting drag for tool ${sectionId}`, { sectionId, side });\n\t\tevent.dataTransfer.setData(\"text/plain\", sectionId);\n\t\tevent.dataTransfer.effectAllowed = \"move\";\n\t};\n\n\tconst handleToolDrop = (targetSectionId: string, event: React.DragEvent) => {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tconst draggedSectionId = event.dataTransfer.getData(\"text/plain\");\n\t\tif (!draggedSectionId || !activeGroupId || draggedSectionId === targetSectionId) return;\n\n\t\tlogger.debug(\"ui\", `Moving tool ${draggedSectionId} to group ${activeGroupId}`, {\n\t\t\tdraggedSectionId,\n\t\t\ttargetGroupId: activeGroupId,\n\t\t\tside\n\t\t});\n\n\t\t// First, remove the section from all existing groups on both sides\n\t\tconst leftGroups = getToolGroupsForSidebar(\"left\");\n\t\tconst rightGroups = getToolGroupsForSidebar(\"right\");\n\n\t\t// Remove from left sidebar groups\n\t\tObject.entries(leftGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tremoveSectionFromGroup(\"left\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Remove from right sidebar groups\n\t\tObject.entries(rightGroups).forEach(([groupId, group]) => {\n\t\t\tif (group.sections.includes(draggedSectionId)) {\n\t\t\t\tremoveSectionFromGroup(\"right\", groupId, draggedSectionId);\n\t\t\t}\n\t\t});\n\n\t\t// Then add to the target group\n\t\taddSectionToGroup(side, activeGroupId, draggedSectionId);\n\t};\n\n\tconst handleToggleCollapse = (sectionId: string) => {\n\t\tconst isCollapsed = collapsedSections[sectionId] || false;\n\t\tsetSectionCollapsed(sectionId, !isCollapsed);\n\t};\n\n\t// Use useEffect to handle sidebar collapse when no active group\n\tReact.useEffect(() => {\n\t\tif (!activeGroup || !groupDefinition) {\n\t\t\t// Collapse only the specific sidebar that has no active group\n\t\t\tif (side === \"left\") {\n\t\t\t\tsetLeftSidebarOpen(false);\n\t\t\t} else {\n\t\t\t\tsetRightSidebarOpen(false);\n\t\t\t}\n\t\t}\n\t}, [activeGroup, groupDefinition, side, setLeftSidebarOpen, setRightSidebarOpen]);\n\n\tif (!activeGroup || !groupDefinition) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tstyle={{\n\t\t\t\theight: \"100%\",\n\t\t\t\toverflow: \"auto\",\n\t\t\t}}\n\t\t\tonDrop={handleDrop}\n\t\t\tonDragOver={handleDragOver}\n\t\t>\n\t\t\t{/* Vertical stack of all tools in the group */}\n\t\t\t<Stack gap={0}>\n\t\t\t\t{activeGroup.sections.map((sectionId, index) => {\n\t\t\t\t\tconst section = getSectionById(sectionId);\n\t\t\t\t\tif (!section) return null;\n\n\t\t\t\t\tconst SectionComponent = section.component;\n\t\t\t\t\tconst isLast = index === activeGroup.sections.length - 1;\n\t\t\t\t\tconst isCollapsed = collapsedSections[sectionId] || false;\n\t\t\t\t\tconst SectionIcon = section.icon;\n\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<div key={sectionId}>\n\t\t\t\t\t\t\t{/* Collapsible tool header */}\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tdraggable\n\t\t\t\t\t\t\t\tonDragStart={(e) => { handleToolDragStart(sectionId, e); }}\n\t\t\t\t\t\t\t\tonDrop={(e) => { handleToolDrop(sectionId, e); }}\n\t\t\t\t\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\t\tbackgroundColor: colors.background.tertiary,\n\t\t\t\t\t\t\t\t\tborderBottom: `1px solid ${colors.border.primary}`,\n\t\t\t\t\t\t\t\t\tcursor: \"grab\",\n\t\t\t\t\t\t\t\t\tuserSelect: \"none\",\n\t\t\t\t\t\t\t\t\ttransition: \"background-color 0.2s ease\",\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = colors.background.secondary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = colors.background.tertiary;\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{/* Drag handle */}\n\t\t\t\t\t\t\t\t<IconGripVertical\n\t\t\t\t\t\t\t\t\tsize={14}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\t\t\t\t\t\tmarginRight: \"6px\",\n\t\t\t\t\t\t\t\t\t\tcursor: \"grab\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t/>\n\n\t\t\t\t\t\t\t\t{/* Tool icon */}\n\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\t\t\t\tmarginRight: \"8px\",\n\t\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\t\talignItems: \"center\"\n\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t<SectionIcon size={16} />\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t{/* Tool title - clickable for collapse */}\n\t\t\t\t\t\t\t\t<Text\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tfw={500}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\t\t\t\t\t\tflex: 1,\n\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\tonClick={() => { handleToggleCollapse(sectionId); }}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{section.title}\n\t\t\t\t\t\t\t\t</Text>\n\n\t\t\t\t\t\t\t\t{/* Context menu */}\n\t\t\t\t\t\t\t\t<SectionContextMenu\n\t\t\t\t\t\t\t\t\tsectionId={sectionId}\n\t\t\t\t\t\t\t\t\tcurrentSidebar={side}\n\t\t\t\t\t\t\t\t/>\n\n\t\t\t\t\t\t\t\t{/* Collapse toggle */}\n\t\t\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tonClick={() => { handleToggleCollapse(sectionId); }}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tmarginLeft: \"4px\",\n\t\t\t\t\t\t\t\t\t\ttransform: isCollapsed ? \"rotate(-90deg)\" : \"rotate(0deg)\",\n\t\t\t\t\t\t\t\t\t\ttransition: \"transform 0.2s ease\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<IconChevronDown size={14} />\n\t\t\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t{/* Collapsible section content */}\n\t\t\t\t\t\t\t<Collapse in={!isCollapsed}>\n\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\t\t\t\tminHeight: isCollapsed ? 0 : \"200px\"\n\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t<Suspense\n\t\t\t\t\t\t\t\t\t\tfallback={\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t>\n                        Loading {section.title}...\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<SectionComponent />\n\t\t\t\t\t\t\t\t\t</Suspense>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</Collapse>\n\n\t\t\t\t\t\t\t{/* Divider between tools (except for last one) */}\n\t\t\t\t\t\t\t{!isLast && (\n\t\t\t\t\t\t\t\t<Divider\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tborderColor: colors.border.secondary\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</Stack>\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/molecules/BuildInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/molecules/CollapsibleSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/molecules/ForceControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/molecules/LayoutControls.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":36,"column":42,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":36,"endColumn":44,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1037,1039],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":46,"column":28,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":46,"endColumn":30,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1257,1259],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Layout controls for switching graph layouts\n */\n\nimport React from \"react\";\nimport { Button, Popover, Stack, Text } from \"@mantine/core\";\nimport { IconLayout, IconNetwork } from \"@tabler/icons-react\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport type { GraphLayout } from \"@academic-explorer/graph\";\n\nconst layoutOptions = [\n\t{\n\t\ttype: \"d3-force\" as const,\n\t\tlabel: \"D3 Force Layout\",\n\t\tdescription: \"Physics-based layout with optimal node separation\",\n\t\ticon: IconNetwork,\n\t},\n];\n\nexport const LayoutControls: React.FC = () => {\n\tconst currentLayout = useGraphStore((state) => state.currentLayout);\n\tconst setLayout = useGraphStore((state) => state.setLayout);\n\n\tconst handleLayoutChange = () => {\n\t\t// Always use D3 force layout with empty options (hook will use fixed parameters)\n\t\tconst newLayout: GraphLayout = {\n\t\t\ttype: \"d3-force\",\n\t\t\toptions: {}\n\t\t};\n\n\t\tsetLayout(newLayout);\n\t};\n\n\n\tconst currentOption = layoutOptions.find(opt => opt.type === currentLayout.type);\n\tconst CurrentIcon = currentOption?.icon || IconLayout;\n\n\treturn (\n\t\t<Popover position=\"bottom-start\" shadow=\"md\">\n\t\t\t<Popover.Target>\n\t\t\t\t<Button\n\t\t\t\t\tleftSection={<CurrentIcon size={16} />}\n\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\tsize=\"sm\"\n\t\t\t\t>\n\t\t\t\t\t{currentOption?.label || \"Layout\"}\n\t\t\t\t</Button>\n\t\t\t</Popover.Target>\n\n\t\t\t<Popover.Dropdown>\n\t\t\t\t<Stack gap=\"md\" style={{ minWidth: 280 }}>\n\t\t\t\t\t<Text size=\"sm\" fw={500}>Graph Layout</Text>\n\n\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t{layoutOptions.map(option => {\n\t\t\t\t\t\t\tconst OptionIcon = option.icon;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\tkey={option.type}\n\t\t\t\t\t\t\t\t\tvariant={currentLayout.type === option.type ? \"filled\" : \"subtle\"}\n\t\t\t\t\t\t\t\t\tleftSection={<OptionIcon size={16} />}\n\t\t\t\t\t\t\t\t\tonClick={() => { handleLayoutChange(); }}\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tjustify=\"flex-start\"\n\t\t\t\t\t\t\t\t\tfullWidth\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t<Text size=\"sm\">{option.label}</Text>\n\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" style={{ fontSize: \"11px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t{option.description}\n\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</Stack>\n\n\t\t\t\t</Stack>\n\t\t\t</Popover.Dropdown>\n\t\t</Popover>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/molecules/RawApiDataSection.tsx","messages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":117,"column":6,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[2750,2757],"text":"\n\t\t\t\t\t&quot;"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[2750,2757],"text":"\n\t\t\t\t\t&ldquo;"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[2750,2757],"text":"\n\t\t\t\t\t&#34;"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[2750,2757],"text":"\n\t\t\t\t\t&rdquo;"},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":117,"column":14,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[2764,2770],"text":"&quot;\n\t\t\t\t"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[2764,2770],"text":"&ldquo;\n\t\t\t\t"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[2764,2770],"text":"&#34;\n\t\t\t\t"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[2764,2770],"text":"&rdquo;\n\t\t\t\t"},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":182,"column":8,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":182,"endColumn":22},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":309,"column":56,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":309,"endColumn":58,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7445,7447],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Component to display raw OpenAlex API data in a readable format\n * Fetches data on demand only when entityId is provided\n */\n\nimport React, { useState } from \"react\";\nimport { IconDownload, IconLoader, IconCopy } from \"@tabler/icons-react\";\nimport { useRawEntityData } from \"@/hooks/use-raw-entity-data\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface RawApiDataSectionProps {\n  entityId?: string | null;\n  className?: string;\n}\n\nexport const RawApiDataSection: React.FC<RawApiDataSectionProps> = ({\n\tentityId,\n\tclassName\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\tconst [viewMode, setViewMode] = useState<\"formatted\" | \"raw\">(\"formatted\");\n\n\tconst rawEntityDataResult = useRawEntityData({\n\t\tentityId: entityId ?? null,\n\t\tenabled: !!entityId\n\t});\n\tconst rawData = rawEntityDataResult.data;\n\tconst {isLoading} = rawEntityDataResult;\n\tconst {error} = rawEntityDataResult;\n\tconst isError = !!rawEntityDataResult.error;\n\n\t// Note: ExpandableSection component removed as we now show all data expanded by default\n\n\tconst formatValue = (value: unknown, depth = 0): React.ReactNode => {\n\t\t// Enhanced styling with better visual hierarchy\n\t\tconst indentSize = 16;\n\n\t\tif (value === null) return (\n\t\t\t<span style={{\n\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\tfontStyle: \"italic\",\n\t\t\t\tfontSize: \"12px\",\n\t\t\t\tfontWeight: \"500\"\n\t\t\t}}>\n\t\t\t\tnull\n\t\t\t</span>\n\t\t);\n\n\t\tif (value === undefined) return (\n\t\t\t<span style={{\n\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\tfontStyle: \"italic\",\n\t\t\t\tfontSize: \"12px\",\n\t\t\t\tfontWeight: \"500\"\n\t\t\t}}>\n\t\t\t\tundefined\n\t\t\t</span>\n\t\t);\n\n\t\tif (typeof value === \"boolean\") {\n\t\t\treturn (\n\t\t\t\t<span style={{\n\t\t\t\t\tcolor: value ? \"#10b981\" : \"#f59e0b\",\n\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\tfontSize: \"12px\"\n\t\t\t\t}}>\n\t\t\t\t\t{value ? \"true\" : \"false\"}\n\t\t\t\t</span>\n\t\t\t);\n\t\t}\n\n\t\tif (typeof value === \"number\") {\n\t\t\treturn (\n\t\t\t\t<span style={{\n\t\t\t\t\tcolor: \"#dc2626\",\n\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\tfontSize: \"12px\"\n\t\t\t\t}}>\n\t\t\t\t\t{value.toLocaleString()}\n\t\t\t\t</span>\n\t\t\t);\n\t\t}\n\n\t\tif (typeof value === \"string\") {\n\t\t\t// Detect URLs and make them clickable\n\t\t\tif (value.startsWith(\"http\")) {\n\t\t\t\treturn (\n\t\t\t\t\t<a\n\t\t\t\t\t\thref={value}\n\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\trel=\"noopener noreferrer\"\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tcolor: \"#2563eb\",\n\t\t\t\t\t\t\ttextDecoration: \"underline\",\n\t\t\t\t\t\t\twordBreak: \"break-all\",\n\t\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\tbackgroundColor: \"#eff6ff\",\n\t\t\t\t\t\t\tpadding: \"1px 4px\",\n\t\t\t\t\t\t\tborderRadius: \"3px\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{value}\n\t\t\t\t\t</a>\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Enhanced string styling with quotes and better contrast\n\t\t\treturn (\n\t\t\t\t<span style={{\n\t\t\t\t\tcolor: \"#059669\",\n\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\tfontWeight: \"500\"\n\t\t\t\t}}>\n\t\t\t\t\t\"{value}\"\n\t\t\t\t</span>\n\t\t\t);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tif (value.length === 0) {\n\t\t\t\treturn (\n\t\t\t\t\t<span style={{\n\t\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\t\tfontStyle: \"italic\",\n\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\tpadding: \"2px 6px\",\n\t\t\t\t\t\tborderRadius: \"4px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t[] (empty array)\n\t\t\t\t\t</span>\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Enhanced array display with better visual hierarchy\n\t\t\treturn (\n\t\t\t\t<div style={{\n\t\t\t\t\tmarginLeft: `${indentSize.toString()}px`,\n\t\t\t\t\tborderLeft: `2px solid ${colors.border.secondary}`,\n\t\t\t\t\tpaddingLeft: \"8px\",\n\t\t\t\t\tmarginTop: \"4px\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\t\tmarginBottom: \"4px\",\n\t\t\t\t\t\ttextTransform: \"uppercase\",\n\t\t\t\t\t\tletterSpacing: \"0.5px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\tArray ({value.length} items)\n\t\t\t\t\t</div>\n\t\t\t\t\t{value.map((item, index) => (\n\t\t\t\t\t\t<div key={`array-item-${String(index)}-${JSON.stringify(item).substring(0, 20)}`} style={{\n\t\t\t\t\t\t\tmarginBottom: \"6px\",\n\t\t\t\t\t\t\tpaddingBottom: \"4px\",\n\t\t\t\t\t\t\tborderBottom: index < value.length - 1 ? `1px solid ${colors.border.secondary}` : \"none\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<span style={{\n\t\t\t\t\t\t\t\tcolor: \"#8b5cf6\",\n\t\t\t\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\t\t\tpadding: \"1px 4px\",\n\t\t\t\t\t\t\t\tborderRadius: \"3px\",\n\t\t\t\t\t\t\t\tmarginRight: \"8px\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t[{index}]\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{formatValue(item, depth + 1)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t);\n\t\t}\n\n\t\tif (typeof value === \"object\") {\n\t\t\t// Type guard: ensure value is a non-null object\n\t\t\tif (value === null || Array.isArray(value)) {\n\t\t\t\treturn (\n\t\t\t\t\t<span style={{\n\t\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\t\tfontStyle: \"italic\",\n\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\tbackgroundColor: \"#fef2f2\",\n\t\t\t\t\t\tpadding: \"2px 6px\",\n\t\t\t\t\t\tborderRadius: \"4px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t[Unexpected value type]\n\t\t\t\t\t</span>\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst entries = Object.entries(value);\n\n\t\t\tif (entries.length === 0) {\n\t\t\t\treturn (\n\t\t\t\t\t<span style={{\n\t\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\t\tfontStyle: \"italic\",\n\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\tpadding: \"2px 6px\",\n\t\t\t\t\t\tborderRadius: \"4px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t{\"{}\"} (empty object)\n\t\t\t\t\t</span>\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Enhanced object display with better visual hierarchy\n\t\t\treturn (\n\t\t\t\t<div style={{\n\t\t\t\t\tmarginLeft: `${indentSize.toString()}px`,\n\t\t\t\t\tborderLeft: `2px solid ${colors.border.secondary}`,\n\t\t\t\t\tpaddingLeft: \"8px\",\n\t\t\t\t\tmarginTop: \"4px\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\t\tmarginBottom: \"4px\",\n\t\t\t\t\t\ttextTransform: \"uppercase\",\n\t\t\t\t\t\tletterSpacing: \"0.5px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\tObject ({entries.length} properties)\n\t\t\t\t\t</div>\n\t\t\t\t\t{entries.map(([key, val], index) => (\n\t\t\t\t\t\t<div key={key} style={{\n\t\t\t\t\t\t\tmarginBottom: \"6px\",\n\t\t\t\t\t\t\tpaddingBottom: \"4px\",\n\t\t\t\t\t\t\tborderBottom: index < entries.length - 1 ? `1px solid ${colors.border.secondary}` : \"none\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<span style={{\n\t\t\t\t\t\t\t\tcolor: \"#1f2937\",\n\t\t\t\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#fef3c7\",\n\t\t\t\t\t\t\t\tpadding: \"1px 4px\",\n\t\t\t\t\t\t\t\tborderRadius: \"3px\",\n\t\t\t\t\t\t\t\tmarginRight: \"8px\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t{key}:\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t{formatValue(val, depth + 1)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t);\n\t\t}\n\n\t\t// Fallback for any other value types (should rarely happen)\n\t\tif (typeof value === \"object\") {\n\t\t\treturn (\n\t\t\t\t<span style={{\n\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\tfontStyle: \"italic\",\n\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\tbackgroundColor: \"#fef2f2\",\n\t\t\t\t\tpadding: \"2px 6px\",\n\t\t\t\t\tborderRadius: \"4px\"\n\t\t\t\t}}>\n\t\t\t\t\t[Unknown Object]\n\t\t\t\t</span>\n\t\t\t);\n\t\t}\n\n\t\t// Only primitive types should reach here (string, number, boolean, symbol, bigint)\n\t\t// Type guard: ensure value is a displayable primitive\n\t\tif (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n\t\t\treturn (\n\t\t\t\t<span style={{\n\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\tfontSize: \"12px\"\n\t\t\t\t}}>\n\t\t\t\t\t{value}\n\t\t\t\t</span>\n\t\t\t);\n\t\t}\n\n\t\t// Fallback for unexpected types\n\t\treturn (\n\t\t\t<span style={{\n\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\tfontStyle: \"italic\",\n\t\t\t\tfontSize: \"12px\",\n\t\t\t\tbackgroundColor: \"#fef2f2\",\n\t\t\t\tpadding: \"2px 6px\",\n\t\t\t\tborderRadius: \"4px\"\n\t\t\t}}>\n\t\t\t\t[Unsupported type: {typeof value}]\n\t\t\t</span>\n\t\t);\n\t};\n\n\tconst downloadJsonData = () => {\n\t\tif (!rawData) return;\n\n\t\ttry {\n\t\t\tconst jsonString = JSON.stringify(rawData, null, 2);\n\t\t\tconst blob = new Blob([jsonString], { type: \"application/json\" });\n\t\t\tconst url = URL.createObjectURL(blob);\n\n\t\t\tconst a = document.createElement(\"a\");\n\t\t\ta.href = url;\n\t\t\ta.download = `openalex-${entityId?.split(\"/\").pop() || \"entity\"}-data.json`;\n\t\t\tdocument.body.appendChild(a);\n\t\t\ta.click();\n\t\t\tdocument.body.removeChild(a);\n\n\t\t\tURL.revokeObjectURL(url);\n\n\t\t\tlogger.debug(\"ui\", \"Raw API data downloaded\", {\n\t\t\t\tentityId,\n\t\t\t\tfilename: a.download\n\t\t\t}, \"RawApiDataSection\");\n\t\t} catch (error) {\n\t\t\tlogger.error(\"ui\", \"Failed to download raw API data\", {\n\t\t\t\tentityId,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t}, \"RawApiDataSection\");\n\t\t}\n\t};\n\n\tconst copyJsonData = async () => {\n\t\tif (!rawData) return;\n\n\t\ttry {\n\t\t\tconst jsonString = JSON.stringify(rawData, null, 2);\n\t\t\tawait navigator.clipboard.writeText(jsonString);\n\n\t\t\tlogger.debug(\"ui\", \"Raw API data copied to clipboard\", {\n\t\t\t\tentityId,\n\t\t\t\tdataSize: jsonString.length\n\t\t\t}, \"RawApiDataSection\");\n\t\t} catch (error) {\n\t\t\tlogger.error(\"ui\", \"Failed to copy raw API data to clipboard\", {\n\t\t\t\tentityId,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t}, \"RawApiDataSection\");\n\t\t}\n\t};\n\n\tif (!entityId) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<div className={className}>\n\t\t\t{isLoading && (\n\t\t\t\t<div style={{\n\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\tgap: \"8px\",\n\t\t\t\t\tpadding: \"12px\",\n\t\t\t\t\tcolor: \"#6b7280\",\n\t\t\t\t\tfontSize: \"12px\"\n\t\t\t\t}}>\n\t\t\t\t\t<IconLoader size={16} style={{ animation: \"spin 1s linear infinite\" }} />\n              Loading raw API data...\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{isError && (\n\t\t\t\t<div style={{\n\t\t\t\t\tpadding: \"12px\",\n\t\t\t\t\tbackgroundColor: \"#fef2f2\",\n\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\tborder: \"1px solid #fecaca\",\n\t\t\t\t\tcolor: \"#dc2626\",\n\t\t\t\t\tfontSize: \"12px\"\n\t\t\t\t}}>\n              Failed to load raw API data: {error instanceof Error ? error.message : \"Unknown error\"}\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{rawData && (\n\t\t\t\t<>\n\t\t\t\t\t{/* Controls */}\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\tgap: \"8px\",\n\t\t\t\t\t\tmarginBottom: \"12px\",\n\t\t\t\t\t\tpaddingBottom: \"8px\",\n\t\t\t\t\t\tborderBottom: `1px solid ${colors.border.secondary}`\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tonClick={() => { setViewMode(\"formatted\"); }}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tpadding: \"4px 8px\",\n\t\t\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\t\t\tbackgroundColor: viewMode === \"formatted\" ? \"#3b82f6\" : \"#f3f4f6\",\n\t\t\t\t\t\t\t\tcolor: viewMode === \"formatted\" ? \"white\" : \"#374151\",\n\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n                  Formatted\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tonClick={() => { setViewMode(\"raw\"); }}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tpadding: \"4px 8px\",\n\t\t\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\t\t\tbackgroundColor: viewMode === \"raw\" ? \"#3b82f6\" : \"#f3f4f6\",\n\t\t\t\t\t\t\t\tcolor: viewMode === \"raw\" ? \"white\" : \"#374151\",\n\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n                  Raw JSON\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tonClick={() => { void copyJsonData(); }}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tpadding: \"4px 8px\",\n\t\t\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#8b5cf6\",\n\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\tgap: \"4px\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconCopy size={12} />\n                  Copy\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tonClick={downloadJsonData}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tpadding: \"4px 8px\",\n\t\t\t\t\t\t\t\tfontSize: \"11px\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#10b981\",\n\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\tgap: \"4px\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconDownload size={12} />\n                  Download\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Data Display */}\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tmaxHeight: \"500px\",\n\t\t\t\t\t\toverflow: \"auto\",\n\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\tbackgroundColor: \"#ffffff\",\n\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\tborder: `2px solid ${colors.border.secondary}`,\n\t\t\t\t\t\tboxShadow: \"0 1px 3px rgba(0, 0, 0, 0.1)\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t{viewMode === \"formatted\" ? (\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\t\t\tfontFamily: \"ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace\",\n\t\t\t\t\t\t\t\tlineHeight: \"1.6\",\n\t\t\t\t\t\t\t\tcolor: colors.text.primary\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t{formatValue(rawData)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<pre style={{\n\t\t\t\t\t\t\t\tfontSize: \"10px\",\n\t\t\t\t\t\t\t\tfontFamily: \"ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace\",\n\t\t\t\t\t\t\t\tmargin: 0,\n\t\t\t\t\t\t\t\twhiteSpace: \"pre-wrap\",\n\t\t\t\t\t\t\t\twordBreak: \"break-word\",\n\t\t\t\t\t\t\t\tcolor: \"#374151\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t{JSON.stringify(rawData, null, 2)}\n\t\t\t\t\t\t\t</pre>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Data Stats */}\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tmarginTop: \"8px\",\n\t\t\t\t\t\tfontSize: \"10px\",\n\t\t\t\t\t\tcolor: \"#6b7280\",\n\t\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t{Object.keys(rawData).length} properties • {JSON.stringify(rawData).length.toLocaleString()} characters\n\t\t\t\t\t</div>\n\t\t\t\t</>\n\t\t\t)}\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/molecules/RichEntityDisplay.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":186,"column":57,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":186,"endColumn":59,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5281,5283],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":235,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":235,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6879,6881],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":240,"column":37,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":240,"endColumn":39,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[7050,7052],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":240,"column":42,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":240,"endColumn":44,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[7055,7057],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":323,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":323,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[9399,9401],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":408,"column":86,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":408,"endColumn":88,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[12105,12107],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":603,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":603,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[18028,18030],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Rich entity display component with detailed, entity-specific information\n * Provides context-aware views for different OpenAlex entity types\n */\n\nimport React from \"react\";\nimport {\n\tStack,\n\tCard,\n\tGroup,\n\tBadge,\n\tText,\n\tTitle,\n\tAnchor,\n\tThemeIcon,\n\tTimeline,\n\tPaper,\n\tNumberFormatter,\n\tScrollArea\n} from \"@mantine/core\";\nimport {\n\tIconFile,\n\tIconUser,\n\tIconBook,\n\tIconBuilding,\n\tIconTag,\n\tIconBuildingStore,\n\tIconQuote,\n\tIconTrendingUp,\n\tIconEye,\n\tIconCalendar,\n\tIconWorld,\n\tIconStar,\n\tIconBolt,\n\tIconChartBar,\n\tIconUsers,\n\tIconSchool,\n\tIconMedal,\n\tIconTarget,\n\tIconMapPin,\n\tIconClock\n} from \"@tabler/icons-react\";\nimport { useRawEntityData } from \"@/hooks/use-raw-entity-data\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { useEntityInteraction } from \"@/hooks/use-entity-interaction\";\nimport type { GraphNode } from \"@academic-explorer/graph\";\nimport type { Authorship, OpenAlexEntity } from \"@academic-explorer/client\";\nimport { isWork, isAuthor, isInstitution } from \"@academic-explorer/client\";\nimport { getNodeYear, getNodeOpenAccess, getNodeCitationCount } from \"@academic-explorer/graph\";\n\ninterface RichEntityDisplayProps {\n\tentity: GraphNode;\n}\n\nexport const RichEntityDisplay: React.FC<RichEntityDisplayProps> = ({\n\tentity\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\tconst rawEntityData = useRawEntityData({\n\t\tentityId: entity.entityId\n\t});\n\tconst rawData = rawEntityData.data;\n\tconst {isLoading} = rawEntityData;\n\tconst entityInteraction = useEntityInteraction();\n\tconst {handleSidebarEntityClick} = entityInteraction;\n\n\tconst getEntityIcon = (type: string, size = 20) => {\n\t\tconst iconProps = { size };\n\t\tswitch (type) {\n\t\t\tcase \"works\": return <IconFile {...iconProps} />;\n\t\t\tcase \"authors\": return <IconUser {...iconProps} />;\n\t\t\tcase \"sources\": return <IconBook {...iconProps} />;\n\t\t\tcase \"institutions\": return <IconBuilding {...iconProps} />;\n\t\t\tcase \"topics\": return <IconTag {...iconProps} />;\n\t\t\tcase \"publishers\": return <IconBuildingStore {...iconProps} />;\n\t\t\tdefault: return <IconTarget {...iconProps} />;\n\t\t}\n\t};\n\n\tconst getEntityColor = (type: string): string => {\n\t\tswitch (type) {\n\t\t\tcase \"works\": return \"red\";\n\t\t\tcase \"authors\": return \"blue\";\n\t\t\tcase \"sources\": return \"green\";\n\t\t\tcase \"institutions\": return \"orange\";\n\t\t\tcase \"topics\": return \"violet\";\n\t\t\tcase \"publishers\": return \"teal\";\n\t\t\tdefault: return \"gray\";\n\t\t}\n\t};\n\n\tconst formatNumber = (num: number | undefined | null) => {\n\t\tif (!num || num === 0) return \"0\";\n\t\treturn num.toLocaleString();\n\t};\n\n\tconst handleEntityClick = (entityId: string, entityType: string) => {\n\t\t// Use shared entity interaction logic for consistent behavior\n\t\tvoid handleSidebarEntityClick(entityId, entityType);\n\t};\n\n\t// Entity-specific rich content components\n\tconst WorksDisplay = ({ work }: { work: OpenAlexEntity }) => {\n\t\t// Type guard to ensure this is actually a Work entity\n\t\tif (!isWork(work)) return null;\n\n\t\treturn (\n\t\t\t<Stack gap=\"md\">\n\t\t\t\t{/* Publication Info */}\n\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"blue\">\n\t\t\t\t\t\t\t<IconCalendar size={16} />\n\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Publication Details</Text>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Group wrap=\"wrap\" gap=\"sm\">\n\t\t\t\t\t\t{work.publication_year && (\n\t\t\t\t\t\t\t<Badge size=\"lg\" variant=\"light\" color=\"blue\">\n\t\t\t\t\t\t\t\t{work.publication_year}\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{work.type && (\n\t\t\t\t\t\t\t<Badge size=\"lg\" variant=\"light\" color=\"gray\">\n\t\t\t\t\t\t\t\t{work.type}\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{work.open_access.is_oa && (\n\t\t\t\t\t\t\t<Badge size=\"lg\" variant=\"light\" color=\"green\">\n\t\t\t\t\t\t\t\tOpen Access\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t{work.primary_location?.source && (\n\t\t\t\t\t\t<Group mt=\"sm\" gap=\"xs\">\n\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">Published in:</Text>\n\t\t\t\t\t\t\t<Anchor\n\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\tfw={500}\n\t\t\t\t\t\t\t\tc={getEntityColor(\"sources\")}\n\t\t\t\t\t\t\t\tstyle={{ cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\tif (work.primary_location?.source?.id) {\n\t\t\t\t\t\t\t\t\t\thandleEntityClick(work.primary_location.source.id, \"source\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{work.primary_location.source.display_name}\n\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t)}\n\t\t\t\t</Card>\n\n\t\t\t\t{/* Impact Metrics */}\n\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"red\">\n\t\t\t\t\t\t\t<IconTrendingUp size={16} />\n\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Impact Metrics</Text>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Group grow>\n\t\t\t\t\t\t<Paper p=\"xs\" bg=\"gray.0\" radius=\"sm\">\n\t\t\t\t\t\t\t<Group justify=\"center\" gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconQuote size={16} color={colors.text.secondary} />\n\t\t\t\t\t\t\t\t<Stack gap={0} align=\"center\">\n\t\t\t\t\t\t\t\t\t<NumberFormatter\n\t\t\t\t\t\t\t\t\t\tvalue={work.cited_by_count || 0}\n\t\t\t\t\t\t\t\t\t\tthousandSeparator\n\t\t\t\t\t\t\t\t\t\tstyle={{ fontSize: \"16px\", fontWeight: 700 }}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">Citations</Text>\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t<Paper p=\"xs\" bg=\"gray.0\" radius=\"sm\">\n\t\t\t\t\t\t\t<Group justify=\"center\" gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconEye size={16} color={colors.text.secondary} />\n\t\t\t\t\t\t\t\t<Stack gap={0} align=\"center\">\n\t\t\t\t\t\t\t\t\t<NumberFormatter\n\t\t\t\t\t\t\t\t\t\tvalue={work.counts_by_year[0]?.cited_by_count || 0}\n\t\t\t\t\t\t\t\t\t\tthousandSeparator\n\t\t\t\t\t\t\t\t\t\tstyle={{ fontSize: \"16px\", fontWeight: 700 }}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">Recent</Text>\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t</Paper>\n\t\t\t\t\t</Group>\n\t\t\t\t</Card>\n\n\t\t\t\t{/* Authors */}\n\t\t\t\t{work.authorships.length > 0 && (\n\t\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"blue\">\n\t\t\t\t\t\t\t\t<IconUsers size={16} />\n\t\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t\t<Text size=\"sm\" fw={600}>\n\t\t\t\t\t\t\tAuthors ({work.authorships.length})\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t<ScrollArea.Autosize mah={120}>\n\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t{work.authorships.slice(0, 10).map((authorship: Authorship, index: number) => (\n\t\t\t\t\t\t\t\t\t<Group key={authorship.author.id || `authorship-${String(index)}`} gap=\"sm\" wrap=\"nowrap\">\n\t\t\t\t\t\t\t\t\t\t<Badge size=\"xs\" variant=\"light\">\n\t\t\t\t\t\t\t\t\t\t\t{authorship.author_position}\n\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t\t<Anchor\n\t\t\t\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\t\t\t\tc={getEntityColor(\"authors\")}\n\t\t\t\t\t\t\t\t\t\t\tstyle={{ flex: 1, cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (authorship.author.id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\thandleEntityClick(authorship.author.id, \"author\");\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{authorship.author.display_name || \"Unknown Author\"}\n\t\t\t\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t\t\t\t\t{authorship.institutions[0] && (\n\t\t\t\t\t\t\t\t\t\t\t<Anchor\n\t\t\t\t\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\t\t\t\t\tc={getEntityColor(\"institutions\")}\n\t\t\t\t\t\t\t\t\t\t\t\ttruncate\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{ maxWidth: 150, cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (authorship.institutions?.[0]?.id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thandleEntityClick(authorship.institutions[0].id, \"institution\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t{authorship.institutions?.[0]?.display_name}\n\t\t\t\t\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t{work.authorships.length > 10 && (\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" ta=\"center\">\n\t\t\t\t\t\t\t\t\t... and {work.authorships.length - 10} more\n\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t</ScrollArea.Autosize>\n\t\t\t\t\t</Card>\n\t\t\t\t)}\n\n\t\t\t\t{/* Topics/Keywords */}\n\t\t\t\t{work.topics && work.topics.length > 0 && (\n\t\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"violet\">\n\t\t\t\t\t\t\t\t<IconTag size={16} />\n\t\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Research Topics</Text>\n\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t{work.topics.slice(0, 8).map((topic, index: number) => (\n\t\t\t\t\t\t\t\t<Badge\n\t\t\t\t\t\t\t\t\tkey={topic.id || `topic-${String(index)}`}\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\tcolor={getEntityColor(\"topics\")}\n\t\t\t\t\t\t\t\t\tstyle={{ cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\tif (topic.id) {\n\t\t\t\t\t\t\t\t\t\t\thandleEntityClick(topic.id, \"topic\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{topic.display_name}\n\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t{work.topics.length > 8 && (\n\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t+{work.topics.length - 8} more\n\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t</Card>\n\t\t\t\t)}\n\t\t\t</Stack>\n\t\t);\n\t};\n\n\tconst AuthorsDisplay = ({ author }: { author: OpenAlexEntity }) => {\n\t\t// Type guard to ensure this is actually an Author entity\n\t\tif (!isAuthor(author)) return null;\n\n\t\treturn (\n\t\t\t<Stack gap=\"md\">\n\t\t\t\t{/* Academic Profile */}\n\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"blue\">\n\t\t\t\t\t\t\t<IconSchool size={16} />\n\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Academic Profile</Text>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Group wrap=\"wrap\" gap=\"sm\">\n\t\t\t\t\t\t{author.last_known_institutions && author.last_known_institutions.length > 0 && (\n\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconBuilding size={14} />\n\t\t\t\t\t\t\t\t<Anchor\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tc={getEntityColor(\"institutions\")}\n\t\t\t\t\t\t\t\t\tstyle={{ cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\tif (author.last_known_institutions?.[0]?.id) {\n\t\t\t\t\t\t\t\t\t\t\thandleEntityClick(author.last_known_institutions[0].id, \"institution\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{author.last_known_institutions?.[0]?.display_name}\n\t\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{author.works_count && (\n\t\t\t\t\t\t\t<Badge size=\"lg\" variant=\"light\" color=\"blue\">\n\t\t\t\t\t\t\t\t{formatNumber(author.works_count)} works\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{author.cited_by_count && (\n\t\t\t\t\t\t\t<Badge size=\"lg\" variant=\"light\" color=\"red\">\n\t\t\t\t\t\t\t\t{formatNumber(author.cited_by_count)} citations\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Group>\n\t\t\t\t</Card>\n\n\t\t\t\t{/* Research Impact */}\n\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"orange\">\n\t\t\t\t\t\t\t<IconMedal size={16} />\n\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Research Impact</Text>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Group grow>\n\t\t\t\t\t\t<Paper p=\"xs\" bg=\"gray.0\" radius=\"sm\">\n\t\t\t\t\t\t\t<Group justify=\"center\" gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconStar size={16} color={colors.text.secondary} />\n\t\t\t\t\t\t\t\t<Stack gap={0} align=\"center\">\n\t\t\t\t\t\t\t\t\t<Text fw={700} size=\"lg\">\n\t\t\t\t\t\t\t\t\t\t{author.summary_stats.h_index || 0}\n\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">H-Index</Text>\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t<Paper p=\"xs\" bg=\"gray.0\" radius=\"sm\">\n\t\t\t\t\t\t\t<Group justify=\"center\" gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconBolt size={16} color={colors.text.secondary} />\n\t\t\t\t\t\t\t\t<Stack gap={0} align=\"center\">\n\t\t\t\t\t\t\t\t\t<Text fw={700} size=\"lg\">\n\t\t\t\t\t\t\t\t\t\t{author.summary_stats.i10_index || 0}\n\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">i10-Index</Text>\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t</Paper>\n\t\t\t\t\t</Group>\n\t\t\t\t</Card>\n\n\t\t\t\t{/* Affiliations Timeline */}\n\t\t\t\t{author.affiliations.length > 0 && (\n\t\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"orange\">\n\t\t\t\t\t\t\t\t<IconBuilding size={16} />\n\t\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Affiliations</Text>\n\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t<Timeline active={0} bulletSize={20} lineWidth={2}>\n\t\t\t\t\t\t\t{author.affiliations.slice(0, 5).map((affiliation, index: number) => (\n\t\t\t\t\t\t\t\t<Timeline.Item\n\t\t\t\t\t\t\t\t\tkey={affiliation.institution.id || `affiliation-${String(index)}`}\n\t\t\t\t\t\t\t\t\tbullet={<IconBuilding size={12} />}\n\t\t\t\t\t\t\t\t\ttitle={\n\t\t\t\t\t\t\t\t\t\t<Anchor\n\t\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\t\tc={getEntityColor(\"institutions\")}\n\t\t\t\t\t\t\t\t\t\t\tstyle={{ cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (affiliation.institution.id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\thandleEntityClick(affiliation.institution.id, \"institution\");\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{affiliation.institution.display_name}\n\t\t\t\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t\t\t\t{affiliation.years[0]} - {affiliation.years[affiliation.years.length - 1] || \"present\"}\n\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t{affiliation.institution.country_code && (\n\t\t\t\t\t\t\t\t\t\t\t<Badge size=\"xs\" variant=\"light\">\n\t\t\t\t\t\t\t\t\t\t\t\t{affiliation.institution.country_code}\n\t\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t</Timeline.Item>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</Timeline>\n\t\t\t\t\t</Card>\n\t\t\t\t)}\n\n\t\t\t\t{/* Research Areas */}\n\t\t\t\t{author.topics && author.topics.length > 0 && (\n\t\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"violet\">\n\t\t\t\t\t\t\t\t<IconTag size={16} />\n\t\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Research Areas</Text>\n\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t{author.topics.slice(0, 5).map((topic, index: number) => (\n\t\t\t\t\t\t\t\t<Group key={topic.id || `author-topic-${String(index)}`} justify=\"space-between\">\n\t\t\t\t\t\t\t\t\t<Anchor\n\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\tc={getEntityColor(\"topics\")}\n\t\t\t\t\t\t\t\t\t\tstyle={{ cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\tif (topic.id) {\n\t\t\t\t\t\t\t\t\t\t\t\thandleEntityClick(topic.id, \"topic\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{topic.display_name}\n\t\t\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t\t\t\t<Badge size=\"xs\" variant=\"light\">\n\t\t\t\t\t\t\t\t\t\t{topic.count} works\n\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Card>\n\t\t\t\t)}\n\t\t\t</Stack>\n\t\t);\n\t};\n\n\tconst InstitutionsDisplay = ({ institution }: { institution: OpenAlexEntity }) => {\n\t\t// Type guard to ensure this is actually an Institution entity\n\t\tif (!isInstitution(institution)) return null;\n\n\t\treturn (\n\t\t\t<Stack gap=\"md\">\n\t\t\t\t{/* Location & Overview */}\n\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"orange\">\n\t\t\t\t\t\t\t<IconMapPin size={16} />\n\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Location & Overview</Text>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Group wrap=\"wrap\" gap=\"sm\">\n\t\t\t\t\t\t{institution.geo.city && (\n\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconWorld size={14} />\n\t\t\t\t\t\t\t\t<Text size=\"sm\">\n\t\t\t\t\t\t\t\t\t{institution.geo.city}, {institution.geo.country}\n\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{institution.type && (\n\t\t\t\t\t\t\t<Badge variant=\"light\" color=\"orange\">\n\t\t\t\t\t\t\t\t{institution.type}\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{institution.homepage_url && (\n\t\t\t\t\t\t\t<Anchor size=\"sm\" href={institution.homepage_url} target=\"_blank\">\n\t\t\t\t\t\t\tVisit Website\n\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Group>\n\t\t\t\t</Card>\n\n\t\t\t\t{/* Research Output */}\n\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"blue\">\n\t\t\t\t\t\t\t<IconChartBar size={16} />\n\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Research Output</Text>\n\t\t\t\t\t</Group>\n\n\t\t\t\t\t<Group grow>\n\t\t\t\t\t\t<Paper p=\"xs\" bg=\"gray.0\" radius=\"sm\">\n\t\t\t\t\t\t\t<Group justify=\"center\" gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconFile size={16} color={colors.text.secondary} />\n\t\t\t\t\t\t\t\t<Stack gap={0} align=\"center\">\n\t\t\t\t\t\t\t\t\t<NumberFormatter\n\t\t\t\t\t\t\t\t\t\tvalue={institution.works_count || 0}\n\t\t\t\t\t\t\t\t\t\tthousandSeparator\n\t\t\t\t\t\t\t\t\t\tstyle={{ fontSize: \"16px\", fontWeight: 700 }}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">Works</Text>\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t</Paper>\n\n\t\t\t\t\t\t<Paper p=\"xs\" bg=\"gray.0\" radius=\"sm\">\n\t\t\t\t\t\t\t<Group justify=\"center\" gap=\"xs\">\n\t\t\t\t\t\t\t\t<IconQuote size={16} color={colors.text.secondary} />\n\t\t\t\t\t\t\t\t<Stack gap={0} align=\"center\">\n\t\t\t\t\t\t\t\t\t<NumberFormatter\n\t\t\t\t\t\t\t\t\t\tvalue={institution.cited_by_count || 0}\n\t\t\t\t\t\t\t\t\t\tthousandSeparator\n\t\t\t\t\t\t\t\t\t\tstyle={{ fontSize: \"16px\", fontWeight: 700 }}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">Citations</Text>\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t</Paper>\n\t\t\t\t\t</Group>\n\t\t\t\t</Card>\n\n\t\t\t\t{/* Associated Topics */}\n\t\t\t\t{institution.topics && institution.topics.length > 0 && (\n\t\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t\t<Group gap=\"xs\" mb=\"sm\">\n\t\t\t\t\t\t\t<ThemeIcon variant=\"light\" size=\"sm\" color=\"violet\">\n\t\t\t\t\t\t\t\t<IconTag size={16} />\n\t\t\t\t\t\t\t</ThemeIcon>\n\t\t\t\t\t\t\t<Text size=\"sm\" fw={600}>Research Focus Areas</Text>\n\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t{institution.topics.slice(0, 6).map((topic, index: number) => (\n\t\t\t\t\t\t\t\t<Group key={topic.id || `institution-topic-${String(index)}`} justify=\"space-between\">\n\t\t\t\t\t\t\t\t\t<Anchor\n\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\tc={getEntityColor(\"topics\")}\n\t\t\t\t\t\t\t\t\t\tstyle={{ cursor: \"pointer\" }}\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\tif (topic.id) {\n\t\t\t\t\t\t\t\t\t\t\t\thandleEntityClick(topic.id, \"topic\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{topic.display_name}\n\t\t\t\t\t\t\t\t\t</Anchor>\n\t\t\t\t\t\t\t\t\t<Badge size=\"xs\" variant=\"light\">\n\t\t\t\t\t\t\t\t\t\t{topic.count} works\n\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Card>\n\t\t\t\t)}\n\t\t\t</Stack>\n\t\t);\n\t};\n\n\t// Enhanced basic info card that works for all entity types\n\tconst BasicInfoCard = () => (\n\t\t<Card padding=\"md\" radius=\"md\" withBorder style={{ borderColor: `var(--mantine-color-${getEntityColor(entity.type)}-5)`, borderWidth: 2 }}>\n\t\t\t<Group align=\"flex-start\" gap=\"md\" mb=\"xs\">\n\t\t\t\t<ThemeIcon size=\"xl\" color={getEntityColor(entity.type)} variant=\"light\">\n\t\t\t\t\t{getEntityIcon(entity.type, 24)}\n\t\t\t\t</ThemeIcon>\n\t\t\t\t<Stack gap=\"xs\" style={{ flex: 1 }}>\n\t\t\t\t\t<Group gap=\"xs\" wrap=\"wrap\">\n\t\t\t\t\t\t<Badge color={getEntityColor(entity.type)} variant=\"light\" size=\"sm\">\n\t\t\t\t\t\t\t{entity.type.replace(/s$/, \"\").toUpperCase()}\n\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t{getNodeYear(entity) && (\n\t\t\t\t\t\t\t<Badge variant=\"light\" color=\"gray\" size=\"sm\">\n\t\t\t\t\t\t\t\t{getNodeYear(entity)}\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{getNodeOpenAccess(entity) && (\n\t\t\t\t\t\t\t<Badge variant=\"light\" color=\"green\" size=\"sm\">\n\t\t\t\t\t\t\t\tOpen Access\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Group>\n\t\t\t\t\t<Title order={4} size=\"sm\" style={{ wordWrap: \"break-word\" }} data-testid=\"rich-entity-display-title\">\n\t\t\t\t\t\t{entity.label}\n\t\t\t\t\t</Title>\n\t\t\t\t\t{getNodeCitationCount(entity) !== undefined && (\n\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t<IconQuote size={14} />\n\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t{formatNumber(getNodeCitationCount(entity) || 0)} citations\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t)}\n\t\t\t\t</Stack>\n\t\t\t</Group>\n\n\t\t\t<Text\n\t\t\t\tsize=\"xs\"\n\t\t\t\tc=\"dimmed\"\n\t\t\t\tff=\"monospace\"\n\t\t\t\tp=\"xs\"\n\t\t\t\tbg=\"gray.0\"\n\t\t\t\tstyle={{ borderRadius: 4, wordBreak: \"break-all\", marginTop: 8 }}\n\t\t\t>\n\t\t\t\t{entity.entityId}\n\t\t\t</Text>\n\t\t</Card>\n\t);\n\n\treturn (\n\t\t<Stack gap=\"md\">\n\t\t\t<BasicInfoCard />\n\n\t\t\t{!isLoading && rawData && (\n\t\t\t\t<>\n\t\t\t\t\t{entity.type === \"works\" && <WorksDisplay work={rawData} />}\n\t\t\t\t\t{entity.type === \"authors\" && <AuthorsDisplay author={rawData} />}\n\t\t\t\t\t{entity.type === \"institutions\" && <InstitutionsDisplay institution={rawData} />}\n\t\t\t\t\t{/* Add more entity types as needed */}\n\t\t\t\t</>\n\t\t\t)}\n\n\t\t\t{isLoading && (\n\t\t\t\t<Card padding=\"md\" radius=\"md\" withBorder>\n\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t<IconClock size={16} />\n\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">Loading detailed information...</Text>\n\t\t\t\t\t</Group>\n\t\t\t\t</Card>\n\t\t\t)}\n\t\t</Stack>\n\t);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/search/DateRangeFilter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/search/SearchInterface.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":108,"column":27,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":108,"endColumn":29,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2753,2755],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from \"react\";\nimport { Group, TextInput, Button, Stack, Paper, Title } from \"@mantine/core\";\nimport { IconSearch, IconFilter } from \"@tabler/icons-react\";\nimport { DateRangeFilter } from \"./DateRangeFilter\";\nimport { debouncedSearch, normalizeSearchQuery, isValidSearchQuery } from \"@academic-explorer/utils\";\n\ninterface SearchFilters {\n  query: string;\n  startDate: Date | null;\n  endDate: Date | null;\n}\n\ninterface SearchInterfaceProps {\n  onSearch: (filters: SearchFilters) => void;\n  isLoading?: boolean;\n  placeholder?: string;\n  showDateFilter?: boolean;\n}\n\nexport function SearchInterface({\n\tonSearch,\n\tisLoading = false,\n\tplaceholder = \"Search academic works, authors, institutions...\",\n\tshowDateFilter = true,\n}: SearchInterfaceProps) {\n\tconst [query, setQuery] = useState(\"\");\n\tconst [startDate, setStartDate] = useState<Date | null>(null);\n\tconst [endDate, setEndDate] = useState<Date | null>(null);\n\tconst [isAdvancedOpen, setIsAdvancedOpen] = useState(false);\n\n\tconst handleSearch = useCallback(() => {\n\t\tconst filters: SearchFilters = {\n\t\t\tquery: isValidSearchQuery(query) ? normalizeSearchQuery(query) : \"\",\n\t\t\tstartDate,\n\t\t\tendDate,\n\t\t};\n\n\t\tonSearch(filters);\n\t}, [query, startDate, endDate, onSearch]);\n\n\tconst handleQueryChange = useCallback((value: string) => {\n\t\tsetQuery(value);\n\n\t\t// Only trigger debounced search if we have a valid query\n\t\tif (isValidSearchQuery(value)) {\n\t\t\tdebouncedSearch(() => {\n\t\t\t\tconst filters: SearchFilters = {\n\t\t\t\t\tquery: normalizeSearchQuery(value),\n\t\t\t\t\tstartDate,\n\t\t\t\t\tendDate,\n\t\t\t\t};\n\t\t\t\tonSearch(filters);\n\t\t\t}, value);\n\t\t}\n\t}, [startDate, endDate, onSearch]);\n\n\tconst handleClearFilters = () => {\n\t\tsetQuery(\"\");\n\t\tsetStartDate(null);\n\t\tsetEndDate(null);\n\t\tonSearch({\n\t\t\tquery: \"\",\n\t\t\tstartDate: null,\n\t\t\tendDate: null,\n\t\t});\n\t};\n\n\treturn (\n\t\t<Paper p=\"md\" withBorder>\n\t\t\t<Stack gap=\"md\">\n\t\t\t\t<Group>\n\t\t\t\t\t<Title order={3} flex={1}>\n            Search Academic Literature\n\t\t\t\t\t</Title>\n\n\t\t\t\t\t{showDateFilter && (\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tleftSection={<IconFilter size={16} />}\n\t\t\t\t\t\t\tonClick={() => { setIsAdvancedOpen(!isAdvancedOpen); }}\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{isAdvancedOpen ? \"Hide\" : \"Show\"} Filters\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t)}\n\t\t\t\t</Group>\n\n\t\t\t\t<Group align=\"flex-end\">\n\t\t\t\t\t<TextInput\n\t\t\t\t\t\tplaceholder={placeholder}\n\t\t\t\t\t\tleftSection={<IconSearch size={16} />}\n\t\t\t\t\t\tvalue={query}\n\t\t\t\t\t\tonChange={(e) => { handleQueryChange(e.target.value); }}\n\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\tflex={1}\n\t\t\t\t\t\tsize=\"md\"\n\t\t\t\t\t\taria-label=\"Search query input\"\n\t\t\t\t\t/>\n\n\t\t\t\t\t<Button\n\t\t\t\t\t\tonClick={handleSearch}\n\t\t\t\t\t\tloading={isLoading}\n\t\t\t\t\t\tleftSection={<IconSearch size={16} />}\n\t\t\t\t\t>\n            Search\n\t\t\t\t\t</Button>\n\n\t\t\t\t\t{(query || startDate || endDate) && (\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tonClick={handleClearFilters}\n\t\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\t>\n              Clear\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t)}\n\t\t\t\t</Group>\n\n\t\t\t\t{showDateFilter && isAdvancedOpen && (\n\t\t\t\t\t<Group>\n\t\t\t\t\t\t<DateRangeFilter\n\t\t\t\t\t\t\tstartDate={startDate}\n\t\t\t\t\t\t\tendDate={endDate}\n\t\t\t\t\t\t\tonStartDateChange={setStartDate}\n\t\t\t\t\t\t\tonEndDateChange={setEndDate}\n\t\t\t\t\t\t\tdisabled={isLoading}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Group>\n\t\t\t\t)}\n\t\t\t</Stack>\n\t\t</Paper>\n\t);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/AllEdgesSection.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":72,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":72,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3356,3358],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":96,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":96,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4095,4097],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":106,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":106,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4457,4459],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":110,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":110,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4676,4678],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":171,"column":22,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":171,"endColumn":24,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6515,6517],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":185,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":185,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7011,7013],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":364,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":364,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[12065,12067],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * All Edges Section component\n * Displays all edges in the graph with grouping, filtering, and visibility controls\n */\n\nimport React, { useCallback, useMemo, useState } from \"react\";\nimport { Stack, Text, TextInput, Checkbox, Group, Button, ScrollArea, Card, Badge, ActionIcon, Tooltip, Divider, Switch } from \"@mantine/core\";\nimport { IconSearch, IconEyeOff, IconTrash, IconSelectAll, IconX, IconArrowRight, IconTarget } from \"@tabler/icons-react\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphEdge } from \"@academic-explorer/graph\";\nimport { RelationType } from \"@academic-explorer/graph\";\n\nimport {\n\tIconPencil,\n\tIconUsers,\n\tIconBook,\n\tIconCoin,\n\tIconQuote,\n\tIconLink,\n\tIconBuilding,\n\tIconBuildingStore,\n\tIconTag,\n\tIconMapPin,\n\tIconBulb,\n} from \"@tabler/icons-react\";\n\nconst relationTypeOptions = [\n\t{ type: RelationType.AUTHORED, label: \"Authored\", icon: IconPencil, description: \"Author → Work\" },\n\t{ type: RelationType.AFFILIATED, label: \"Affiliated\", icon: IconUsers, description: \"Author → Institution\" },\n\t{ type: RelationType.PUBLISHED_IN, label: \"Published In\", icon: IconBook, description: \"Work → Source\" },\n\t{ type: RelationType.FUNDED_BY, label: \"Funded By\", icon: IconCoin, description: \"Work → Funder\" },\n\t{ type: RelationType.REFERENCES, label: \"References\", icon: IconQuote, description: \"Work → Work\" },\n\t{ type: RelationType.SOURCE_PUBLISHED_BY, label: \"Source Published By\", icon: IconBuildingStore, description: \"Source → Publisher\" },\n\t{ type: RelationType.INSTITUTION_CHILD_OF, label: \"Institution Child Of\", icon: IconBuilding, description: \"Institution → Parent\" },\n\t{ type: RelationType.PUBLISHER_CHILD_OF, label: \"Publisher Child Of\", icon: IconBuildingStore, description: \"Publisher → Parent\" },\n\t{ type: RelationType.WORK_HAS_TOPIC, label: \"Work Has Topic\", icon: IconTag, description: \"Work → Topic\" },\n\t{ type: RelationType.WORK_HAS_KEYWORD, label: \"Work Has Keyword\", icon: IconTag, description: \"Work → Keyword\" },\n\t{ type: RelationType.AUTHOR_RESEARCHES, label: \"Author Researches\", icon: IconBulb, description: \"Author → Topic\" },\n\t{ type: RelationType.INSTITUTION_LOCATED_IN, label: \"Institution Located In\", icon: IconMapPin, description: \"Institution → Location\" },\n\t{ type: RelationType.FUNDER_LOCATED_IN, label: \"Funder Located In\", icon: IconMapPin, description: \"Funder → Location\" },\n\t{ type: RelationType.TOPIC_PART_OF_FIELD, label: \"Topic Part Of Field\", icon: IconBulb, description: \"Topic → Field\" },\n\t{ type: RelationType.RELATED_TO, label: \"Related To\", icon: IconLink, description: \"General relation\" },\n];\n\ninterface EdgeItemProps {\n  edge: GraphEdge;\n  isSelected: boolean;\n  isVisible: boolean;\n  sourceNodeLabel?: string;\n  targetNodeLabel?: string;\n  onSelect: (edgeId: string, selected: boolean) => void;\n  onHighlight: (edgeId: string) => void;\n  onRemove: (edgeId: string) => void;\n}\n\nconst EdgeItem: React.FC<EdgeItemProps> = ({\n\tedge,\n\tisSelected,\n\tisVisible,\n\tsourceNodeLabel,\n\ttargetNodeLabel,\n\tonSelect,\n\tonHighlight,\n\tonRemove,\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\tconst relationTypeOption = relationTypeOptions.find(opt => opt.type === edge.type);\n\tconst IconComponent = relationTypeOption?.icon || IconLink;\n\n\treturn (\n\t\t<Card\n\t\t\tp=\"xs\"\n\t\t\tradius=\"sm\"\n\t\t\twithBorder\n\t\t\tstyle={{\n\t\t\t\topacity: isVisible ? 1 : 0.5,\n\t\t\t\tbackgroundColor: isSelected ? colors.primary + \"20\" : colors.background.secondary,\n\t\t\t\tborderColor: isSelected ? colors.primary : colors.border.primary,\n\t\t\t}}\n\t\t>\n\t\t\t<Group justify=\"space-between\" wrap=\"nowrap\">\n\t\t\t\t<Group gap=\"xs\" style={{ flex: 1, minWidth: 0 }}>\n\t\t\t\t\t<Checkbox\n\t\t\t\t\t\tchecked={isSelected}\n\t\t\t\t\t\tonChange={(event) => { onSelect(edge.id, event.currentTarget.checked); }}\n\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t/>\n\t\t\t\t\t<IconComponent size={16} color={colors.text.secondary} />\n\t\t\t\t\t<div style={{ flex: 1, minWidth: 0 }}>\n\t\t\t\t\t\t<Group gap=\"xs\" mb=\"xs\">\n\t\t\t\t\t\t\t<Text size=\"sm\" fw={500}>\n\t\t\t\t\t\t\t\t{relationTypeOption?.label || edge.type}\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t{edge.weight && (\n\t\t\t\t\t\t\t\t<Badge size=\"xs\" variant=\"light\" color=\"blue\">\n                  Weight: {edge.weight.toFixed(2)}\n\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t<Group gap=\"xs\" align=\"center\">\n\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" truncate style={{ maxWidth: \"80px\" }} title={sourceNodeLabel}>\n\t\t\t\t\t\t\t\t{sourceNodeLabel || edge.source}\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t<IconArrowRight size={12} color={colors.text.secondary} />\n\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" truncate style={{ maxWidth: \"80px\" }} title={targetNodeLabel}>\n\t\t\t\t\t\t\t\t{targetNodeLabel || edge.target}\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t{relationTypeOption?.description && (\n\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" fs=\"italic\">\n\t\t\t\t\t\t\t\t{relationTypeOption.description}\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t</Group>\n\n\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t<Tooltip label=\"Highlight endpoints\">\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tcolor=\"blue\"\n\t\t\t\t\t\t\tonClick={() => { onHighlight(edge.id); }}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconTarget size={14} />\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Tooltip>\n\n\t\t\t\t\t<Tooltip label=\"Remove edge\">\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\t\t\tonClick={() => { onRemove(edge.id); }}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconTrash size={14} />\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Tooltip>\n\t\t\t\t</Group>\n\t\t\t</Group>\n\t\t</Card>\n\t);\n};\n\nexport const AllEdgesSection: React.FC = () => {\n\tconst [searchTerm, setSearchTerm] = useState(\"\");\n\tconst [showOnlyVisible, setShowOnlyVisible] = useState(false);\n\tconst [selectedEdgeIds, setSelectedEdgeIds] = useState<Set<string>>(new Set());\n\n\t// Use stable selectors to avoid React 19 infinite loops\n\tconst edges = useGraphStore((state) => state.edges);\n\tconst nodes = useGraphStore((state) => state.nodes);\n\tconst edgeTypeStats = useGraphStore((state) => state.edgeTypeStats);\n\tconst removeEdge = useGraphStore((state) => state.removeEdge);\n\tconst selectNode = useGraphStore((state) => state.selectNode);\n\tconst addToSelection = useGraphStore((state) => state.addToSelection);\n\tconst clearSelection = useGraphStore((state) => state.clearSelection);\n\n\t// Convert edges record to array\n\tconst edgeArray = useMemo(() => {\n\t\treturn Object.values(edges).filter((edge): edge is GraphEdge => edge !== undefined);\n\t}, [edges]);\n\n\t// Get node labels for display\n\tconst getNodeLabel = useCallback((nodeId: string) => {\n\t\tconst node = nodes[nodeId];\n\t\treturn node?.label || nodeId;\n\t}, [nodes]);\n\n\t// Filter and group edges\n\tconst { filteredEdges, edgesByType } = useMemo(() => {\n\t\tlet filtered = edgeArray;\n\n\t\t// Apply search filter\n\t\tif (searchTerm) {\n\t\t\tconst searchLower = searchTerm.toLowerCase();\n\t\t\tfiltered = filtered.filter(edge => {\n\t\t\t\tconst sourceLabel = getNodeLabel(edge.source).toLowerCase();\n\t\t\t\tconst targetLabel = getNodeLabel(edge.target).toLowerCase();\n\t\t\t\tconst edgeType = edge.type.toLowerCase();\n\t\t\t\tconst edgeLabel = edge.label?.toLowerCase() || \"\";\n\n\t\t\t\treturn sourceLabel.includes(searchLower) ||\n               targetLabel.includes(searchLower) ||\n               edgeType.includes(searchLower) ||\n               edgeLabel.includes(searchLower) ||\n               edge.id.toLowerCase().includes(searchLower);\n\t\t\t});\n\t\t}\n\n\t\t// Apply visibility filter\n\t\tif (showOnlyVisible) {\n\t\t\tfiltered = filtered.filter(edge => {\n\t\t\t\tconst visibleCount = edgeTypeStats.visible[edge.type] || 0;\n\t\t\t\treturn visibleCount > 0;\n\t\t\t});\n\t\t}\n\n\t\t// Group by edge type\n\t\tconst grouped = filtered.reduce<Partial<Record<RelationType, GraphEdge[]>>>((acc, edge) => {\n\t\t\tconst {type} = edge;\n\t\t\tif (!(type in acc)) {\n\t\t\t\tacc[type] = [];\n\t\t\t}\n\t\t\tconst edgeArray = acc[type];\n\t\t\tif (edgeArray) {\n\t\t\t\tedgeArray.push(edge);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\treturn {\n\t\t\tfilteredEdges: filtered,\n\t\t\tedgesByType: grouped\n\t\t};\n\t}, [edgeArray, searchTerm, showOnlyVisible, edgeTypeStats, getNodeLabel]);\n\n\tconst handleSelectEdge = useCallback((edgeId: string, selected: boolean) => {\n\t\tsetSelectedEdgeIds(prev => {\n\t\t\tconst newSet = new Set(prev);\n\t\t\tif (selected) {\n\t\t\t\tnewSet.add(edgeId);\n\t\t\t} else {\n\t\t\t\tnewSet.delete(edgeId);\n\t\t\t}\n\t\t\treturn newSet;\n\t\t});\n\t}, []);\n\n\tconst handleSelectAll = useCallback(() => {\n\t\tif (selectedEdgeIds.size === filteredEdges.length) {\n\t\t\tsetSelectedEdgeIds(new Set());\n\t\t} else {\n\t\t\tsetSelectedEdgeIds(new Set(filteredEdges.map(edge => edge.id)));\n\t\t}\n\t}, [selectedEdgeIds.size, filteredEdges]);\n\n\tconst handleHighlightEdge = useCallback((edgeId: string) => {\n\t\tconst edge = edges[edgeId];\n\t\tif (edge) {\n\t\t\tlogger.debug(\"graph\", \"Highlighting edge endpoints\", {\n\t\t\t\tedgeId,\n\t\t\t\tsource: edge.source,\n\t\t\t\ttarget: edge.target\n\t\t\t});\n\n\t\t\t// Clear previous selection and select both endpoints\n\t\t\tclearSelection();\n\t\t\taddToSelection(edge.source);\n\t\t\taddToSelection(edge.target);\n\n\t\t\t// Set primary selection to source node\n\t\t\tselectNode(edge.source);\n\t\t}\n\t}, [edges, clearSelection, addToSelection, selectNode]);\n\n\tconst handleRemoveEdge = useCallback((edgeId: string) => {\n\t\tlogger.debug(\"graph\", \"Removing edge from AllEdgesSection\", { edgeId });\n\t\tremoveEdge(edgeId);\n\t\tsetSelectedEdgeIds(prev => {\n\t\t\tconst newSet = new Set(prev);\n\t\t\tnewSet.delete(edgeId);\n\t\t\treturn newSet;\n\t\t});\n\t}, [removeEdge]);\n\n\tconst handleBatchActions = useCallback((action: \"highlight\" | \"remove\") => {\n\t\tconst selectedEdges = filteredEdges.filter(edge => selectedEdgeIds.has(edge.id));\n\n\t\tlogger.debug(\"graph\", \"Batch action on edges\", {\n\t\t\taction,\n\t\t\tedgeCount: selectedEdges.length,\n\t\t\tedgeIds: selectedEdges.map(e => e.id)\n\t\t});\n\n\t\tswitch (action) {\n\t\t\tcase \"highlight\": {\n\t\t\t\t// Collect all unique nodes from selected edges\n\t\t\t\tconst nodeIds = new Set<string>();\n\t\t\t\tselectedEdges.forEach(edge => {\n\t\t\t\t\tnodeIds.add(edge.source);\n\t\t\t\t\tnodeIds.add(edge.target);\n\t\t\t\t});\n\n\t\t\t\tclearSelection();\n\t\t\t\tArray.from(nodeIds).forEach(id => { addToSelection(id); });\n\t\t\t\tif (nodeIds.size > 0) {\n\t\t\t\t\tselectNode(Array.from(nodeIds)[0] ?? null);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"remove\":\n\t\t\t\tselectedEdges.forEach(edge => { removeEdge(edge.id); });\n\t\t\t\tsetSelectedEdgeIds(new Set());\n\t\t\t\tbreak;\n\t\t}\n\t}, [selectedEdgeIds, filteredEdges, removeEdge, clearSelection, addToSelection, selectNode]);\n\n\treturn (\n\t\t<Stack gap=\"md\" p=\"md\">\n\t\t\t<div>\n\t\t\t\t<Text fw={600} size=\"lg\">All Edges</Text>\n\t\t\t\t<Text size=\"sm\" c=\"dimmed\">\n\t\t\t\t\t{filteredEdges.length} of {edgeArray.length} edges\n\t\t\t\t\t{selectedEdgeIds.size > 0 && ` (${selectedEdgeIds.size.toString()} selected)`}\n\t\t\t\t</Text>\n\t\t\t</div>\n\n\t\t\t<Stack gap=\"sm\">\n\t\t\t\t<TextInput\n\t\t\t\t\tplaceholder=\"Search edges, nodes, or types...\"\n\t\t\t\t\tvalue={searchTerm}\n\t\t\t\t\tonChange={(event) => { setSearchTerm(event.currentTarget.value); }}\n\t\t\t\t\tleftSection={<IconSearch size={16} />}\n\t\t\t\t\trightSection={\n\t\t\t\t\t\tsearchTerm && (\n\t\t\t\t\t\t\t<ActionIcon size=\"sm\" variant=\"subtle\" onClick={() => { setSearchTerm(\"\"); }}>\n\t\t\t\t\t\t\t\t<IconX size={14} />\n\t\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t/>\n\n\t\t\t\t<Group justify=\"space-between\">\n\t\t\t\t\t<Switch\n\t\t\t\t\t\tlabel=\"Show only visible\"\n\t\t\t\t\t\tchecked={showOnlyVisible}\n\t\t\t\t\t\tonChange={(event) => { setShowOnlyVisible(event.currentTarget.checked); }}\n\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t/>\n\n\t\t\t\t\t<Button\n\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\tleftSection={<IconSelectAll size={14} />}\n\t\t\t\t\t\tonClick={handleSelectAll}\n\t\t\t\t\t>\n\t\t\t\t\t\t{selectedEdgeIds.size === filteredEdges.length ? \"Deselect All\" : \"Select All\"}\n\t\t\t\t\t</Button>\n\t\t\t\t</Group>\n\n\t\t\t\t{selectedEdgeIds.size > 0 && (\n\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">Batch actions:</Text>\n\t\t\t\t\t\t<Button size=\"xs\" variant=\"light\" onClick={() => { handleBatchActions(\"highlight\"); }}>\n              Highlight Endpoints\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button size=\"xs\" variant=\"light\" color=\"red\" onClick={() => { handleBatchActions(\"remove\"); }}>\n              Remove\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</Group>\n\t\t\t\t)}\n\t\t\t</Stack>\n\n\t\t\t<Divider />\n\n\t\t\t<ScrollArea style={{ height: \"calc(100vh - 400px)\" }}>\n\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t{relationTypeOptions.map(({ type, label, icon: IconComponent, description }) => {\n\t\t\t\t\t\tconst typeEdges = edgesByType[type] || [];\n\t\t\t\t\t\tconst totalCount = edgeTypeStats.total[type] || 0;\n\t\t\t\t\t\tconst visibleCount = edgeTypeStats.visible[type] || 0;\n\t\t\t\t\t\tconst isTypeVisible = visibleCount > 0;\n\n\t\t\t\t\t\tif (typeEdges.length === 0) return null;\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={type}>\n\t\t\t\t\t\t\t\t<Group justify=\"space-between\" mb=\"xs\">\n\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<IconComponent size={16} />\n\t\t\t\t\t\t\t\t\t\t<Text fw={500} size=\"sm\">{label}</Text>\n\t\t\t\t\t\t\t\t\t\t<Badge size=\"sm\" variant=\"light\">\n\t\t\t\t\t\t\t\t\t\t\t{typeEdges.length}\n\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t\t\t\t{visibleCount}/{totalCount} visible\n\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t{!isTypeVisible && (\n\t\t\t\t\t\t\t\t\t\t\t<IconEyeOff size={14} color=\"gray\" />\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" mb=\"xs\" fs=\"italic\">\n\t\t\t\t\t\t\t\t\t{description}\n\t\t\t\t\t\t\t\t</Text>\n\n\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t{typeEdges.map(edge => (\n\t\t\t\t\t\t\t\t\t\t<EdgeItem\n\t\t\t\t\t\t\t\t\t\t\tkey={edge.id}\n\t\t\t\t\t\t\t\t\t\t\tedge={edge}\n\t\t\t\t\t\t\t\t\t\t\tisSelected={selectedEdgeIds.has(edge.id)}\n\t\t\t\t\t\t\t\t\t\t\tisVisible={isTypeVisible}\n\t\t\t\t\t\t\t\t\t\t\tsourceNodeLabel={getNodeLabel(edge.source)}\n\t\t\t\t\t\t\t\t\t\t\ttargetNodeLabel={getNodeLabel(edge.target)}\n\t\t\t\t\t\t\t\t\t\t\tonSelect={handleSelectEdge}\n\t\t\t\t\t\t\t\t\t\t\tonHighlight={handleHighlightEdge}\n\t\t\t\t\t\t\t\t\t\t\tonRemove={handleRemoveEdge}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\n\t\t\t\t\t{filteredEdges.length === 0 && (\n\t\t\t\t\t\t<Text ta=\"center\" c=\"dimmed\" py=\"xl\">\n              No edges found\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t)}\n\t\t\t\t</Stack>\n\t\t\t</ScrollArea>\n\t\t</Stack>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/AllNodesSection.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":59,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":59,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2159,2161],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":62,"column":47,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":62,"endColumn":49,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2297,2299],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":89,"column":34,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":89,"endColumn":36,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3141,3143],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":359,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":359,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[10982,10984],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * All Nodes Section component\n * Displays all nodes in the graph with grouping, filtering, and visibility controls\n */\n\nimport React, { useCallback, useMemo, useState } from \"react\";\nimport { Stack, Text, TextInput, Checkbox, Group, Button, ScrollArea, Card, Badge, ActionIcon, Tooltip, Divider, Switch } from \"@mantine/core\";\nimport { IconSearch, IconEyeOff, IconPin, IconPinnedOff, IconGitBranch, IconTrash, IconSelectAll, IconX } from \"@tabler/icons-react\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useGraphData } from \"@/hooks/use-graph-data\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphNode, EntityType } from \"@academic-explorer/graph\";\n\nimport {\n\tIconFile,\n\tIconUser,\n\tIconBook,\n\tIconBuilding,\n\tIconTag,\n\tIconBuildingStore,\n\tIconCoin,\n\tIconBulb,\n} from \"@tabler/icons-react\";\n\nconst entityTypeOptions = [\n\t{ type: \"works\" satisfies EntityType, label: \"Works\", icon: IconFile },\n\t{ type: \"authors\" satisfies EntityType, label: \"Authors\", icon: IconUser },\n\t{ type: \"sources\" satisfies EntityType, label: \"Sources\", icon: IconBook },\n\t{ type: \"institutions\" satisfies EntityType, label: \"Institutions\", icon: IconBuilding },\n\t{ type: \"topics\" satisfies EntityType, label: \"Topics\", icon: IconTag },\n\t{ type: \"publishers\" satisfies EntityType, label: \"Publishers\", icon: IconBuildingStore },\n\t{ type: \"funders\" satisfies EntityType, label: \"Funders\", icon: IconCoin },\n\t{ type: \"concepts\" satisfies EntityType, label: \"Concepts\", icon: IconBulb },\n] as const;\n\ninterface NodeItemProps {\n  node: GraphNode;\n  isSelected: boolean;\n  isVisible: boolean;\n  onSelect: (nodeId: string, selected: boolean) => void;\n  onTogglePin: (nodeId: string) => void;\n  onExpand: (nodeId: string) => void;\n  onRemove: (nodeId: string) => void;\n}\n\nconst NodeItem: React.FC<NodeItemProps> = ({\n\tnode,\n\tisSelected,\n\tisVisible,\n\tonSelect,\n\tonTogglePin,\n\tonExpand,\n\tonRemove,\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\tconst pinnedNodes = useGraphStore((state) => state.pinnedNodes);\n\tconst isPinned = pinnedNodes[node.id] || false;\n\n\tconst entityTypeOption = entityTypeOptions.find(opt => opt.type === node.type);\n\tconst IconComponent = entityTypeOption?.icon || IconFile;\n\n\treturn (\n\t\t<Card\n\t\t\tp=\"xs\"\n\t\t\tradius=\"sm\"\n\t\t\twithBorder\n\t\t\tstyle={{\n\t\t\t\topacity: isVisible ? 1 : 0.5,\n\t\t\t\tbackgroundColor: isSelected ? colors.primary + \"20\" : colors.background.secondary,\n\t\t\t\tborderColor: isSelected ? colors.primary : colors.border.primary,\n\t\t\t}}\n\t\t>\n\t\t\t<Group justify=\"space-between\" wrap=\"nowrap\">\n\t\t\t\t<Group gap=\"xs\" style={{ flex: 1, minWidth: 0 }}>\n\t\t\t\t\t<Checkbox\n\t\t\t\t\t\tchecked={isSelected}\n\t\t\t\t\t\tonChange={(event) => { onSelect(node.id, event.currentTarget.checked); }}\n\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t/>\n\t\t\t\t\t<IconComponent size={16} color={colors.text.secondary} />\n\t\t\t\t\t<div style={{ flex: 1, minWidth: 0 }}>\n\t\t\t\t\t\t<Text size=\"sm\" fw={500} truncate title={node.label}>\n\t\t\t\t\t\t\t{node.label}\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t<Badge size=\"xs\" variant=\"light\" color=\"blue\">\n\t\t\t\t\t\t\t\t{entityTypeOption?.label || node.type}\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t</div>\n\t\t\t\t</Group>\n\n\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t<Tooltip label={isPinned ? \"Unpin node\" : \"Pin node\"}>\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tcolor={isPinned ? \"orange\" : \"gray\"}\n\t\t\t\t\t\t\tonClick={() => { onTogglePin(node.id); }}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{isPinned ? <IconPinnedOff size={14} /> : <IconPin size={14} />}\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Tooltip>\n\n\t\t\t\t\t<Tooltip label=\"Expand node\">\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tcolor=\"green\"\n\t\t\t\t\t\t\tonClick={() => { onExpand(node.id); }}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconGitBranch size={14} />\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Tooltip>\n\n\t\t\t\t\t<Tooltip label=\"Remove node\">\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\t\t\tonClick={() => { onRemove(node.id); }}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconTrash size={14} />\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Tooltip>\n\t\t\t\t</Group>\n\t\t\t</Group>\n\t\t</Card>\n\t);\n};\n\nexport const AllNodesSection: React.FC = () => {\n\tconst [searchTerm, setSearchTerm] = useState(\"\");\n\tconst [showOnlyVisible, setShowOnlyVisible] = useState(false);\n\tconst [selectedNodeIds, setSelectedNodeIds] = useState<Set<string>>(new Set());\n\n\t// Use stable selectors to avoid React 19 infinite loops\n\tconst nodes = useGraphStore((state) => state.nodes);\n\tconst visibleEntityTypes = useGraphStore((state) => state.visibleEntityTypes);\n\tconst entityTypeStats = useGraphStore((state) => state.entityTypeStats);\n\tconst removeNode = useGraphStore((state) => state.removeNode);\n\tconst pinNode = useGraphStore((state) => state.pinNode);\n\tconst unpinNode = useGraphStore((state) => state.unpinNode);\n\tconst addToSelection = useGraphStore((state) => state.addToSelection);\n\tconst selectNode = useGraphStore((state) => state.selectNode);\n\n\tconst { expandNode } = useGraphData();\n\n\t// Convert nodes record to array\n\tconst nodeArray = useMemo(() => {\n\t\treturn Object.values(nodes).filter((node): node is GraphNode => node !== undefined);\n\t}, [nodes]);\n\n\t// Filter and group nodes\n\tconst { filteredNodes, nodesByType } = useMemo(() => {\n\t\tlet filtered = nodeArray;\n\n\t\t// Apply search filter\n\t\tif (searchTerm) {\n\t\t\tconst searchLower = searchTerm.toLowerCase();\n\t\t\tfiltered = filtered.filter(node =>\n\t\t\t\tnode.label.toLowerCase().includes(searchLower) ||\n        node.id.toLowerCase().includes(searchLower)\n\t\t\t);\n\t\t}\n\n\t\t// Apply visibility filter\n\t\tif (showOnlyVisible) {\n\t\t\tfiltered = filtered.filter(node =>\n\t\t\t\tvisibleEntityTypes[node.type]\n\t\t\t);\n\t\t}\n\n\t\t// Group by entity type\n\t\tconst grouped = filtered.reduce<Partial<Record<EntityType, GraphNode[]>>>((acc, node) => {\n\t\t\tconst {type} = node;\n\t\t\tif (!(type in acc)) {\n\t\t\t\tacc[type] = [];\n\t\t\t}\n\t\t\tconst nodeArray = acc[type];\n\t\t\tif (nodeArray) {\n\t\t\t\tnodeArray.push(node);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\treturn {\n\t\t\tfilteredNodes: filtered,\n\t\t\tnodesByType: grouped\n\t\t};\n\t}, [nodeArray, searchTerm, showOnlyVisible, visibleEntityTypes]);\n\n\tconst handleSelectNode = useCallback((nodeId: string, selected: boolean) => {\n\t\tsetSelectedNodeIds(prev => {\n\t\t\tconst newSet = new Set(prev);\n\t\t\tif (selected) {\n\t\t\t\tnewSet.add(nodeId);\n\t\t\t} else {\n\t\t\t\tnewSet.delete(nodeId);\n\t\t\t}\n\t\t\treturn newSet;\n\t\t});\n\t}, []);\n\n\tconst handleSelectAll = useCallback(() => {\n\t\tif (selectedNodeIds.size === filteredNodes.length) {\n\t\t\tsetSelectedNodeIds(new Set());\n\t\t} else {\n\t\t\tsetSelectedNodeIds(new Set(filteredNodes.map(node => node.id)));\n\t\t}\n\t}, [selectedNodeIds.size, filteredNodes]);\n\n\tconst handleTogglePin = useCallback((nodeId: string) => {\n\t\tconst {pinnedNodes} = useGraphStore.getState();\n\t\tif (pinnedNodes[nodeId]) {\n\t\t\tunpinNode(nodeId);\n\t\t} else {\n\t\t\tpinNode(nodeId);\n\t\t}\n\t}, [pinNode, unpinNode]);\n\n\tconst handleExpandNode = useCallback(async (nodeId: string) => {\n\t\ttry {\n\t\t\tlogger.debug(\"graph\", \"Expanding node from AllNodesSection\", { nodeId });\n\t\t\tawait expandNode(nodeId, {\n\t\t\t\tdepth: 1,\n\t\t\t\tlimit: 10,\n\t\t\t\tforce: false\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error(\"graph\", \"Failed to expand node from AllNodesSection\", {\n\t\t\t\tnodeId,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t});\n\t\t}\n\t}, [expandNode]);\n\n\tconst handleRemoveNode = useCallback((nodeId: string) => {\n\t\tlogger.debug(\"graph\", \"Removing node from AllNodesSection\", { nodeId });\n\t\tremoveNode(nodeId);\n\t\tsetSelectedNodeIds(prev => {\n\t\t\tconst newSet = new Set(prev);\n\t\t\tnewSet.delete(nodeId);\n\t\t\treturn newSet;\n\t\t});\n\t}, [removeNode]);\n\n\tconst handleBatchActions = useCallback((action: \"pin\" | \"unpin\" | \"expand\" | \"remove\" | \"select\") => {\n\t\tconst selectedNodes = filteredNodes.filter(node => selectedNodeIds.has(node.id));\n\n\t\tlogger.debug(\"graph\", \"Batch action on nodes\", {\n\t\t\taction,\n\t\t\tnodeCount: selectedNodes.length,\n\t\t\tnodeIds: selectedNodes.map(n => n.id)\n\t\t});\n\n\t\tswitch (action) {\n\t\t\tcase \"pin\":\n\t\t\t\tselectedNodes.forEach(node => { pinNode(node.id); });\n\t\t\t\tbreak;\n\t\t\tcase \"unpin\":\n\t\t\t\tselectedNodes.forEach(node => { unpinNode(node.id); });\n\t\t\t\tbreak;\n\t\t\tcase \"expand\":\n\t\t\t\tselectedNodes.forEach(node => {\n\t\t\t\t\thandleExpandNode(node.id).catch((error: unknown) => {\n\t\t\t\t\t\tlogger.error(\"graph\", \"Batch expand failed for node\", {\n\t\t\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"remove\":\n\t\t\t\tselectedNodes.forEach(node => { removeNode(node.id); });\n\t\t\t\tsetSelectedNodeIds(new Set());\n\t\t\t\tbreak;\n\t\t\tcase \"select\":\n\t\t\t\tselectedNodes.forEach(node => { addToSelection(node.id); });\n\t\t\t\tif (selectedNodes.length > 0) {\n\t\t\t\t\tselectNode(selectedNodes[0]?.id ?? null);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}, [selectedNodeIds, filteredNodes, pinNode, unpinNode, removeNode, addToSelection, selectNode, handleExpandNode]);\n\n\treturn (\n\t\t<Stack gap=\"md\" p=\"md\">\n\t\t\t<div>\n\t\t\t\t<Text fw={600} size=\"lg\">All Nodes</Text>\n\t\t\t\t<Text size=\"sm\" c=\"dimmed\">\n\t\t\t\t\t{filteredNodes.length} of {nodeArray.length} nodes\n\t\t\t\t\t{selectedNodeIds.size > 0 && ` (${selectedNodeIds.size.toString()} selected)`}\n\t\t\t\t</Text>\n\t\t\t</div>\n\n\t\t\t<Stack gap=\"sm\">\n\t\t\t\t<TextInput\n\t\t\t\t\tplaceholder=\"Search nodes...\"\n\t\t\t\t\tvalue={searchTerm}\n\t\t\t\t\tonChange={(event) => { setSearchTerm(event.currentTarget.value); }}\n\t\t\t\t\tleftSection={<IconSearch size={16} />}\n\t\t\t\t\trightSection={\n\t\t\t\t\t\tsearchTerm && (\n\t\t\t\t\t\t\t<ActionIcon size=\"sm\" variant=\"subtle\" onClick={() => { setSearchTerm(\"\"); }}>\n\t\t\t\t\t\t\t\t<IconX size={14} />\n\t\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t/>\n\n\t\t\t\t<Group justify=\"space-between\">\n\t\t\t\t\t<Switch\n\t\t\t\t\t\tlabel=\"Show only visible\"\n\t\t\t\t\t\tchecked={showOnlyVisible}\n\t\t\t\t\t\tonChange={(event) => { setShowOnlyVisible(event.currentTarget.checked); }}\n\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t/>\n\n\t\t\t\t\t<Button\n\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\tleftSection={<IconSelectAll size={14} />}\n\t\t\t\t\t\tonClick={handleSelectAll}\n\t\t\t\t\t>\n\t\t\t\t\t\t{selectedNodeIds.size === filteredNodes.length ? \"Deselect All\" : \"Select All\"}\n\t\t\t\t\t</Button>\n\t\t\t\t</Group>\n\n\t\t\t\t{selectedNodeIds.size > 0 && (\n\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">Batch actions:</Text>\n\t\t\t\t\t\t<Button size=\"xs\" variant=\"light\" onClick={() => { handleBatchActions(\"pin\"); }}>\n              Pin\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button size=\"xs\" variant=\"light\" onClick={() => { handleBatchActions(\"unpin\"); }}>\n              Unpin\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button size=\"xs\" variant=\"light\" onClick={() => { handleBatchActions(\"expand\"); }}>\n              Expand\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button size=\"xs\" variant=\"light\" onClick={() => { handleBatchActions(\"select\"); }}>\n              Select in Graph\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button size=\"xs\" variant=\"light\" color=\"red\" onClick={() => { handleBatchActions(\"remove\"); }}>\n              Remove\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</Group>\n\t\t\t\t)}\n\t\t\t</Stack>\n\n\t\t\t<Divider />\n\n\t\t\t<ScrollArea style={{ height: \"calc(100vh - 400px)\" }}>\n\t\t\t\t<Stack gap=\"md\">\n\t\t\t\t\t{entityTypeOptions.map(({ type, label, icon: IconComponent }) => {\n\t\t\t\t\t\tconst typeNodes = nodesByType[type] || [];\n\t\t\t\t\t\tconst totalCount = entityTypeStats.total[type] || 0;\n\t\t\t\t\t\tconst visibleCount = entityTypeStats.visible[type] || 0;\n\t\t\t\t\t\tconst isTypeVisible = visibleEntityTypes[type];\n\n\t\t\t\t\t\tif (typeNodes.length === 0) return null;\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={type}>\n\t\t\t\t\t\t\t\t<Group justify=\"space-between\" mb=\"xs\">\n\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<IconComponent size={16} />\n\t\t\t\t\t\t\t\t\t\t<Text fw={500} size=\"sm\">{label}</Text>\n\t\t\t\t\t\t\t\t\t\t<Badge size=\"sm\" variant=\"light\">\n\t\t\t\t\t\t\t\t\t\t\t{typeNodes.length}\n\t\t\t\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t\t\t\t\t\t{visibleCount}/{totalCount} visible\n\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t{!isTypeVisible && (\n\t\t\t\t\t\t\t\t\t\t\t<IconEyeOff size={14} color=\"gray\" />\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t</Group>\n\n\t\t\t\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t\t\t\t{typeNodes.map(node => (\n\t\t\t\t\t\t\t\t\t\t<NodeItem\n\t\t\t\t\t\t\t\t\t\t\tkey={node.id}\n\t\t\t\t\t\t\t\t\t\t\tnode={node}\n\t\t\t\t\t\t\t\t\t\t\tisSelected={selectedNodeIds.has(node.id)}\n\t\t\t\t\t\t\t\t\t\t\tisVisible={isTypeVisible}\n\t\t\t\t\t\t\t\t\t\t\tonSelect={handleSelectNode}\n\t\t\t\t\t\t\t\t\t\t\tonTogglePin={handleTogglePin}\n\t\t\t\t\t\t\t\t\t\t\tonExpand={(nodeId: string) => { void handleExpandNode(nodeId); }}\n\t\t\t\t\t\t\t\t\t\t\tonRemove={handleRemoveNode}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\n\t\t\t\t\t{filteredNodes.length === 0 && (\n\t\t\t\t\t\t<Text ta=\"center\" c=\"dimmed\" py=\"xl\">\n              No nodes found\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t)}\n\t\t\t\t</Stack>\n\t\t\t</ScrollArea>\n\t\t</Stack>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/AppActivitySection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/CacheSettingsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/CustomForcesSection.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":68,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":68,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1519,1521],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":77,"column":44,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":77,"endColumn":46,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1813,1815],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":83,"column":44,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":83,"endColumn":46,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2056,2058],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":91,"column":46,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":91,"endColumn":48,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2369,2371],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":100,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":100,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2713,2715],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":118,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":118,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3365,3367],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":119,"column":82,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":119,"endColumn":84,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3453,3455],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":134,"column":47,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":134,"endColumn":49,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4050,4052],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":141,"column":47,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":141,"endColumn":49,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4349,4351],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":148,"column":68,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":148,"endColumn":70,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4631,4633],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":168,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":168,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5493,5495],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":178,"column":46,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":178,"endColumn":48,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5817,5819],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":195,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":195,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6407,6409],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":196,"column":81,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":196,"endColumn":83,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6494,6496],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":208,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":208,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6952,6954],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":216,"column":69,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":216,"endColumn":71,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7248,7250],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":653,"column":40,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":653,"endColumn":89},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":654,"column":33,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":654,"endColumn":73}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Custom Forces Section\n * Sidebar tool for managing and configuring custom forces in the graph layout\n */\n\nimport React, { useState, useCallback } from \"react\";\nimport {\n  Stack,\n  Text,\n  Button,\n  ActionIcon,\n  Group,\n  Select,\n  NumberInput,\n  Switch,\n  Slider,\n  Divider,\n  Card,\n  Badge,\n  Tooltip,\n  Alert,\n  Modal,\n  Collapse,\n  JsonInput,\n  TextInput,\n} from \"@mantine/core\";\nimport {\n  IconWaveSquare,\n  IconPlus,\n  IconTrash,\n  IconChevronDown,\n  IconInfoCircle,\n  IconTemplate,\n} from \"@tabler/icons-react\";\nimport { useDisclosure } from \"@mantine/hooks\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { customForceManager } from \"@academic-explorer/graph\";\nimport type {\n  CustomForce,\n  CustomForceType,\n  CustomForceConfig,\n  RadialForceConfig,\n  PropertyForceConfig,\n  ClusterForceConfig,\n  RepulsionForceConfig,\n  AttractionForceConfig,\n  OrbitForceConfig,\n} from \"@academic-explorer/graph\";\n\n/**\n * Force type configuration forms\n */\ninterface ForceConfigFormProps {\n  config: CustomForceConfig;\n  onChange: (config: CustomForceConfig) => void;\n}\n\nconst RadialConfigForm: React.FC<ForceConfigFormProps> = ({ config, onChange }) => {\n  const isRadialConfig = (cfg: CustomForceConfig): cfg is RadialForceConfig => cfg['type'] === \"radial\";\n  if (!isRadialConfig(config)) return null;\n  const radialConfig = config;\n\n  return (\n    <Stack gap=\"sm\">\n      <NumberInput\n        label=\"Radius\"\n        description=\"Target radius for radial layout\"\n        value={radialConfig.radius || 200}\n        onChange={(value) => { onChange({ ...radialConfig, radius: typeof value === \"number\" ? value : 200 }); }}\n        min={50}\n        max={500}\n        step={10}\n      />\n      <Group grow>\n        <NumberInput\n          label=\"Center X\"\n          value={(radialConfig['centerX']) || 0}\n          onChange={(value) => { onChange({ ...radialConfig, centerX: typeof value === \"number\" ? value : 0 }); }}\n          step={10}\n        />\n        <NumberInput\n          label=\"Center Y\"\n          value={(radialConfig['centerY']) || 0}\n          onChange={(value) => { onChange({ ...radialConfig, centerY: typeof value === \"number\" ? value : 0 }); }}\n          step={10}\n        />\n      </Group>\n      <NumberInput\n        label=\"Inner Radius (optional)\"\n        description=\"For annular layouts\"\n        value={(radialConfig['innerRadius']) || 0}\n        onChange={(value) => { onChange({ ...radialConfig, innerRadius: typeof value === \"number\" ? value : 0 }); }}\n        min={0}\n        max={400}\n        step={10}\n      />\n      <Switch\n        label=\"Even Distribution\"\n        description=\"Distribute nodes evenly around circle\"\n        checked={(radialConfig['evenDistribution']) || false}\n        onChange={(event) => { onChange({ ...radialConfig, evenDistribution: event.currentTarget.checked }); }}\n      />\n    </Stack>\n  );\n};\n\nconst PropertyConfigForm: React.FC<ForceConfigFormProps> = ({ config, onChange }) => {\n  const isPropertyConfig = (cfg: CustomForceConfig): cfg is PropertyForceConfig =>\n    cfg['type'] === \"property-x\" || cfg['type'] === \"property-y\";\n  if (!isPropertyConfig(config)) return null;\n  const propertyConfig = config;\n\n  return (\n    <Stack gap=\"sm\">\n      <Select\n        label=\"Property Name\"\n        description=\"Node property to use for positioning\"\n        value={(propertyConfig['propertyName']) || \"\"}\n        onChange={(value) => { onChange({ ...propertyConfig, propertyName: value || \"\" }); }}\n        data={[\n          { value: \"publication_year\", label: \"Publication Year\" },\n          { value: \"cited_by_count\", label: \"Citation Count\" },\n          { value: \"works_count\", label: \"Works Count\" },\n          { value: \"h_index\", label: \"H-Index\" },\n          { value: \"i10_index\", label: \"i10 Index\" },\n          { value: \"two_yr_mean_citedness\", label: \"2-Year Mean Citedness\" },\n        ]}\n        searchable\n      />\n      <Group grow>\n        <NumberInput\n          label=\"Min Value\"\n          description=\"Minimum coordinate\"\n          value={(propertyConfig['minValue']) || -400}\n          onChange={(value) => { onChange({ ...propertyConfig, minValue: typeof value === \"number\" ? value : -400 }); }}\n          step={10}\n        />\n        <NumberInput\n          label=\"Max Value\"\n          description=\"Maximum coordinate\"\n          value={(propertyConfig['maxValue']) || 400}\n          onChange={(value) => { onChange({ ...propertyConfig, maxValue: typeof value === \"number\" ? value : 400 }); }}\n          step={10}\n        />\n      </Group>\n      <Select\n        label=\"Scale Type\"\n        value={(propertyConfig['scaleType'] as string | undefined) || \"linear\"}\n        onChange={(value) => {\n          const validScaleTypes = [\"linear\", \"log\", \"sqrt\", \"pow\"] as const;\n          const isValidScaleType = (val: string | null): val is typeof validScaleTypes[number] => {\n            if (val === null) return false;\n            return validScaleTypes.some(type => type === val);\n          };\n          const scaleType = isValidScaleType(value) ? value : \"linear\";\n          onChange({ ...propertyConfig, scaleType });\n        }}\n        data={[\n          { value: \"linear\", label: \"Linear\" },\n          { value: \"log\", label: \"Logarithmic\" },\n          { value: \"sqrt\", label: \"Square Root\" },\n          { value: \"pow\", label: \"Power\" },\n        ]}\n      />\n      {propertyConfig['scaleType'] === \"pow\" && (\n        <NumberInput\n          label=\"Scale Exponent\"\n          value={(propertyConfig['scaleExponent']) || 2}\n          onChange={(value) => { onChange({ ...propertyConfig, scaleExponent: typeof value === \"number\" ? value : 2 }); }}\n          min={0.1}\n          max={5}\n          step={0.1}\n          decimalScale={1}\n        />\n      )}\n      <Switch\n        label=\"Reverse Scale\"\n        checked={(propertyConfig['reverse']) || false}\n        onChange={(event) => { onChange({ ...propertyConfig, reverse: event.currentTarget.checked }); }}\n      />\n    </Stack>\n  );\n};\n\nconst ClusterConfigForm: React.FC<ForceConfigFormProps> = ({ config, onChange }) => {\n  const isClusterConfig = (cfg: CustomForceConfig): cfg is ClusterForceConfig => cfg['type'] === \"cluster\";\n  if (!isClusterConfig(config)) return null;\n  const clusterConfig = config;\n\n  return (\n    <Stack gap=\"sm\">\n      <Select\n        label=\"Property Name\"\n        description=\"Property to group nodes by\"\n        value={(clusterConfig['propertyName']) || \"\"}\n        onChange={(value) => { onChange({ ...clusterConfig, propertyName: value || \"\" }); }}\n        data={[\n          { value: \"type\", label: \"Entity Type\" },\n          { value: \"institution_id\", label: \"Institution\" },\n          { value: \"primary_topic\", label: \"Primary Topic\" },\n          { value: \"publication_year\", label: \"Publication Year\" },\n        ]}\n        searchable\n      />\n      <NumberInput\n        label=\"Cluster Spacing\"\n        description=\"Distance between cluster centers\"\n        value={(clusterConfig['spacing']) || 150}\n        onChange={(value) => { onChange({ ...clusterConfig, spacing: typeof value === \"number\" ? value : 150 }); }}\n        min={50}\n        max={500}\n        step={10}\n      />\n      <Select\n        label=\"Arrangement\"\n        value={(clusterConfig['arrangement'] as string | undefined) || \"circular\"}\n        onChange={(value) => {\n          const validArrangements = [\"grid\", \"circular\", \"random\"] as const;\n          const isValidArrangement = (val: string | null): val is typeof validArrangements[number] => {\n            if (val === null) return false;\n            return validArrangements.some(arrangement => arrangement === val);\n          };\n          const arrangement = isValidArrangement(value) ? value : \"circular\";\n          onChange({ ...clusterConfig, arrangement });\n        }}\n        data={[\n          { value: \"circular\", label: \"Circular\" },\n          { value: \"grid\", label: \"Grid\" },\n          { value: \"random\", label: \"Random\" },\n        ]}\n      />\n    </Stack>\n  );\n};\n\n/**\n * Force configuration form component\n */\nconst ForceConfigForm: React.FC<ForceConfigFormProps> = ({ config, onChange }) => {\n  switch (config['type']) {\n    case \"radial\":\n      return <RadialConfigForm config={config} onChange={onChange} />;\n    case \"property-x\":\n    case \"property-y\":\n      return <PropertyConfigForm config={config} onChange={onChange} />;\n    case \"cluster\":\n      return <ClusterConfigForm config={config} onChange={onChange} />;\n    default:\n      return (\n        <JsonInput\n          label=\"Configuration\"\n          description=\"Raw JSON configuration\"\n          value={JSON.stringify(config, null, 2)}\n          onChange={(value) => {\n            try {\n              const parsed: unknown = JSON.parse(value);\n              // Type guard to ensure parsed value matches CustomForceConfig structure\n              const isValidConfig = (obj: unknown): obj is CustomForceConfig =>\n                typeof obj === \"object\" && obj !== null && \"type\" in obj;\n              if (isValidConfig(parsed)) {\n                onChange(parsed);\n              }\n            } catch {\n              // Invalid JSON, ignore\n            }\n          }}\n          autosize\n          minRows={4}\n          maxRows={10}\n        />\n      );\n  }\n};\n\n/**\n * Individual force item component\n */\ninterface ForceItemProps {\n  force: CustomForce;\n  onUpdate: (updates: Partial<CustomForce>) => void;\n  onRemove: () => void;\n}\n\nconst ForceItem: React.FC<ForceItemProps> = ({ force, onUpdate, onRemove }) => {\n  const [opened, { toggle }] = useDisclosure(false);\n\n  const handleConfigChange = useCallback((config: CustomForceConfig) => {\n    onUpdate({ config });\n  }, [onUpdate]);\n\n  return (\n    <Card withBorder>\n      <Stack gap=\"sm\">\n        {/* Force Header */}\n        <Group justify=\"space-between\">\n          <Group gap=\"sm\">\n            <Switch\n              checked={force.enabled}\n              onChange={(event) => { onUpdate({ enabled: event.currentTarget.checked }); }}\n              size=\"sm\"\n            />\n            <div>\n              <Text size=\"sm\" fw={500}>{force.name}</Text>\n              <Badge size=\"xs\" variant=\"light\">{force.type}</Badge>\n            </div>\n          </Group>\n          <Group gap=\"xs\">\n            <ActionIcon\n              variant=\"subtle\"\n              size=\"sm\"\n              onClick={toggle}\n            >\n              <IconChevronDown\n                size={14}\n                style={{\n                  transform: opened ? \"rotate(180deg)\" : \"rotate(0deg)\",\n                  transition: \"transform 0.2s ease\",\n                }}\n              />\n            </ActionIcon>\n            <ActionIcon\n              variant=\"subtle\"\n              size=\"sm\"\n              color=\"red\"\n              onClick={onRemove}\n            >\n              <IconTrash size={14} />\n            </ActionIcon>\n          </Group>\n        </Group>\n\n        {/* Force Strength Slider */}\n        <div>\n          <Text size=\"xs\" mb={4}>Strength: {force.strength.toFixed(2)}</Text>\n          <Slider\n            value={force.strength}\n            onChange={(value) => { onUpdate({ strength: value }); }}\n            min={0}\n            max={1}\n            step={0.01}\n            size=\"sm\"\n          />\n        </div>\n\n        {/* Force Configuration */}\n        <Collapse in={opened}>\n          <Stack gap=\"sm\">\n            <Divider />\n            <NumberInput\n              label=\"Priority\"\n              description=\"Force application order (higher = later)\"\n              value={force.priority}\n              onChange={(value) => { onUpdate({ priority: typeof value === \"number\" ? value : 0 }); }}\n              min={0}\n              max={100}\n              step={1}\n              size=\"sm\"\n            />\n            <ForceConfigForm\n              config={force.config}\n              onChange={handleConfigChange}\n            />\n          </Stack>\n        </Collapse>\n      </Stack>\n    </Card>\n  );\n};\n\n/**\n * Custom Forces Section Component\n */\nexport const CustomForcesSection: React.FC = () => {\n  const [forces, setForces] = useState<CustomForce[]>([]);\n  const [addModalOpened, { open: openAddModal, close: closeAddModal }] = useDisclosure(false);\n  const [presetModalOpened, { open: openPresetModal, close: closePresetModal }] = useDisclosure(false);\n  const [newForceType, setNewForceType] = useState<CustomForceType>(\"radial\");\n  const [newForceName, setNewForceName] = useState(\"\");\n\n  // Load forces on component mount\n  React.useEffect(() => {\n    const loadForces = () => {\n      setForces(customForceManager.getAllForces());\n    };\n\n    loadForces();\n\n    // Set up periodic refresh (since we don't have events from the manager)\n    const interval = setInterval(loadForces, 1000);\n    return () => { clearInterval(interval); };\n  }, []);\n\n  const handleAddForce = useCallback(() => {\n    if (!newForceName.trim()) return;\n\n    try {\n      // Create default config based on force type\n      let defaultConfig: CustomForceConfig;\n\n      switch (newForceType) {\n        case \"radial\":\n          defaultConfig = {\n            type: \"radial\",\n            radius: 200,\n            centerX: 0,\n            centerY: 0,\n            evenDistribution: true,\n          } satisfies RadialForceConfig;\n          break;\n        case \"property-x\":\n          defaultConfig = {\n            type: \"property-x\",\n            propertyName: \"publication_year\",\n            minValue: -400,\n            maxValue: 400,\n            scaleType: \"linear\",\n          } satisfies PropertyForceConfig;\n          break;\n        case \"property-y\":\n          defaultConfig = {\n            type: \"property-y\",\n            propertyName: \"cited_by_count\",\n            minValue: -300,\n            maxValue: 300,\n            scaleType: \"log\",\n          } satisfies PropertyForceConfig;\n          break;\n        case \"cluster\":\n          defaultConfig = {\n            type: \"cluster\",\n            propertyName: \"type\",\n            spacing: 150,\n            arrangement: \"circular\",\n          } satisfies ClusterForceConfig;\n          break;\n        case \"repulsion\":\n          defaultConfig = {\n            type: \"repulsion\",\n            maxDistance: 100,\n            minDistance: 10,\n            falloff: \"quadratic\",\n          } satisfies RepulsionForceConfig;\n          break;\n        case \"attraction\":\n          defaultConfig = {\n            type: \"attraction\",\n            attractorSelector: () => true,\n            maxDistance: 200,\n            falloff: \"linear\",\n          } satisfies AttractionForceConfig;\n          break;\n        case \"orbit\":\n          defaultConfig = {\n            type: \"orbit\",\n            centerSelector: () => true,\n            radius: 100,\n            speed: 0.01,\n            direction: \"clockwise\",\n          } satisfies OrbitForceConfig;\n          break;\n        default: {\n          // Fallback for unknown force types - this should never happen with proper typing\n          // Create a minimal config that matches the CustomForceConfig union type\n          const minimalConfig: RadialForceConfig = {\n            type: \"radial\", // Safe fallback to a known type\n            radius: 100,\n          };\n          defaultConfig = minimalConfig;\n        }\n      }\n\n      const forceId = customForceManager.addForce({\n        name: newForceName,\n        type: newForceType,\n        enabled: true,\n        strength: 0.5,\n        priority: forces.length,\n        config: defaultConfig,\n      });\n\n      logger.debug(\"graph\", \"Custom force added via UI\", { forceId, type: newForceType, name: newForceName });\n\n      setNewForceName(\"\");\n      setNewForceType(\"radial\");\n      closeAddModal();\n      setForces(customForceManager.getAllForces());\n    } catch (error) {\n      logger.error(\"graph\", \"Failed to add custom force\", { error });\n    }\n  }, [newForceName, newForceType, forces.length, closeAddModal]);\n\n  const handleUpdateForce = useCallback((forceId: string, updates: Partial<CustomForce>) => {\n    customForceManager.updateForce(forceId, updates);\n    setForces(customForceManager.getAllForces());\n  }, []);\n\n  const handleRemoveForce = useCallback((forceId: string) => {\n    customForceManager.removeForce(forceId);\n    setForces(customForceManager.getAllForces());\n  }, []);\n\n  const handleLoadPreset = useCallback((presetId: string) => {\n    const presets = customForceManager.getBuiltInPresets();\n    const preset = presets[presetId];\n\n    if (preset) {\n      customForceManager.loadPreset(preset);\n      setForces(customForceManager.getAllForces());\n      closePresetModal();\n      logger.debug(\"graph\", \"Force preset loaded\", { presetId, name: preset.name });\n    }\n  }, [closePresetModal]);\n\n  const handleClearAll = useCallback(() => {\n    customForceManager.clearAllForces();\n    setForces([]);\n    logger.debug(\"graph\", \"All custom forces cleared\");\n  }, []);\n\n  const handleAddQuickForce = useCallback((type: \"year-citation\" | \"radial\" | \"institution\") => {\n    try {\n      let force: CustomForce;\n      switch (type) {\n        case \"year-citation\":\n          force = {\n            name: \"Year Citation Force\",\n            type: \"property-x\",\n            enabled: true,\n            strength: 0.1,\n            priority: 1,\n            config: {\n              type: \"property-x\",\n              propertyName: \"publication_year\",\n              scaleType: \"linear\"\n            }\n          };\n          break;\n        case \"radial\":\n          force = {\n            name: \"Radial Force\",\n            type: \"radial\",\n            enabled: true,\n            strength: 0.1,\n            priority: 1,\n            config: {\n              type: \"radial\",\n              radius: 100\n            }\n          };\n          break;\n        case \"institution\":\n          force = {\n            name: \"Institution Cluster Force\",\n            type: \"cluster\",\n            enabled: true,\n            strength: 0.1,\n            priority: 1,\n            config: {\n              type: \"cluster\",\n              propertyName: \"institution\",\n              arrangement: \"circular\"\n            }\n          };\n          break;\n      }\n      customForceManager.addForce(force);\n      setForces(customForceManager.getAllForces());\n      logger.debug(\"graph\", \"Quick force added\", { type });\n    } catch (error) {\n      logger.error(\"graph\", \"Failed to add quick force\", { error, type });\n    }\n  }, []);\n\n  const stats = customForceManager.getStats();\n\n  return (\n    <Stack gap=\"md\">\n      {/* Header */}\n      <Group justify=\"space-between\">\n        <div>\n          <Text size=\"sm\" fw={500}>Custom Forces</Text>\n          <Text size=\"xs\" c=\"dimmed\">\n            {stats.enabledForces}/{stats.totalForces} active\n          </Text>\n        </div>\n        <Tooltip label=\"Configure custom graph forces\">\n          <IconWaveSquare size={16} />\n        </Tooltip>\n      </Group>\n\n      {/* Quick Actions */}\n      <Group grow>\n        <Button\n          variant=\"light\"\n          size=\"xs\"\n          leftSection={<IconPlus size={12} />}\n          onClick={openAddModal}\n        >\n          Add Force\n        </Button>\n        <Button\n          variant=\"light\"\n          size=\"xs\"\n          leftSection={<IconTemplate size={12} />}\n          onClick={openPresetModal}\n        >\n          Presets\n        </Button>\n      </Group>\n\n      {/* Quick Force Buttons */}\n      <Stack gap=\"xs\">\n        <Text size=\"xs\" fw={500} c=\"dimmed\">QUICK FORCES</Text>\n        <Group grow>\n          <Button\n            variant=\"default\"\n            size=\"xs\"\n            onClick={() => { handleAddQuickForce(\"year-citation\"); }}\n          >\n            Year/Citation\n          </Button>\n          <Button\n            variant=\"default\"\n            size=\"xs\"\n            onClick={() => { handleAddQuickForce(\"radial\"); }}\n          >\n            Radial\n          </Button>\n        </Group>\n        <Button\n          variant=\"default\"\n          size=\"xs\"\n          fullWidth\n          onClick={() => { handleAddQuickForce(\"institution\"); }}\n        >\n          Institution Clusters\n        </Button>\n      </Stack>\n\n      <Divider />\n\n      {/* Forces List */}\n      {forces.length === 0 ? (\n        <Alert icon={<IconInfoCircle size={16} />} color=\"blue\">\n          No custom forces active. Add forces to enhance your graph layout.\n        </Alert>\n      ) : (\n        <Stack gap=\"sm\">\n          {forces.map((force) => (\n            <ForceItem\n              key={force.id}\n              force={force}\n              onUpdate={(updates) => { force.id && handleUpdateForce(force.id, updates); }}\n              onRemove={() => { force.id && handleRemoveForce(force.id); }}\n            />\n          ))}\n        </Stack>\n      )}\n\n      {/* Management Actions */}\n      {forces.length > 0 && (\n        <>\n          <Divider />\n          <Group justify=\"center\">\n            <Button\n              variant=\"light\"\n              size=\"xs\"\n              color=\"red\"\n              leftSection={<IconTrash size={12} />}\n              onClick={handleClearAll}\n            >\n              Clear All\n            </Button>\n          </Group>\n        </>\n      )}\n\n      {/* Add Force Modal */}\n      <Modal\n        opened={addModalOpened}\n        onClose={closeAddModal}\n        title=\"Add Custom Force\"\n        size=\"md\"\n      >\n        <Stack gap=\"md\">\n          <Select\n            label=\"Force Type\"\n            value={newForceType}\n            onChange={(value) => {\n              const validForceTypes: CustomForceType[] = [\"radial\", \"property-x\", \"property-y\", \"cluster\", \"repulsion\", \"attraction\", \"orbit\"];\n              const isValidForceType = (val: string | null): val is CustomForceType => {\n                if (val === null) return false;\n                return validForceTypes.some(type => type === val);\n              };\n              const forceType = isValidForceType(value) ? value : \"radial\";\n              setNewForceType(forceType);\n            }}\n            data={[\n              { value: \"radial\", label: \"Radial Layout\" },\n              { value: \"property-x\", label: \"Property-based X Position\" },\n              { value: \"property-y\", label: \"Property-based Y Position\" },\n              { value: \"cluster\", label: \"Cluster by Property\" },\n              { value: \"repulsion\", label: \"Custom Repulsion\" },\n              { value: \"attraction\", label: \"Custom Attraction\" },\n              { value: \"orbit\", label: \"Orbital Motion\" },\n            ]}\n          />\n          <TextInput\n            label=\"Force Name\"\n            placeholder=\"Enter a descriptive name\"\n            value={newForceName}\n            onChange={(event) => { setNewForceName(event.currentTarget.value); }}\n          />\n          <Group justify=\"flex-end\">\n            <Button variant=\"default\" onClick={closeAddModal}>\n              Cancel\n            </Button>\n            <Button onClick={handleAddForce} disabled={!newForceName.trim()}>\n              Add Force\n            </Button>\n          </Group>\n        </Stack>\n      </Modal>\n\n      {/* Preset Modal */}\n      <Modal\n        opened={presetModalOpened}\n        onClose={closePresetModal}\n        title=\"Load Force Preset\"\n        size=\"md\"\n      >\n        <Stack gap=\"md\">\n          {Object.entries(customForceManager.getBuiltInPresets()).map(([id, preset]) => (\n            <Card key={id} withBorder p=\"md\">\n              <Stack gap=\"sm\">\n                <div>\n                  <Text size=\"sm\" fw={500}>{preset.name}</Text>\n                  <Text size=\"xs\" c=\"dimmed\">{preset.description}</Text>\n                  <Badge size=\"xs\" mt={4}>{preset.forces.length} forces</Badge>\n                </div>\n                <Button\n                  variant=\"light\"\n                  size=\"xs\"\n                  onClick={() => { handleLoadPreset(id); }}\n                >\n                  Load Preset\n                </Button>\n              </Stack>\n            </Card>\n          ))}\n        </Stack>\n      </Modal>\n    </Stack>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/EdgeFiltersSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/EdgeRepositorySection.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":51,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":51,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2498,2500],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":52,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":52,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2549,2551],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Edge Repository Section component\n * Displays repository edges that can be dragged into the graph\n */\n\nimport React, { useCallback, useMemo } from \"react\";\nimport { Stack, Text, Checkbox, Group, Button, ScrollArea, Card, Badge, ActionIcon, Tooltip } from \"@mantine/core\";\nimport { IconSelectAll, IconX, IconTrash, IconDragDrop, IconArrowRight, IconBulb } from \"@tabler/icons-react\";\nimport { useRepositoryStore } from \"@/stores/repository-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphEdge } from \"@academic-explorer/graph\";\nimport { RelationType } from \"@academic-explorer/graph\";\n\nconst edgeTypeOptions = [\n\t{ type: RelationType.AUTHORED, label: \"Authored\", color: \"#3498db\" },\n\t{ type: RelationType.AFFILIATED, label: \"Affiliated\", color: \"#2ecc71\" },\n\t{ type: RelationType.PUBLISHED_IN, label: \"Published In\", color: \"#e74c3c\" },\n\t{ type: RelationType.FUNDED_BY, label: \"Funded By\", color: \"#f39c12\" },\n\t{ type: RelationType.REFERENCES, label: \"References\", color: \"#9b59b6\" },\n\t{ type: RelationType.RELATED_TO, label: \"Related To\", color: \"#95a5a6\" },\n\t{ type: RelationType.SOURCE_PUBLISHED_BY, label: \"Source Published By\", color: \"#e67e22\" },\n\t{ type: RelationType.INSTITUTION_CHILD_OF, label: \"Institution Child Of\", color: \"#1abc9c\" },\n\t{ type: RelationType.PUBLISHER_CHILD_OF, label: \"Publisher Child Of\", color: \"#34495e\" },\n\t{ type: RelationType.WORK_HAS_TOPIC, label: \"Work Has Topic\", color: \"#8e44ad\" },\n\t{ type: RelationType.WORK_HAS_KEYWORD, label: \"Work Has Keyword\", color: \"#27ae60\" },\n\t{ type: RelationType.AUTHOR_RESEARCHES, label: \"Author Researches\", color: \"#2980b9\" },\n\t{ type: RelationType.INSTITUTION_LOCATED_IN, label: \"Institution Located In\", color: \"#c0392b\" },\n\t{ type: RelationType.FUNDER_LOCATED_IN, label: \"Funder Located In\", color: \"#d35400\" },\n\t{ type: RelationType.TOPIC_PART_OF_FIELD, label: \"Topic Part Of Field\", color: \"#7f8c8d\" },\n];\n\ninterface EdgeRepositoryItemProps {\n  edge: GraphEdge;\n  isSelected: boolean;\n  onSelect: (edgeId: string, selected: boolean) => void;\n  onRemove: (edgeId: string) => void;\n}\n\nconst EdgeRepositoryItem: React.FC<EdgeRepositoryItemProps> = ({\n\tedge,\n\tisSelected,\n\tonSelect,\n\tonRemove,\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Get display info for edge type\n\tconst edgeOption = edgeTypeOptions.find(option => option.type === edge.type);\n\tconst edgeColor = edgeOption?.color || \"#95a5a6\";\n\tconst edgeLabel = edgeOption?.label || edge.type;\n\n\tconst handleDragStart = useCallback((event: React.DragEvent) => {\n\t\t// Store edge data for drop handler\n\t\tevent.dataTransfer.setData(\"application/json\", JSON.stringify({\n\t\t\ttype: \"repository-edge\",\n\t\t\tedge\n\t\t}));\n\t\tevent.dataTransfer.effectAllowed = \"copy\";\n\n\t\tlogger.debug(\"repository\", \"Started dragging repository edge\", {\n\t\t\tedgeId: edge.id,\n\t\t\tedgeType: edge.type,\n\t\t\tsource: edge.source,\n\t\t\ttarget: edge.target\n\t\t});\n\t}, [edge]);\n\n\tconst handleCheckboxChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n\t\tonSelect(edge.id, event.currentTarget.checked);\n\t}, [edge.id, onSelect]);\n\n\tconst handleRemove = useCallback(() => {\n\t\tonRemove(edge.id);\n\t}, [edge.id, onRemove]);\n\n\treturn (\n\t\t<Card\n\t\t\tpadding=\"xs\"\n\t\t\twithBorder\n\t\t\tstyle={{\n\t\t\t\tcursor: \"grab\",\n\t\t\t\tbackgroundColor: isSelected ? colors.primary + \"20\" : colors.background.primary,\n\t\t\t\tborderColor: isSelected ? colors.primary : colors.border.primary,\n\t\t\t\tmarginBottom: \"4px\",\n\t\t\t}}\n\t\t\tdraggable=\"true\"\n\t\t\tonDragStart={handleDragStart}\n\t\t>\n\t\t\t<Group gap=\"xs\" wrap=\"nowrap\">\n\t\t\t\t<Checkbox\n\t\t\t\t\tchecked={isSelected}\n\t\t\t\t\tonChange={handleCheckboxChange}\n\t\t\t\t\tsize=\"sm\"\n\t\t\t\t/>\n\n\t\t\t\t<div style={{ flex: 1, minWidth: 0 }}>\n\t\t\t\t\t<Group gap=\"xs\" wrap=\"nowrap\">\n\t\t\t\t\t\t<Text size=\"xs\" style={{ color: colors.text.secondary }} truncate>\n\t\t\t\t\t\t\t{edge.source}\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t<IconArrowRight size={12} style={{ color: edgeColor, flexShrink: 0 }} />\n\t\t\t\t\t\t<Text size=\"xs\" style={{ color: colors.text.secondary }} truncate>\n\t\t\t\t\t\t\t{edge.target}\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t</Group>\n\t\t\t\t\t<Text size=\"xs\" style={{ color: edgeColor, fontWeight: 500 }}>\n\t\t\t\t\t\t{edgeLabel}\n\t\t\t\t\t</Text>\n\t\t\t\t</div>\n\n\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t<Tooltip label=\"Drag to graph\">\n\t\t\t\t\t\t<div style={{ color: colors.text.tertiary }}>\n\t\t\t\t\t\t\t<IconDragDrop size={14} />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</Tooltip>\n\n\t\t\t\t\t<Tooltip label=\"Remove from repository\">\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\t\t\tonClick={handleRemove}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconTrash size={12} />\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Tooltip>\n\t\t\t\t</Group>\n\t\t\t</Group>\n\t\t</Card>\n\t);\n};\n\nexport const EdgeRepositorySection: React.FC = () => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Repository store\n\tconst repositoryStore = useRepositoryStore();\n\tconst {edgeTypeFilter} = repositoryStore;\n\tconst {selectedRepositoryEdges} = repositoryStore;\n\tconst {setEdgeTypeFilter} = repositoryStore;\n\tconst {selectRepositoryEdge} = repositoryStore;\n\tconst {selectAllEdges} = repositoryStore;\n\tconst {clearAllSelections} = repositoryStore;\n\tconst {removeFromRepository} = repositoryStore;\n\tconst {getFilteredEdges} = repositoryStore;\n\tconst {getSelectedEdges} = repositoryStore;\n\tconst {recomputeFilteredEdges} = repositoryStore;\n\n\t// Get filtered edges (stable reference from store)\n\tconst filteredEdges = useMemo(() => {\n\t\t// Trigger recomputation to ensure cache is fresh\n\t\trecomputeFilteredEdges();\n\t\treturn getFilteredEdges();\n\t}, [getFilteredEdges, recomputeFilteredEdges]);\n\n\tconst selectedEdges = useMemo(() => {\n\t\treturn getSelectedEdges();\n\t}, [getSelectedEdges]);\n\n\tconst handleTypeFilterChange = useCallback((relationType: RelationType, checked: boolean) => {\n\t\tsetEdgeTypeFilter(relationType, checked);\n\t}, [setEdgeTypeFilter]);\n\n\tconst handleSelectAll = useCallback(() => {\n\t\tselectAllEdges();\n\t}, [selectAllEdges]);\n\n\tconst handleClearSelection = useCallback(() => {\n\t\tclearAllSelections();\n\t}, [clearAllSelections]);\n\n\tconst handleRemoveSelected = useCallback(() => {\n\t\tconst selectedEdgeIds = Object.keys(selectedRepositoryEdges);\n\t\tif (selectedEdgeIds.length > 0) {\n\t\t\tremoveFromRepository([], selectedEdgeIds);\n\t\t\tlogger.debug(\"repository\", \"Removed selected edges from repository\", {\n\t\t\t\tremovedCount: selectedEdgeIds.length\n\t\t\t});\n\t\t}\n\t}, [selectedRepositoryEdges, removeFromRepository]);\n\n\tconst handleRemoveEdge = useCallback((edgeId: string) => {\n\t\tremoveFromRepository([], [edgeId]);\n\t\tlogger.debug(\"repository\", \"Removed single edge from repository\", { edgeId });\n\t}, [removeFromRepository]);\n\n\treturn (\n\t\t<Stack gap=\"sm\" style={{ height: \"100%\", overflow: \"hidden\" }}>\n\t\t\t{/* Type filters */}\n\t\t\t<Stack gap=\"xs\">\n\t\t\t\t<Text size=\"sm\" style={{ fontWeight: 500, color: colors.text.primary }}>\n          Filter by type:\n\t\t\t\t</Text>\n\t\t\t\t<ScrollArea style={{ maxHeight: \"200px\" }}>\n\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t{edgeTypeOptions.map(option => {\n\t\t\t\t\t\t\tconst isChecked = edgeTypeFilter[option.type];\n\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Checkbox\n\t\t\t\t\t\t\t\t\tkey={option.type}\n\t\t\t\t\t\t\t\t\tchecked={isChecked}\n\t\t\t\t\t\t\t\t\tonChange={(event) => { handleTypeFilterChange(option.type, event.currentTarget.checked); }}\n\t\t\t\t\t\t\t\t\tlabel={\n\t\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\t\twidth: \"12px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\theight: \"12px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: option.color,\n\t\t\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"2px\",\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\">{option.label}</Text>\n\t\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</Stack>\n\t\t\t\t</ScrollArea>\n\t\t\t</Stack>\n\n\t\t\t{/* Selection controls */}\n\t\t\t<Group gap=\"xs\">\n\t\t\t\t<Button\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tleftSection={<IconSelectAll size={14} />}\n\t\t\t\t\tonClick={handleSelectAll}\n\t\t\t\t\tdisabled={filteredEdges.length === 0}\n\t\t\t\t>\n          All\n\t\t\t\t</Button>\n\n\t\t\t\t<Button\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tleftSection={<IconX size={14} />}\n\t\t\t\t\tonClick={handleClearSelection}\n\t\t\t\t\tdisabled={selectedEdges.length === 0}\n\t\t\t\t>\n          None\n\t\t\t\t</Button>\n\n\t\t\t\t<Button\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\tleftSection={<IconTrash size={14} />}\n\t\t\t\t\tonClick={handleRemoveSelected}\n\t\t\t\t\tdisabled={selectedEdges.length === 0}\n\t\t\t\t>\n          Remove\n\t\t\t\t</Button>\n\t\t\t</Group>\n\n\t\t\t{/* Results summary */}\n\t\t\t<Group gap=\"xs\" justify=\"space-between\">\n\t\t\t\t<Text size=\"xs\" style={{ color: colors.text.secondary }}>\n\t\t\t\t\t{filteredEdges.length} edge{filteredEdges.length !== 1 ? \"s\" : \"\"}\n\t\t\t\t</Text>\n\t\t\t\t{selectedEdges.length > 0 && (\n\t\t\t\t\t<Badge size=\"xs\" color=\"blue\">\n\t\t\t\t\t\t{selectedEdges.length} selected\n\t\t\t\t\t</Badge>\n\t\t\t\t)}\n\t\t\t</Group>\n\n\t\t\t{/* Edge list */}\n\t\t\t<ScrollArea style={{ flex: 1 }}>\n\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t{filteredEdges.length === 0 ? (\n\t\t\t\t\t\t<Text size=\"sm\" style={{ color: colors.text.tertiary, textAlign: \"center\", padding: \"20px\" }}>\n              No edges in repository.\n              Edges are added when expanding nodes.\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t) : (\n\t\t\t\t\t\tfilteredEdges.map(edge => (\n\t\t\t\t\t\t\t<EdgeRepositoryItem\n\t\t\t\t\t\t\t\tkey={edge.id}\n\t\t\t\t\t\t\t\tedge={edge}\n\t\t\t\t\t\t\t\tisSelected={selectedRepositoryEdges[edge.id] ?? false}\n\t\t\t\t\t\t\t\tonSelect={selectRepositoryEdge}\n\t\t\t\t\t\t\t\tonRemove={handleRemoveEdge}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))\n\t\t\t\t\t)}\n\t\t\t\t</Stack>\n\t\t\t</ScrollArea>\n\n\t\t\t{/* Drag instructions */}\n\t\t\t{filteredEdges.length > 0 && (\n\t\t\t\t<Group justify=\"center\" gap=\"xs\" style={{ padding: \"8px\" }}>\n\t\t\t\t\t<IconBulb size={12} style={{ color: colors.text.tertiary }} />\n\t\t\t\t\t<Text size=\"xs\" style={{ color: colors.text.tertiary }}>\n            Drag edges to the graph to add them\n\t\t\t\t\t</Text>\n\t\t\t\t</Group>\n\t\t\t)}\n\t\t</Stack>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/EntityFiltersSection.tsx","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":116,"column":29,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":116,"endColumn":59},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":130,"column":23,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":130,"endColumn":54}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Entity filters section component\n * Extracted from LeftSidebar for dynamic section system\n */\n\nimport React, { useMemo } from \"react\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { EntityType } from \"@academic-explorer/client\";\nimport { Checkbox, Badge, Stack } from \"@mantine/core\";\nimport {\n\tIconFile,\n\tIconUser,\n\tIconBook,\n\tIconBuilding,\n\tIconTag,\n\tIconBuildingStore,\n\tIconCoin,\n\tIconBulb,\n} from \"@tabler/icons-react\";\n\n// Properly typed entity options without type assertions\nconst entityTypeOptions: Array<{ type: EntityType; label: string; icon: React.ComponentType<{ size?: number; style?: React.CSSProperties }> }> = [\n\t{ type: \"works\", label: \"Works\", icon: IconFile },\n\t{ type: \"authors\", label: \"Authors\", icon: IconUser },\n\t{ type: \"sources\", label: \"Sources\", icon: IconBook },\n\t{ type: \"institutions\", label: \"Institutions\", icon: IconBuilding },\n\t{ type: \"topics\", label: \"Topics\", icon: IconTag },\n\t{ type: \"publishers\", label: \"Publishers\", icon: IconBuildingStore },\n\t{ type: \"funders\", label: \"Funders\", icon: IconCoin },\n\t{ type: \"concepts\", label: \"Concepts\", icon: IconBulb },\n];\n\nexport const EntityFiltersSection: React.FC = () => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\tconst nodesMap = useGraphStore((state) => state.nodes);\n\tconst setEntityTypeVisibility = useGraphStore((state) => state.setEntityTypeVisibility);\n\tconst visibleEntityTypes = useGraphStore((state) => state.visibleEntityTypes);\n\n\tconst entityStats = useMemo(() => {\n\t\ttry {\n\t\t\tconst nodeValues = Object.values(nodesMap);\n\t\t\tconst nodes = Array.isArray(nodeValues) ? nodeValues : [];\n\n\t\t\t// Initialize counters for all entity types\n\t\t\tconst total: Record<EntityType, number> = {\n\t\t\t\tworks: 0,\n\t\t\t\tauthors: 0,\n\t\t\t\tsources: 0,\n\t\t\t\tinstitutions: 0,\n\t\t\t\ttopics: 0,\n\t\t\t\tconcepts: 0,\n\t\t\t\tpublishers: 0,\n\t\t\t\tfunders: 0,\n\t\t\t\tkeywords: 0\n\t\t\t};\n\t\t\tconst visible: Record<EntityType, number> = {\n\t\t\t\tworks: 0,\n\t\t\t\tauthors: 0,\n\t\t\t\tsources: 0,\n\t\t\t\tinstitutions: 0,\n\t\t\t\ttopics: 0,\n\t\t\t\tconcepts: 0,\n\t\t\t\tpublishers: 0,\n\t\t\t\tfunders: 0,\n\t\t\t\tkeywords: 0\n\t\t\t};\n\n\t\t\t// Count nodes by type\n\t\t\tfor (const node of nodes) {\n\t\t\t\tif (node?.type && node.type in total) {\n\t\t\t\t\tconst nodeType = node.type as EntityType;\n\t\t\t\t\ttotal[nodeType]++;\n\t\t\t\t\t// Note: visibility is handled at the graph level, not per-node\n\t\t\t\t\t// For now, count all nodes as visible\n\t\t\t\t\tvisible[nodeType]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { total, visible };\n\t\t} catch (error) {\n\t\t\tlogger.warn(\"ui\", \"Failed to calculate entity stats\", { error });\n\t\t\tconst emptyTotal: Record<EntityType, number> = {\n\t\t\t\tworks: 0,\n\t\t\t\tauthors: 0,\n\t\t\t\tsources: 0,\n\t\t\t\tinstitutions: 0,\n\t\t\t\ttopics: 0,\n\t\t\t\tconcepts: 0,\n\t\t\t\tpublishers: 0,\n\t\t\t\tfunders: 0,\n\t\t\t\tkeywords: 0\n\t\t\t};\n\t\t\tconst emptyVisible: Record<EntityType, number> = {\n\t\t\t\tworks: 0,\n\t\t\t\tauthors: 0,\n\t\t\t\tsources: 0,\n\t\t\t\tinstitutions: 0,\n\t\t\t\ttopics: 0,\n\t\t\t\tconcepts: 0,\n\t\t\t\tpublishers: 0,\n\t\t\t\tfunders: 0,\n\t\t\t\tkeywords: 0\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\ttotal: emptyTotal,\n\t\t\t\tvisible: emptyVisible,\n\t\t\t};\n\t\t}\n\t}, [nodesMap]);\n\n\tconst handleToggleEntityType = (entityType: EntityType) => {\n\t\tconst currentVisibility = visibleEntityTypes[entityType] ?? false;\n\t\tlogger.debug(\"ui\", `Toggling entity type visibility`, {\n\t\t\tentityType,\n\t\t\tfromVisible: currentVisibility,\n\t\t\ttoVisible: !currentVisibility\n\t\t});\n\t\tsetEntityTypeVisibility(entityType, !currentVisibility);\n\t};\n\n\treturn (\n\t\t<Stack gap=\"xs\">\n\t\t\t{entityTypeOptions.map(option => {\n\t\t\t\tconst totalCount = entityStats.total[option.type] || 0;\n\t\t\t\tconst visibleCount = entityStats.visible[option.type] || 0;\n\t\t\t\tconst isVisible = visibleEntityTypes[option.type] ?? false;\n\t\t\t\tconst Icon = option.icon;\n\n\t\t\t\treturn (\n\t\t\t\t\t<div\n\t\t\t\t\t\tkey={option.type}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\tgap: \"8px\",\n\t\t\t\t\t\t\tpadding: \"6px 8px\",\n\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\tbackgroundColor: isVisible ? \"transparent\" : colors.background.secondary,\n\t\t\t\t\t\t\topacity: isVisible ? 1 : 0.6,\n\t\t\t\t\t\t\ttransition: \"all 0.2s ease\",\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Checkbox\n\t\t\t\t\t\t\tchecked={isVisible}\n\t\t\t\t\t\t\tonChange={() => { handleToggleEntityType(option.type); }}\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\taria-label={`Toggle ${option.label} visibility`}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Icon size={16} style={{ color: colors.text.secondary }} />\n\t\t\t\t\t\t<span style={{\n\t\t\t\t\t\t\tflex: 1,\n\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\tcolor: colors.text.primary\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t{option.label}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<Badge size=\"xs\" variant=\"light\" color={isVisible ? \"blue\" : \"gray\"}>\n\t\t\t\t\t\t\t{visibleCount}/{totalCount}\n\t\t\t\t\t\t</Badge>\n\t\t\t\t\t</div>\n\t\t\t\t);\n\t\t\t})}\n\t\t</Stack>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/EntityInfoSection.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":33,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":33,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1152,1183],"text":"(hoveredNodeId ?? selectedNodeId)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":33,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":33,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1184,1186],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Entity Information Section\n * Displays detailed information about selected or hovered entities\n */\n\nimport React from \"react\";\nimport { IconInfoCircle } from \"@tabler/icons-react\";\nimport { RichEntityDisplay } from \"@/components/molecules/RichEntityDisplay\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface EntityInfoSectionProps {\n\tclassName?: string;\n}\n\nexport const EntityInfoSection: React.FC<EntityInfoSectionProps> = ({\n\tclassName = \"\"\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Get entity to display - priority: hovered > selected > preview\n\tconst hoveredNodeId = useGraphStore((state) => state.hoveredNodeId);\n\tconst selectedNodeId = useGraphStore((state) => state.selectedNodeId);\n\tconst previewEntityId = useLayoutStore((state) => state.previewEntityId);\n\n\t// Get entity data from store\n\tconst nodesMap = useGraphStore((state) => state.nodes);\n\n\t// Determine which entity to show\n\tconst displayEntityId = hoveredNodeId || selectedNodeId || previewEntityId;\n\tconst entityNode = displayEntityId ? nodesMap[displayEntityId] : undefined;\n\n\tReact.useEffect(() => {\n\t\tif (displayEntityId) {\n\t\t\tlogger.debug(\"ui\", \"EntityInfoSection displaying entity\", {\n\t\t\t\tentityId: displayEntityId,\n\t\t\t\tsource: hoveredNodeId ? \"hover\" : selectedNodeId ? \"selection\" : \"preview\",\n\t\t\t\thasNodeData: !!entityNode\n\t\t\t});\n\t\t}\n\t}, [displayEntityId, hoveredNodeId, selectedNodeId, entityNode]);\n\n\tif (!displayEntityId || !entityNode) {\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName={className}\n\t\t\t\tstyle={{\n\t\t\t\t\tpadding: \"24px\",\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\tcolor: colors.text.secondary\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<IconInfoCircle\n\t\t\t\t\tsize={48}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\tmarginBottom: \"12px\"\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t\t<div style={{\n\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\tfontWeight: 500,\n\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t}}>\n\t\t\t\t\tNo Entity Selected\n\t\t\t\t</div>\n\t\t\t\t<div style={{\n\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\topacity: 0.7,\n\t\t\t\t\tlineHeight: 1.4\n\t\t\t\t}}>\n\t\t\t\t\tSelect a node on the graph or hover over one to see detailed information\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\t// Use the GraphNode directly - RichEntityDisplay expects a GraphNode\n\tconst entity = entityNode;\n\n\treturn (\n\t\t<div className={className} style={{ padding: \"16px\" }}>\n\t\t\t<div style={{\n\t\t\t\tfontSize: \"14px\",\n\t\t\t\tfontWeight: 600,\n\t\t\t\tmarginBottom: \"12px\",\n\t\t\t\tcolor: colors.text.primary,\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tgap: \"8px\"\n\t\t\t}}>\n\t\t\t\t<IconInfoCircle size={16} />\n\t\t\t\tEntity Information\n\t\t\t</div>\n\n\t\t\t<RichEntityDisplay entity={entity} />\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/ExternalLinksSection.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":35,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":35,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1296,1327],"text":"(hoveredNodeId ?? selectedNodeId)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":35,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":35,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1328,1330],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4150,4153],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4150,4153],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access ['ids'] on an `any` value.","line":137,"column":76,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":137,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":140,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":140,"endColumn":53},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4247,4250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4247,4250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access ['ids'] on an `any` value.","line":140,"column":32,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":140,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4483,4486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4483,4486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access ['ids'] on an `any` value.","line":148,"column":76,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":148,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":151,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":151,"endColumn":52},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4578,4581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4578,4581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access ['ids'] on an `any` value.","line":151,"column":32,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":151,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * External Links Section\n * Provides links to external resources and services\n */\n\nimport React from \"react\";\nimport { IconExternalLink, IconLink, IconFileText, IconSchool } from \"@tabler/icons-react\";\nimport { Button, Divider, Text } from \"@mantine/core\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { CollapsibleSection } from \"@/components/molecules/CollapsibleSection\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphNode } from \"@academic-explorer/graph\";\n\ninterface ExternalLinksSectionProps {\n\tclassName?: string;\n}\n\nexport const ExternalLinksSection: React.FC<ExternalLinksSectionProps> = ({\n\tclassName = \"\"\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Get entity to display - priority: hovered > selected > preview\n\tconst hoveredNodeId = useGraphStore((state) => state.hoveredNodeId);\n\tconst selectedNodeId = useGraphStore((state) => state.selectedNodeId);\n\tconst previewEntityId = useLayoutStore((state) => state.previewEntityId);\n\n\t// Get entity data from store\n\tconst nodesMap = useGraphStore((state) => state.nodes);\n\n\t// Determine which entity to show\n\tconst displayEntityId = hoveredNodeId || selectedNodeId || previewEntityId;\n\tconst entityNode = displayEntityId ? nodesMap[displayEntityId] : undefined;\n\n\tconst handleLinkClick = (url: string, linkType: string) => {\n\t\tlogger.debug(\"ui\", `Opening external link: ${linkType}`, {\n\t\t\turl,\n\t\t\tentityId: displayEntityId,\n\t\t\tlinkType\n\t\t});\n\t\twindow.open(url, \"_blank\", \"noopener,noreferrer\");\n\t};\n\n\t// Type guards for safe URL handling\n\tconst isString = (value: unknown): value is string => {\n\t\treturn typeof value === \"string\" && value.length > 0;\n\t};\n\n\tconst isValidUrl = (value: unknown): value is string => {\n\t\tif (!isString(value)) return false;\n\t\ttry {\n\t\t\tnew URL(value);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tconst isIdsRecord = (value: unknown): value is Record<string, unknown> => {\n\t\treturn value !== null && typeof value === \"object\" && !Array.isArray(value);\n\t};\n\n\tconst generateLinks = (entity: GraphNode) => {\n\t\tconst links: Array<{\n\t\t\tlabel: string;\n\t\t\turl: string;\n\t\t\ticon: React.ReactNode;\n\t\t\tdescription: string;\n\t\t\ttype: string;\n\t\t}> = [];\n\n\t\t// OpenAlex link (always available if we have an entity)\n\t\tif (entity.id) {\n\t\t\tlinks.push({\n\t\t\t\tlabel: \"View in OpenAlex\",\n\t\t\t\turl: `https://openalex.org/${entity.id}`,\n\t\t\t\ticon: <IconSchool size={16} />,\n\t\t\t\tdescription: \"Open in OpenAlex database\",\n\t\t\t\ttype: \"openalex\"\n\t\t\t});\n\t\t}\n\n\t\t// DOI link for works - access entityData safely\n\t\tconst {entityData} = entity;\n\t\tif (entity.type === \"works\" && entityData?.['doi'] && isValidUrl(entityData['doi'])) {\n\t\t\tlinks.push({\n\t\t\t\tlabel: \"DOI Resolver\",\n\t\t\t\turl: entityData['doi'],\n\t\t\t\ticon: <IconFileText size={16} />,\n\t\t\t\tdescription: \"View full article via DOI\",\n\t\t\t\ttype: \"doi\"\n\t\t\t});\n\t\t}\n\n\t\t// ORCID link for authors\n\t\tif (entity.type === \"authors\" && entityData?.['orcid'] && isValidUrl(entityData['orcid'])) {\n\t\t\tlinks.push({\n\t\t\t\tlabel: \"ORCID Profile\",\n\t\t\t\turl: entityData['orcid'],\n\t\t\t\ticon: <IconExternalLink size={16} />,\n\t\t\t\tdescription: \"View ORCID researcher profile\",\n\t\t\t\ttype: \"orcid\"\n\t\t\t});\n\t\t}\n\n\t\t// Homepage/website links\n\t\tif (entityData?.['homepage_url'] && isValidUrl(entityData['homepage_url'])) {\n\t\t\ttry {\n\t\t\t\tconst domain = new URL(entityData['homepage_url']).hostname;\n\t\t\t\tlinks.push({\n\t\t\t\t\tlabel: `Visit ${domain}`,\n\t\t\t\t\turl: entityData['homepage_url'],\n\t\t\t\t\ticon: <IconLink size={16} />,\n\t\t\t\t\tdescription: \"Official website\",\n\t\t\t\t\ttype: \"homepage\"\n\t\t\t\t});\n\t\t\t} catch {\n\t\t\t\t// Invalid URL, skip\n\t\t\t}\n\t\t}\n\n\t\t// Publisher website for sources\n\t\tif (entity.type === \"sources\" && entityData?.['homepage_url'] && isValidUrl(entityData['homepage_url'])) {\n\t\t\tlinks.push({\n\t\t\t\tlabel: \"Publisher Website\",\n\t\t\t\turl: entityData['homepage_url'],\n\t\t\t\ticon: <IconLink size={16} />,\n\t\t\t\tdescription: \"View publisher's website\",\n\t\t\t\ttype: \"publisher\"\n\t\t\t});\n\t\t}\n\n\t\t// Wikipedia link\n\t\tif (isIdsRecord(entityData?.['ids']) && isValidUrl((entityData as any)?.['ids']?.['wikipedia'])) {\n\t\t\tlinks.push({\n\t\t\t\tlabel: \"Wikipedia\",\n\t\t\t\turl: (entityData as any)?.['ids']?.['wikipedia'],\n\t\t\t\ticon: <IconExternalLink size={16} />,\n\t\t\t\tdescription: \"View Wikipedia article\",\n\t\t\t\ttype: \"wikipedia\"\n\t\t\t});\n\t\t}\n\n\t\t// Wikidata link\n\t\tif (isIdsRecord(entityData?.['ids']) && isValidUrl((entityData as any)?.['ids']?.['wikidata'])) {\n\t\t\tlinks.push({\n\t\t\t\tlabel: \"Wikidata\",\n\t\t\t\turl: (entityData as any)?.['ids']?.['wikidata'],\n\t\t\t\ticon: <IconExternalLink size={16} />,\n\t\t\t\tdescription: \"View Wikidata entry\",\n\t\t\t\ttype: \"wikidata\"\n\t\t\t});\n\t\t}\n\n\t\treturn links;\n\t};\n\n\tif (!displayEntityId || !entityNode) {\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName={className}\n\t\t\t\tstyle={{\n\t\t\t\t\tpadding: \"24px\",\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\tcolor: colors.text.secondary\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<IconExternalLink\n\t\t\t\t\tsize={48}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\tmarginBottom: \"12px\"\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t\t<div style={{\n\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\tfontWeight: 500,\n\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t}}>\n\t\t\t\t\tNo Entity Selected\n\t\t\t\t</div>\n\t\t\t\t<div style={{\n\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\topacity: 0.7,\n\t\t\t\t\tlineHeight: 1.4\n\t\t\t\t}}>\n\t\t\t\t\tSelect an entity to view external links and resources\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\tconst links = generateLinks(entityNode);\n\n\tif (links.length === 0) {\n\t\treturn (\n\t\t\t<div className={className} style={{ padding: \"16px\" }}>\n\t\t\t\t<div style={{\n\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\tfontWeight: 600,\n\t\t\t\t\tmarginBottom: \"12px\",\n\t\t\t\t\tcolor: colors.text.primary,\n\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\tgap: \"8px\"\n\t\t\t\t}}>\n\t\t\t\t\t<IconExternalLink size={16} />\n\t\t\t\t\tExternal Links\n\t\t\t\t</div>\n\n\t\t\t\t<div style={{\n\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\tcolor: colors.text.secondary,\n\t\t\t\t\tbackgroundColor: colors.background.secondary,\n\t\t\t\t\tborderRadius: \"8px\"\n\t\t\t\t}}>\n\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">\n\t\t\t\t\t\tNo external links available for this entity\n\t\t\t\t\t</Text>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn (\n\t\t<div className={className} style={{ padding: \"16px\" }}>\n\t\t\t<div style={{\n\t\t\t\tfontSize: \"14px\",\n\t\t\t\tfontWeight: 600,\n\t\t\t\tmarginBottom: \"12px\",\n\t\t\t\tcolor: colors.text.primary,\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tgap: \"8px\"\n\t\t\t}}>\n\t\t\t\t<IconExternalLink size={16} />\n\t\t\t\tExternal Links\n\t\t\t</div>\n\n\t\t\t{/* Academic Resources */}\n\t\t\t<CollapsibleSection\n\t\t\t\ttitle=\"Academic Resources\"\n\t\t\t\ticon={<IconSchool size={14} />}\n\t\t\t\tdefaultExpanded={true}\n\t\t\t\tstorageKey=\"external-links-academic\"\n\t\t\t>\n\t\t\t\t<div style={{ marginTop: \"12px\" }}>\n\t\t\t\t\t{links.filter(link => [\"openalex\", \"doi\", \"orcid\"].includes(link.type)).map((link) => (\n\t\t\t\t\t\t<div key={link.type} style={{ marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\tleftSection={link.icon}\n\t\t\t\t\t\t\t\trightSection={<IconExternalLink size={12} />}\n\t\t\t\t\t\t\t\tonClick={() => { handleLinkClick(link.url, link.type); }}\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\t\t\t\tjustifyContent: \"flex-start\",\n\t\t\t\t\t\t\t\t\theight: \"auto\",\n\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\"\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div style={{ textAlign: \"left\" }}>\n\t\t\t\t\t\t\t\t\t<div style={{ fontWeight: 500 }}>{link.label}</div>\n\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" style={{ marginTop: \"2px\" }}>\n\t\t\t\t\t\t\t\t\t\t{link.description}\n\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</CollapsibleSection>\n\n\t\t\t{links.filter(link => ![\"openalex\", \"doi\", \"orcid\"].includes(link.type)).length > 0 && (\n\t\t\t\t<>\n\t\t\t\t\t<Divider style={{ margin: \"16px 0\" }} />\n\n\t\t\t\t\t{/* Web Resources */}\n\t\t\t\t\t<CollapsibleSection\n\t\t\t\t\t\ttitle=\"Web Resources\"\n\t\t\t\t\t\ticon={<IconLink size={14} />}\n\t\t\t\t\t\tdefaultExpanded={false}\n\t\t\t\t\t\tstorageKey=\"external-links-web\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<div style={{ marginTop: \"12px\" }}>\n\t\t\t\t\t\t\t{links.filter(link => ![\"openalex\", \"doi\", \"orcid\"].includes(link.type)).map((link) => (\n\t\t\t\t\t\t\t\t<div key={link.type} style={{ marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\tleftSection={link.icon}\n\t\t\t\t\t\t\t\t\t\trightSection={<IconExternalLink size={12} />}\n\t\t\t\t\t\t\t\t\t\tonClick={() => { handleLinkClick(link.url, link.type); }}\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\t\t\t\t\t\t\tjustifyContent: \"flex-start\",\n\t\t\t\t\t\t\t\t\t\t\theight: \"auto\",\n\t\t\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\"\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"left\" }}>\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontWeight: 500 }}>{link.label}</div>\n\t\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\" style={{ marginTop: \"2px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t{link.description}\n\t\t\t\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</CollapsibleSection>\n\t\t\t\t</>\n\t\t\t)}\n\n\t\t\t{/* Usage Tips */}\n\t\t\t<div style={{\n\t\t\t\tmarginTop: \"16px\",\n\t\t\t\tpadding: \"12px\",\n\t\t\t\tbackgroundColor: colors.background.secondary,\n\t\t\t\tborderRadius: \"6px\"\n\t\t\t}}>\n\t\t\t\t<Text size=\"xs\" c=\"dimmed\" style={{ marginBottom: \"8px\" }}>\n\t\t\t\t\tTips\n\t\t\t\t</Text>\n\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t• Links open in new tabs for easy reference<br />\n\t\t\t\t\t• Academic resources provide authoritative data<br />\n\t\t\t\t\t• Web resources offer additional context\n\t\t\t\t</Text>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/GraphActionsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/GraphStatsSection.tsx","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":48,"column":25,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":48,"endColumn":49},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":48,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":48,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1798,1800],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":52,"column":21,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":52,"endColumn":23,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1923,1925],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":56,"column":25,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":56,"endColumn":47},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":56,"column":38,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":56,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2040,2042],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":60,"column":19,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":60,"endColumn":21,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2163,2165],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":291,"column":19,"nodeType":"Identifier","messageId":"neverNullish","endLine":291,"endColumn":34},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":301,"column":24,"nodeType":"Identifier","messageId":"neverNullish","endLine":301,"endColumn":39}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Graph Statistics Section\n * Displays comprehensive graph statistics and metrics\n */\n\nimport React, { useMemo } from \"react\";\nimport { IconChartBar, IconCircle, IconLink, IconTrendingUp, IconDownload } from \"@tabler/icons-react\";\nimport { Button, Badge, Progress, Divider } from \"@mantine/core\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { CollapsibleSection } from \"@/components/molecules/CollapsibleSection\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n// Types imported but used indirectly through store types\n\ninterface GraphStatsSectionProps {\n\tclassName?: string;\n}\n\nexport const GraphStatsSection: React.FC<GraphStatsSectionProps> = ({\n\tclassName = \"\"\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Get stats from graph store\n\tconst totalNodeCount = useGraphStore((state) => state.totalNodeCount);\n\tconst totalEdgeCount = useGraphStore((state) => state.totalEdgeCount);\n\tconst entityTypeStats = useGraphStore((state) => state.entityTypeStats);\n\tconst edgeTypeStats = useGraphStore((state) => state.edgeTypeStats);\n\tconst lastSearchStats = useGraphStore((state) => state.lastSearchStats);\n\n\t// Calculate derived metrics\n\tconst networkMetrics = useMemo(() => {\n\t\tconst density = totalNodeCount > 1\n\t\t\t? (2 * totalEdgeCount) / (totalNodeCount * (totalNodeCount - 1))\n\t\t\t: 0;\n\n\t\tconst avgDegree = totalNodeCount > 0 ? (2 * totalEdgeCount) / totalNodeCount : 0;\n\n\t\treturn {\n\t\t\tdensity: Math.round(density * 10000) / 100, // As percentage with 2 decimal places\n\t\t\tavgDegree: Math.round(avgDegree * 100) / 100\n\t\t};\n\t}, [totalNodeCount, totalEdgeCount]);\n\n\t// Top entity types by count\n\tconst topEntityTypes = useMemo(() => {\n\t\treturn Object.entries(entityTypeStats?.visible ?? {})\n\t\t\t.filter(([, count]) => count > 0)\n\t\t\t.sort(([, a], [, b]) => b - a)\n\t\t\t.slice(0, 5);\n\t}, [entityTypeStats?.visible]);\n\n\t// Top edge types by count\n\tconst topEdgeTypes = useMemo(() => {\n\t\treturn Object.entries(edgeTypeStats?.visible ?? {})\n\t\t\t.filter(([, count]) => count > 0)\n\t\t\t.sort(([, a], [, b]) => b - a)\n\t\t\t.slice(0, 5);\n\t}, [edgeTypeStats?.visible]);\n\n\tconst handleExportStats = () => {\n\t\tconst stats = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tnetwork: {\n\t\t\t\tnodes: totalNodeCount,\n\t\t\t\tedges: totalEdgeCount,\n\t\t\t\tdensity: networkMetrics.density,\n\t\t\t\taverageDegree: networkMetrics.avgDegree\n\t\t\t},\n\t\t\tentityTypes: entityTypeStats,\n\t\t\tedgeTypes: edgeTypeStats,\n\t\t\tlastSearch: lastSearchStats\n\t\t};\n\n\t\tconst blob = new Blob([JSON.stringify(stats, null, 2)], { type: \"application/json\" });\n\t\tconst url = URL.createObjectURL(blob);\n\t\tconst a = document.createElement(\"a\");\n\t\ta.href = url;\n\t\ta.download = `graph-stats-${new Date().toISOString().split(\"T\")[0]}.json`;\n\t\tdocument.body.appendChild(a);\n\t\ta.click();\n\t\tdocument.body.removeChild(a);\n\t\tURL.revokeObjectURL(url);\n\n\t\tlogger.debug(\"ui\", \"Graph statistics exported\", {\n\t\t\tnodeCount: totalNodeCount,\n\t\t\tedgeCount: totalEdgeCount\n\t\t});\n\t};\n\n\tconst StatItem: React.FC<{ label: string; value: string | number; icon?: React.ReactNode }> = ({\n\t\tlabel,\n\t\tvalue,\n\t\ticon\n\t}) => (\n\t\t<div style={{\n\t\t\tdisplay: \"flex\",\n\t\t\tjustifyContent: \"space-between\",\n\t\t\talignItems: \"center\",\n\t\t\tpadding: \"8px 0\",\n\t\t\tborderBottom: `1px solid ${colors.border.secondary}`,\n\t\t}}>\n\t\t\t<div style={{\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tgap: \"8px\",\n\t\t\t\tfontSize: \"13px\",\n\t\t\t\tcolor: colors.text.secondary\n\t\t\t}}>\n\t\t\t\t{icon}\n\t\t\t\t{label}\n\t\t\t</div>\n\t\t\t<div style={{\n\t\t\t\tfontSize: \"14px\",\n\t\t\t\tfontWeight: 600,\n\t\t\t\tcolor: colors.text.primary\n\t\t\t}}>\n\t\t\t\t{typeof value === \"number\" && value > 999\n\t\t\t\t\t? value.toLocaleString()\n\t\t\t\t\t: value\n\t\t\t\t}\n\t\t\t</div>\n\t\t</div>\n\t);\n\n\tconst EntityTypeBar: React.FC<{ type: string; count: number; total: number }> = ({\n\t\ttype,\n\t\tcount,\n\t\ttotal\n\t}) => {\n\t\tconst percentage = total > 0 ? (count / total) * 100 : 0;\n\t\treturn (\n\t\t\t<div style={{ marginBottom: \"8px\" }}>\n\t\t\t\t<div style={{\n\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\tjustifyContent: \"space-between\",\n\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\tmarginBottom: \"4px\"\n\t\t\t\t}}>\n\t\t\t\t\t<span style={{ fontSize: \"12px\", textTransform: \"capitalize\" }}>\n\t\t\t\t\t\t{type.replace(\"_\", \" \")}\n\t\t\t\t\t</span>\n\t\t\t\t\t<Badge size=\"xs\" variant=\"light\">\n\t\t\t\t\t\t{count}\n\t\t\t\t\t</Badge>\n\t\t\t\t</div>\n\t\t\t\t<Progress\n\t\t\t\t\tvalue={percentage}\n\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\tcolor=\"blue\"\n\t\t\t\t\tstyle={{ opacity: 0.8 }}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t};\n\n\tif (totalNodeCount === 0) {\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName={className}\n\t\t\t\tstyle={{\n\t\t\t\t\tpadding: \"24px\",\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\tcolor: colors.text.secondary\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<IconChartBar\n\t\t\t\t\tsize={48}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\topacity: 0.3,\n\t\t\t\t\t\tmarginBottom: \"12px\"\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t\t<div style={{\n\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\tfontWeight: 500,\n\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t}}>\n\t\t\t\t\tNo Graph Data\n\t\t\t\t</div>\n\t\t\t\t<div style={{\n\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\topacity: 0.7\n\t\t\t\t}}>\n\t\t\t\t\tSearch for entities to see graph statistics\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn (\n\t\t<div className={className} style={{ padding: \"16px\" }}>\n\t\t\t<div style={{\n\t\t\t\tfontSize: \"14px\",\n\t\t\t\tfontWeight: 600,\n\t\t\t\tmarginBottom: \"16px\",\n\t\t\t\tcolor: colors.text.primary,\n\t\t\t\tdisplay: \"flex\",\n\t\t\t\talignItems: \"center\",\n\t\t\t\tjustifyContent: \"space-between\"\n\t\t\t}}>\n\t\t\t\t<div style={{ display: \"flex\", alignItems: \"center\", gap: \"8px\" }}>\n\t\t\t\t\t<IconChartBar size={16} />\n\t\t\t\t\tGraph Statistics\n\t\t\t\t</div>\n\t\t\t\t<Button\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tleftSection={<IconDownload size={12} />}\n\t\t\t\t\tonClick={handleExportStats}\n\t\t\t\t>\n\t\t\t\t\tExport\n\t\t\t\t</Button>\n\t\t\t</div>\n\n\t\t\t{/* Basic Statistics */}\n\t\t\t<CollapsibleSection\n\t\t\t\ttitle=\"Network Overview\"\n\t\t\t\ticon={<IconTrendingUp size={14} />}\n\t\t\t\tdefaultExpanded={true}\n\t\t\t\tstorageKey=\"graph-stats-network-overview\"\n\t\t\t>\n\t\t\t\t<div style={{ marginTop: \"8px\" }}>\n\t\t\t\t\t<StatItem\n\t\t\t\t\t\tlabel=\"Total Nodes\"\n\t\t\t\t\t\tvalue={totalNodeCount}\n\t\t\t\t\t\ticon={<IconCircle size={14} />}\n\t\t\t\t\t/>\n\t\t\t\t\t<StatItem\n\t\t\t\t\t\tlabel=\"Total Edges\"\n\t\t\t\t\t\tvalue={totalEdgeCount}\n\t\t\t\t\t\ticon={<IconLink size={14} />}\n\t\t\t\t\t/>\n\t\t\t\t\t<StatItem\n\t\t\t\t\t\tlabel=\"Network Density\"\n\t\t\t\t\t\tvalue={`${networkMetrics.density.toString()}%`}\n\t\t\t\t\t\ticon={<IconTrendingUp size={14} />}\n\t\t\t\t\t/>\n\t\t\t\t\t<StatItem\n\t\t\t\t\t\tlabel=\"Avg. Connections\"\n\t\t\t\t\t\tvalue={networkMetrics.avgDegree}\n\t\t\t\t\t\ticon={<IconTrendingUp size={14} />}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</CollapsibleSection>\n\n\t\t\t<Divider style={{ margin: \"16px 0\" }} />\n\n\t\t\t{/* Entity Types Distribution */}\n\t\t\t<CollapsibleSection\n\t\t\t\ttitle={`Entity Types (${topEntityTypes.length.toString()})`}\n\t\t\t\ticon={<IconCircle size={14} />}\n\t\t\t\tdefaultExpanded={false}\n\t\t\t\tstorageKey=\"graph-stats-entity-types\"\n\t\t\t>\n\t\t\t\t<div style={{ marginTop: \"12px\" }}>\n\t\t\t\t\t{topEntityTypes.map(([type, count]) => (\n\t\t\t\t\t\t<EntityTypeBar\n\t\t\t\t\t\t\tkey={type}\n\t\t\t\t\t\t\ttype={type}\n\t\t\t\t\t\t\tcount={count}\n\t\t\t\t\t\t\ttotal={totalNodeCount}\n\t\t\t\t\t\t/>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</CollapsibleSection>\n\n\t\t\t<Divider style={{ margin: \"16px 0\" }} />\n\n\t\t\t{/* Edge Types Distribution */}\n\t\t\t<CollapsibleSection\n\t\t\t\ttitle={`Connection Types (${topEdgeTypes.length.toString()})`}\n\t\t\t\ticon={<IconLink size={14} />}\n\t\t\t\tdefaultExpanded={false}\n\t\t\t\tstorageKey=\"graph-stats-edge-types\"\n\t\t\t>\n\t\t\t\t<div style={{ marginTop: \"12px\" }}>\n\t\t\t\t\t{topEdgeTypes.map(([type, count]) => (\n\t\t\t\t\t\t<EntityTypeBar\n\t\t\t\t\t\t\tkey={type}\n\t\t\t\t\t\t\ttype={type}\n\t\t\t\t\t\t\tcount={count}\n\t\t\t\t\t\t\ttotal={totalEdgeCount}\n\t\t\t\t\t\t/>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</CollapsibleSection>\n\n\t\t\t{/* Search Results Summary */}\n\t\t\t{Object.values(lastSearchStats ?? {}).some(v => v > 0) && (\n\t\t\t\t<>\n\t\t\t\t\t<Divider style={{ margin: \"16px 0\" }} />\n\t\t\t\t\t<CollapsibleSection\n\t\t\t\t\t\ttitle=\"Last Search Results\"\n\t\t\t\t\t\ticon={<IconChartBar size={14} />}\n\t\t\t\t\t\tdefaultExpanded={false}\n\t\t\t\t\t\tstorageKey=\"graph-stats-search-results\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<div style={{ marginTop: \"8px\" }}>\n\t\t\t\t\t\t\t{Object.entries(lastSearchStats ?? {})\n\t\t\t\t\t\t\t\t.filter(([, count]) => count > 0)\n\t\t\t\t\t\t\t\t.map(([type, count]) => (\n\t\t\t\t\t\t\t\t\t<StatItem\n\t\t\t\t\t\t\t\t\t\tkey={type}\n\t\t\t\t\t\t\t\t\t\tlabel={type.replace(\"_\", \" \")}\n\t\t\t\t\t\t\t\t\t\tvalue={count}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</CollapsibleSection>\n\t\t\t\t</>\n\t\t\t)}\n\t\t</div>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/NetworkActivitySection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/NodeRepositorySection.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":54,"column":34,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":54,"endColumn":36,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1966,1968],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":106,"column":28,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":106,"endColumn":30,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3444,3446],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Node Repository Section component\n * Displays repository nodes that can be dragged into the graph\n */\n\nimport React, { useCallback, useMemo } from \"react\";\nimport { Stack, Text, TextInput, Checkbox, Group, Button, ScrollArea, Card, Badge, ActionIcon, Tooltip } from \"@mantine/core\";\nimport { IconSearch, IconTrash, IconDragDrop, IconSelectAll, IconX } from \"@tabler/icons-react\";\nimport { useRepositoryStore } from \"@/stores/repository-store\";\nimport { useThemeColors } from \"@/hooks/use-theme-colors\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphNode, EntityType } from \"@academic-explorer/graph\";\nimport {\n\tIconFile,\n\tIconUser,\n\tIconBook,\n\tIconBuilding,\n\tIconTag,\n\tIconBuildingStore,\n\tIconCoin,\n\tIconBulb,\n} from \"@tabler/icons-react\";\n\n// Properly typed entity options without type assertions\nconst entityTypeOptions: Array<{ type: EntityType; label: string; icon: React.ComponentType<{ size?: number; style?: React.CSSProperties }> }> = [\n\t{ type: \"works\", label: \"Works\", icon: IconFile },\n\t{ type: \"authors\", label: \"Authors\", icon: IconUser },\n\t{ type: \"sources\", label: \"Sources\", icon: IconBook },\n\t{ type: \"institutions\", label: \"Institutions\", icon: IconBuilding },\n\t{ type: \"topics\", label: \"Topics\", icon: IconTag },\n\t{ type: \"publishers\", label: \"Publishers\", icon: IconBuildingStore },\n\t{ type: \"funders\", label: \"Funders\", icon: IconCoin },\n\t{ type: \"concepts\", label: \"Concepts\", icon: IconBulb },\n];\n\ninterface NodeRepositoryItemProps {\n  node: GraphNode;\n  isSelected: boolean;\n  onSelect: (nodeId: string, selected: boolean) => void;\n  onRemove: (nodeId: string) => void;\n}\n\nconst NodeRepositoryItem: React.FC<NodeRepositoryItemProps> = ({\n\tnode,\n\tisSelected,\n\tonSelect,\n\tonRemove,\n}) => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Get icon for entity type\n\tconst entityOption = entityTypeOptions.find(option => option.type === node.type);\n\tconst Icon = entityOption?.icon || IconFile;\n\n\tconst handleDragStart = useCallback((event: React.DragEvent) => {\n\t\t// Store node data for drop handler\n\t\tevent.dataTransfer.setData(\"application/json\", JSON.stringify({\n\t\t\ttype: \"repository-node\",\n\t\t\tnode\n\t\t}));\n\t\tevent.dataTransfer.effectAllowed = \"copy\";\n\n\t\tlogger.debug(\"repository\", \"Started dragging repository node\", {\n\t\t\tnodeId: node.id,\n\t\t\tnodeType: node.type,\n\t\t\tnodeLabel: node.label\n\t\t});\n\t}, [node]);\n\n\tconst handleCheckboxChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n\t\tonSelect(node.id, event.currentTarget.checked);\n\t}, [node.id, onSelect]);\n\n\tconst handleRemove = useCallback(() => {\n\t\tonRemove(node.id);\n\t}, [node.id, onRemove]);\n\n\treturn (\n\t\t<Card\n\t\t\tpadding=\"xs\"\n\t\t\twithBorder\n\t\t\tstyle={{\n\t\t\t\tcursor: \"grab\",\n\t\t\t\tbackgroundColor: isSelected ? colors.primary + \"20\" : colors.background.primary,\n\t\t\t\tborderColor: isSelected ? colors.primary : colors.border.primary,\n\t\t\t\tmarginBottom: \"4px\",\n\t\t\t}}\n\t\t\tdraggable=\"true\"\n\t\t\tonDragStart={handleDragStart}\n\t\t>\n\t\t\t<Group gap=\"xs\" wrap=\"nowrap\">\n\t\t\t\t<Checkbox\n\t\t\t\t\tchecked={isSelected}\n\t\t\t\t\tonChange={handleCheckboxChange}\n\t\t\t\t\tsize=\"sm\"\n\t\t\t\t/>\n\n\t\t\t\t<Icon size={16} style={{ color: colors.text.secondary, flexShrink: 0 }} />\n\n\t\t\t\t<div style={{ flex: 1, minWidth: 0 }}>\n\t\t\t\t\t<Text size=\"sm\" style={{ fontWeight: 500, color: colors.text.primary }} truncate>\n\t\t\t\t\t\t{node.label}\n\t\t\t\t\t</Text>\n\t\t\t\t\t<Text size=\"xs\" style={{ color: colors.text.secondary }}>\n\t\t\t\t\t\t{entityOption?.label || node.type}\n\t\t\t\t\t</Text>\n\t\t\t\t</div>\n\n\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t<Tooltip label=\"Drag to graph\">\n\t\t\t\t\t\t<div style={{ color: colors.text.tertiary }}>\n\t\t\t\t\t\t\t<IconDragDrop size={14} />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</Tooltip>\n\n\t\t\t\t\t<Tooltip label=\"Remove from repository\">\n\t\t\t\t\t\t<ActionIcon\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\t\t\tonClick={handleRemove}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<IconTrash size={12} />\n\t\t\t\t\t\t</ActionIcon>\n\t\t\t\t\t</Tooltip>\n\t\t\t\t</Group>\n\t\t\t</Group>\n\t\t</Card>\n\t);\n};\n\nexport const NodeRepositorySection: React.FC = () => {\n\tconst themeColors = useThemeColors();\n\tconst {colors} = themeColors;\n\n\t// Repository store\n\tconst repositoryStore = useRepositoryStore();\n\tconst {searchQuery} = repositoryStore;\n\tconst {nodeTypeFilter} = repositoryStore;\n\tconst {selectedRepositoryNodes} = repositoryStore;\n\tconst {setSearchQuery} = repositoryStore;\n\tconst {setNodeTypeFilter} = repositoryStore;\n\tconst {selectRepositoryNode} = repositoryStore;\n\tconst {selectAllNodes} = repositoryStore;\n\tconst {clearAllSelections} = repositoryStore;\n\tconst {removeFromRepository} = repositoryStore;\n\tconst {getFilteredNodes} = repositoryStore;\n\tconst {getSelectedNodes} = repositoryStore;\n\tconst {recomputeFilteredNodes} = repositoryStore;\n\n\t// Get filtered nodes (stable reference from store)\n\tconst filteredNodes = useMemo(() => {\n\t\t// Trigger recomputation to ensure cache is fresh\n\t\trecomputeFilteredNodes();\n\t\treturn getFilteredNodes();\n\t}, [getFilteredNodes, recomputeFilteredNodes]);\n\n\tconst selectedNodes = useMemo(() => {\n\t\treturn getSelectedNodes();\n\t}, [getSelectedNodes]);\n\n\tconst handleSearchChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n\t\tsetSearchQuery(event.currentTarget.value);\n\t}, [setSearchQuery]);\n\n\tconst handleTypeFilterChange = useCallback((entityType: EntityType, checked: boolean) => {\n\t\tsetNodeTypeFilter(entityType, checked);\n\t}, [setNodeTypeFilter]);\n\n\tconst handleSelectAll = useCallback(() => {\n\t\tselectAllNodes();\n\t}, [selectAllNodes]);\n\n\tconst handleClearSelection = useCallback(() => {\n\t\tclearAllSelections();\n\t}, [clearAllSelections]);\n\n\tconst handleRemoveSelected = useCallback(() => {\n\t\tconst selectedNodeIds = Object.keys(selectedRepositoryNodes);\n\t\tif (selectedNodeIds.length > 0) {\n\t\t\tremoveFromRepository(selectedNodeIds);\n\t\t\tlogger.debug(\"repository\", \"Removed selected nodes from repository\", {\n\t\t\t\tremovedCount: selectedNodeIds.length\n\t\t\t});\n\t\t}\n\t}, [selectedRepositoryNodes, removeFromRepository]);\n\n\tconst handleRemoveNode = useCallback((nodeId: string) => {\n\t\tremoveFromRepository([nodeId]);\n\t\tlogger.debug(\"repository\", \"Removed single node from repository\", { nodeId });\n\t}, [removeFromRepository]);\n\n\treturn (\n\t\t<Stack gap=\"sm\" style={{ height: \"100%\", overflow: \"hidden\" }}>\n\t\t\t{/* Search */}\n\t\t\t<TextInput\n\t\t\t\tplaceholder=\"Search repository nodes...\"\n\t\t\t\tleftSection={<IconSearch size={16} />}\n\t\t\t\tvalue={searchQuery}\n\t\t\t\tonChange={handleSearchChange}\n\t\t\t\tsize=\"sm\"\n\t\t\t/>\n\n\t\t\t{/* Type filters */}\n\t\t\t<Stack gap=\"xs\">\n\t\t\t\t<Text size=\"sm\" style={{ fontWeight: 500, color: colors.text.primary }}>\n          Filter by type:\n\t\t\t\t</Text>\n\t\t\t\t<div style={{ display: \"grid\", gridTemplateColumns: \"1fr 1fr\", gap: \"4px\" }}>\n\t\t\t\t\t{entityTypeOptions.map(option => {\n\t\t\t\t\t\tconst Icon = option.icon;\n\t\t\t\t\t\tconst isChecked = nodeTypeFilter[option.type];\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Checkbox\n\t\t\t\t\t\t\t\tkey={option.type}\n\t\t\t\t\t\t\t\tchecked={isChecked}\n\t\t\t\t\t\t\t\tonChange={(event) => { handleTypeFilterChange(option.type, event.currentTarget.checked); }}\n\t\t\t\t\t\t\t\tlabel={\n\t\t\t\t\t\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t\t\t\t\t\t<Icon size={14} />\n\t\t\t\t\t\t\t\t\t\t<Text size=\"xs\">{option.label}</Text>\n\t\t\t\t\t\t\t\t\t</Group>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</Stack>\n\n\t\t\t{/* Selection controls */}\n\t\t\t<Group gap=\"xs\">\n\t\t\t\t<Button\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tleftSection={<IconSelectAll size={14} />}\n\t\t\t\t\tonClick={handleSelectAll}\n\t\t\t\t\tdisabled={filteredNodes.length === 0}\n\t\t\t\t>\n          All\n\t\t\t\t</Button>\n\n\t\t\t\t<Button\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tleftSection={<IconX size={14} />}\n\t\t\t\t\tonClick={handleClearSelection}\n\t\t\t\t\tdisabled={selectedNodes.length === 0}\n\t\t\t\t>\n          None\n\t\t\t\t</Button>\n\n\t\t\t\t<Button\n\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\tleftSection={<IconTrash size={14} />}\n\t\t\t\t\tonClick={handleRemoveSelected}\n\t\t\t\t\tdisabled={selectedNodes.length === 0}\n\t\t\t\t>\n          Remove\n\t\t\t\t</Button>\n\t\t\t</Group>\n\n\t\t\t{/* Results summary */}\n\t\t\t<Group gap=\"xs\" justify=\"space-between\">\n\t\t\t\t<Text size=\"xs\" style={{ color: colors.text.secondary }}>\n\t\t\t\t\t{filteredNodes.length} node{filteredNodes.length !== 1 ? \"s\" : \"\"}\n\t\t\t\t</Text>\n\t\t\t\t{selectedNodes.length > 0 && (\n\t\t\t\t\t<Badge size=\"xs\" color=\"blue\">\n\t\t\t\t\t\t{selectedNodes.length} selected\n\t\t\t\t\t</Badge>\n\t\t\t\t)}\n\t\t\t</Group>\n\n\t\t\t{/* Node list */}\n\t\t\t<ScrollArea style={{ flex: 1 }}>\n\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t{filteredNodes.length === 0 ? (\n\t\t\t\t\t\t<Text size=\"sm\" style={{ color: colors.text.tertiary, textAlign: \"center\", padding: \"20px\" }}>\n              No nodes in repository.\n              Search for entities to add them here.\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t) : (\n\t\t\t\t\t\tfilteredNodes.map(node => (\n\t\t\t\t\t\t\t<NodeRepositoryItem\n\t\t\t\t\t\t\t\tkey={node.id}\n\t\t\t\t\t\t\t\tnode={node}\n\t\t\t\t\t\t\t\tisSelected={selectedRepositoryNodes[node.id] ?? false}\n\t\t\t\t\t\t\t\tonSelect={selectRepositoryNode}\n\t\t\t\t\t\t\t\tonRemove={handleRemoveNode}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))\n\t\t\t\t\t)}\n\t\t\t\t</Stack>\n\t\t\t</ScrollArea>\n\n\t\t\t{/* Drag instructions */}\n\t\t\t{filteredNodes.length > 0 && (\n\t\t\t\t<Group justify=\"center\" gap=\"xs\" style={{ padding: \"8px\" }}>\n\t\t\t\t\t<IconBulb size={12} style={{ color: colors.text.tertiary }} />\n\t\t\t\t\t<Text size=\"xs\" style={{ color: colors.text.tertiary }}>\n            Drag nodes to the graph to add them\n\t\t\t\t\t</Text>\n\t\t\t\t</Group>\n\t\t\t)}\n\t\t</Stack>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/SearchSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/SettingsSection.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":164,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":164,"endColumn":56},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5448,5451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5448,5451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .clearedLayers on an `any` value.","line":164,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":164,"endColumn":50},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":164,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":164,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5468,5470],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":165,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":165,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5498,5501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5498,5501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .errors on an `any` value.","line":165,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":165,"endColumn":36},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":165,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":165,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5511,5513],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Settings section for user preferences and data management\n */\n\nimport React from \"react\";\nimport { Button, Stack, Text, Alert, Group, TextInput, Tooltip, Divider } from \"@mantine/core\";\nimport { IconTrash, IconRefresh, IconSettings, IconAlertTriangle, IconMail, IconCheck, IconX, IconInfoCircle } from \"@tabler/icons-react\";\nimport { notifications } from \"@mantine/notifications\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { clearAllCacheLayers } from \"@academic-explorer/utils/cache\";\nimport { clearAppMetadata } from \"@academic-explorer/utils/cache\";\nimport { useLayoutStore } from \"@/stores/layout-store\";\nimport { useSettingsStore } from \"@/stores/settings-store\";\nimport { updateOpenAlexEmail } from \"@academic-explorer/client\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface ResetState {\n\tclearingCache: boolean;\n\tresettingPreferences: boolean;\n}\n\nexport const SettingsSection: React.FC = () => {\n\tconst [resetState, setResetState] = React.useState<ResetState>({\n\t\tclearingCache: false,\n\t\tresettingPreferences: false,\n\t});\n\n\t// Settings store hooks\n\tconst politePoolEmail = useSettingsStore((state) => state.politePoolEmail);\n\tconst setPolitePoolEmail = useSettingsStore((state) => state.setPolitePoolEmail);\n\tconst isValidEmail = useSettingsStore((state) => state.isValidEmail);\n\n\t// Local state for email editing\n\tconst [localEmail, setLocalEmail] = React.useState(politePoolEmail);\n\tconst [isEditingEmail, setIsEditingEmail] = React.useState(false);\n\tconst [showEmailValidation, setShowEmailValidation] = React.useState(false);\n\n\tconst queryClient = useQueryClient();\n\n\t// Sync local email state with store\n\tReact.useEffect(() => {\n\t\tsetLocalEmail(politePoolEmail);\n\t}, [politePoolEmail]);\n\n\tconst handleEmailChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n\t\tconst {value} = event.target;\n\t\tsetLocalEmail(value);\n\t\tsetShowEmailValidation(value.length > 0);\n\t}, []);\n\n\tconst handleEmailSave = React.useCallback(() => {\n\t\tconst trimmedEmail = localEmail.trim();\n\t\tif (trimmedEmail === \"\" || isValidEmail(trimmedEmail)) {\n\t\t\t// Update the settings store\n\t\t\tsetPolitePoolEmail(trimmedEmail);\n\n\t\t\t// Update the OpenAlex client configuration\n\t\t\tupdateOpenAlexEmail(trimmedEmail);\n\n\t\t\tsetIsEditingEmail(false);\n\t\t\tsetShowEmailValidation(false);\n\n\t\t\tlogger.debug(\"settings\", \"Email saved successfully\", {\n\t\t\t\thasEmail: trimmedEmail.length > 0,\n\t\t\t\tisValid: isValidEmail(trimmedEmail)\n\t\t\t});\n\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Email Updated\",\n\t\t\t\tmessage: trimmedEmail ? \"OpenAlex polite pool email has been configured.\" : \"OpenAlex polite pool email has been cleared.\",\n\t\t\t\tcolor: \"green\",\n\t\t\t\ticon: <IconCheck size={16} />,\n\t\t\t});\n\t\t}\n\t}, [localEmail, setPolitePoolEmail, isValidEmail]);\n\n\tconst handleEmailCancel = React.useCallback(() => {\n\t\tsetLocalEmail(politePoolEmail);\n\t\tsetIsEditingEmail(false);\n\t\tsetShowEmailValidation(false);\n\t\tlogger.debug(\"settings\", \"Email edit cancelled\");\n\t}, [politePoolEmail]);\n\n\tconst handleEmailKeyDown = React.useCallback((event: React.KeyboardEvent<HTMLInputElement>) => {\n\t\tif (event.key === \"Enter\") {\n\t\t\tevent.preventDefault();\n\t\t\thandleEmailSave();\n\t\t} else if (event.key === \"Escape\") {\n\t\t\tevent.preventDefault();\n\t\t\thandleEmailCancel();\n\t\t}\n\t}, [handleEmailSave, handleEmailCancel]);\n\n\t/**\n\t * Reset user preferences to defaults\n\t */\n\tconst handleResetPreferences = async (): Promise<void> => {\n\t\tsetResetState(prev => ({ ...prev, resettingPreferences: true }));\n\n\t\ttry {\n\t\t\tlogger.debug(\"ui\", \"Starting user preferences reset\", {}, \"SettingsSection\");\n\n\t\t\t// Clear Zustand persisted stores\n\t\t\t// This will reset layout store, expansion settings, graph store, etc.\n\t\t\tconst storeKeys = [\n\t\t\t\t\"academic-explorer-layout-store\",\n\t\t\t\t\"academic-explorer-expansion-settings\",\n\t\t\t\t\"academic-explorer-graph-store\",\n\t\t\t];\n\n\t\t\tfor (const key of storeKeys) {\n\t\t\t\ttry {\n\t\t\t\t\tlocalStorage.removeItem(key);\n\t\t\t\t\tlogger.debug(\"ui\", `Cleared persisted store: ${key}`, { key }, \"SettingsSection\");\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.warn(\"ui\", `Failed to clear store: ${key}`, { key, error }, \"SettingsSection\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reset layout store to defaults\n\t\t\tuseLayoutStore.persist.clearStorage();\n\n\t\t\t// Clear app metadata\n\t\t\tawait clearAppMetadata();\n\n\t\t\tlogger.debug(\"ui\", \"User preferences reset completed\", {}, \"SettingsSection\");\n\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Preferences Reset\",\n\t\t\t\tmessage: \"User preferences have been reset to defaults. Please reload the page to see changes.\",\n\t\t\t\tcolor: \"green\",\n\t\t\t\ticon: <IconRefresh size={16} />,\n\t\t\t});\n\n\t\t} catch (error) {\n\t\t\tlogger.error(\"ui\", \"Failed to reset user preferences\", { error });\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Reset Failed\",\n\t\t\t\tmessage: \"Failed to reset user preferences. Please try again.\",\n\t\t\t\tcolor: \"red\",\n\t\t\t\ticon: <IconAlertTriangle size={16} />,\n\t\t\t});\n\t\t} finally {\n\t\t\tsetResetState(prev => ({ ...prev, resettingPreferences: false }));\n\t\t}\n\t};\n\n\t/**\n\t * Clear all cache and user data\n\t */\n\tconst handleClearAllData = async (): Promise<void> => {\n\t\tsetResetState(prev => ({ ...prev, clearingCache: true }));\n\n\t\ttry {\n\t\t\tlogger.debug(\"ui\", \"Starting complete data reset\", {}, \"SettingsSection\");\n\n\t\t\t// Clear TanStack Query cache\n\t\t\tqueryClient.clear();\n\n\t\t\t// Clear all cache layers (IndexedDB, localStorage cache, memory)\n\t\t\tconst result = await clearAllCacheLayers();\n\n\t\t\tlogger.debug(\"ui\", \"Cache layers cleared\", {\n\t\t\t\tclearedLayers: (result as any)?.clearedLayers || [],\n\t\t\t\terrors: (result as any)?.errors || []\n\t\t\t});\n\n\t\t\t// Clear app metadata\n\t\t\tawait clearAppMetadata();\n\n\t\t\t// Clear all localStorage data (including persisted stores)\n\t\t\tconst localStorageKeys = Object.keys(localStorage);\n\t\t\tfor (const key of localStorageKeys) {\n\t\t\t\tif (key.startsWith(\"academic-explorer-\") || key.startsWith(\"mantine-\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlocalStorage.removeItem(key);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.warn(\"ui\", `Failed to clear localStorage key: ${key}`, { key, error }, \"SettingsSection\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.debug(\"ui\", \"Complete data reset completed\", {}, \"SettingsSection\");\n\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Data Cleared\",\n\t\t\t\tmessage: \"All cache and user data have been cleared. Please reload the page to see changes.\",\n\t\t\t\tcolor: \"green\",\n\t\t\t\ticon: <IconTrash size={16} />,\n\t\t\t});\n\n\t\t} catch (error) {\n\t\t\tlogger.error(\"ui\", \"Failed to clear cache and user data\", { error });\n\t\t\tnotifications.show({\n\t\t\t\ttitle: \"Clear Failed\",\n\t\t\t\tmessage: \"Failed to clear cache and user data. Please try again.\",\n\t\t\t\tcolor: \"red\",\n\t\t\t\ticon: <IconAlertTriangle size={16} />,\n\t\t\t});\n\t\t} finally {\n\t\t\tsetResetState(prev => ({ ...prev, clearingCache: false }));\n\t\t}\n\t};\n\n\tconst isEmailValid = showEmailValidation ? isValidEmail(localEmail) : true;\n\tconst hasStoredEmail = politePoolEmail.length > 0 && isValidEmail(politePoolEmail);\n\n\treturn (\n\t\t<Stack gap=\"md\">\n\t\t\t<Group gap=\"xs\">\n\t\t\t\t<IconSettings size={16} />\n\t\t\t\t<Text size=\"sm\" fw={500}>User Preferences</Text>\n\t\t\t</Group>\n\n\t\t\t{/* OpenAlex Polite Pool Email Configuration */}\n\t\t\t<Stack gap=\"sm\">\n\t\t\t\t<Group gap=\"xs\">\n\t\t\t\t\t<IconMail size={16} />\n\t\t\t\t\t<Text size=\"sm\" fw={500}>OpenAlex Polite Pool</Text>\n\t\t\t\t\t<Tooltip\n\t\t\t\t\t\tlabel=\"Providing an email enables faster response times from the OpenAlex API through their polite pool\"\n\t\t\t\t\t\tposition=\"right\"\n\t\t\t\t\t\tmultiline\n\t\t\t\t\t\tw={200}\n\t\t\t\t\t>\n\t\t\t\t\t\t<IconInfoCircle size={12} style={{ color: \"var(--mantine-color-dimmed)\" }} />\n\t\t\t\t\t</Tooltip>\n\t\t\t\t</Group>\n\n\t\t\t\t{!isEditingEmail ? (\n\t\t\t\t\t<Group gap=\"sm\">\n\t\t\t\t\t\t<Text size=\"sm\" {...(hasStoredEmail ? {} : { c: \"dimmed\" })}>\n\t\t\t\t\t\t\t{hasStoredEmail ? politePoolEmail : \"No email configured\"}\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\tonClick={() => { setIsEditingEmail(true); }}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{hasStoredEmail ? \"Edit\" : \"Configure\"}\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</Group>\n\t\t\t\t) : (\n\t\t\t\t\t<Stack gap=\"xs\">\n\t\t\t\t\t\t<TextInput\n\t\t\t\t\t\t\tplaceholder=\"your.email@example.com\"\n\t\t\t\t\t\t\tvalue={localEmail}\n\t\t\t\t\t\t\tonChange={handleEmailChange}\n\t\t\t\t\t\t\tonKeyDown={handleEmailKeyDown}\n\t\t\t\t\t\t\terror={showEmailValidation && !isEmailValid ? \"Please enter a valid email address\" : undefined}\n\t\t\t\t\t\t\trightSection={\n\t\t\t\t\t\t\t\tshowEmailValidation ? (\n\t\t\t\t\t\t\t\t\tisEmailValid ? (\n\t\t\t\t\t\t\t\t\t\t<IconCheck size={16} style={{ color: \"var(--mantine-color-green-6)\" }} />\n\t\t\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t\t\t<IconX size={16} style={{ color: \"var(--mantine-color-red-6)\" }} />\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) : null\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<Group gap=\"sm\">\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\tonClick={handleEmailSave}\n\t\t\t\t\t\t\t\tdisabled={showEmailValidation && !isEmailValid}\n\t\t\t\t\t\t\t\tleftSection={<IconCheck size={14} />}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tSave\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tvariant=\"subtle\"\n\t\t\t\t\t\t\t\tsize=\"xs\"\n\t\t\t\t\t\t\t\tonClick={handleEmailCancel}\n\t\t\t\t\t\t\t\tleftSection={<IconX size={14} />}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tCancel\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</Group>\n\t\t\t\t\t</Stack>\n\t\t\t\t)}\n\n\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\tYour email is used only for OpenAlex API requests to enable faster response times.\n\t\t\t\t\tIt is not stored remotely or shared with third parties.\n\t\t\t\t</Text>\n\t\t\t</Stack>\n\n\t\t\t<Divider />\n\n\t\t\t<Alert\n\t\t\t\ticon={<IconAlertTriangle size={16} />}\n\t\t\t\ttitle=\"Warning\"\n\t\t\t\tcolor=\"yellow\"\n\t\t\t\tvariant=\"light\"\n\t\t\t>\n\t\t\t\tThese actions will modify or clear your saved preferences and data.\n\t\t\t\tYou may need to reload the page after making changes.\n\t\t\t</Alert>\n\n\t\t\t<Stack gap=\"sm\">\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\tleftSection={<IconRefresh size={16} />}\n\t\t\t\t\tonClick={() => void handleResetPreferences()}\n\t\t\t\t\tloading={resetState.resettingPreferences}\n\t\t\t\t\tdisabled={resetState.clearingCache}\n\t\t\t\t\tfullWidth\n\t\t\t\t>\n\t\t\t\t\tReset User Preferences\n\t\t\t\t</Button>\n\n\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\tReset layout, expansion settings, and other user preferences to default values.\n\t\t\t\t</Text>\n\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\tcolor=\"red\"\n\t\t\t\t\tleftSection={<IconTrash size={16} />}\n\t\t\t\t\tonClick={() => void handleClearAllData()}\n\t\t\t\t\tloading={resetState.clearingCache}\n\t\t\t\t\tdisabled={resetState.resettingPreferences}\n\t\t\t\t\tfullWidth\n\t\t\t\t>\n\t\t\t\t\tClear All Cache & User Data\n\t\t\t\t</Button>\n\n\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\tClear all cached API data, user preferences, and application state.\n\t\t\t\t\tThis will reset the app to a fresh state.\n\t\t\t\t</Text>\n\t\t\t</Stack>\n\t\t</Stack>\n\t);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/ViewOptionsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/sections/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/components/tables/BaseTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/config/cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/config/rate-limit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-auto-relationship-detection.ts","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'queryClient' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":72,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":77,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":77,"endColumn":16,"suggestions":[{"fix":{"range":[2320,2388],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2418,2421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2418,2421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":80,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":80,"endColumn":18,"suggestions":[{"fix":{"range":[2434,2495],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":20,"suggestions":[{"fix":{"range":[2573,2619],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":89,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":89,"endColumn":20,"suggestions":[{"fix":{"range":[2718,2762],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":20,"suggestions":[{"fix":{"range":[2894,2950],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":99,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":99,"endColumn":20,"suggestions":[{"fix":{"range":[3080,3126],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":16,"suggestions":[{"fix":{"range":[3344,3433],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for automatic relationship detection when any nodes are added to the graph\n * Listens for BULK_NODES_ADDED events and triggers relationship detection for all entity types\n */\n\nimport { useMemo, useEffect } from \"react\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { GraphEventType } from \"@academic-explorer/graph\";\nimport { useEventBus } from \"./use-unified-event-system\";\nimport { getRelationshipDetectionService } from \"@academic-explorer/utils\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphEdge } from \"@academic-explorer/graph\";\n\n// Interface for node structure\ninterface NodeLike {\n  type: string;\n  id: string;\n}\n\n// Note: EdgeLike interface removed - service returns proper GraphEdge objects\n\n// Interface for event structure\ninterface EventLike {\n  payload?: unknown;\n}\n\n// Type guard for graph nodes - using property existence checks\nfunction isValidNode(value: unknown): value is NodeLike {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  // Check properties exist and have correct types without type assertion\n  return (\n    \"type\" in value &&\n    \"id\" in value &&\n    typeof value.type === \"string\" &&\n    typeof value.id === \"string\"\n  );\n}\n\n// Type guard for GraphEdge objects\nfunction isValidGraphEdge(value: unknown): value is GraphEdge {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  return (\n    \"id\" in value &&\n    \"type\" in value &&\n    \"source\" in value &&\n    \"target\" in value &&\n    typeof value.id === \"string\" &&\n    typeof value.source === \"string\" &&\n    typeof value.target === \"string\" &&\n    // type should be a valid RelationType, but string validation is sufficient for type guard\n    typeof value.type === \"string\"\n  );\n}\n\n// Type guard for event structure\nfunction isValidEvent(value: unknown): value is EventLike {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  return true; // Any object is a valid event, payload is optional\n}\n\nexport function useAutoRelationshipDetection() {\n  const queryClient = useQueryClient();\n  const relationshipDetectionService = useMemo(() => getRelationshipDetectionService(), []);\n  const eventBus = useEventBus();\n\n  useEffect(() => {\n    console.log(\"DEBUG: useAutoRelationshipDetection hook initialized\");\n\n    const handler = (event: any) => {\n      console.log(\"DEBUG: BULK_NODES_ADDED event received\", event);\n\n      // Type guard for the event\n      if (!isValidEvent(event)) {\n        console.log(\"DEBUG: Event failed type guard\");\n        return;\n      }\n\n      if (!event.payload || typeof event.payload !== \"object\") {\n        console.log(\"DEBUG: Event payload invalid\");\n        return;\n      }\n      const {payload} = event;\n      if (!(\"nodes\" in payload) || !Array.isArray(payload.nodes)) {\n        console.log(\"DEBUG: Event payload missing nodes array\");\n        return;\n      }\n      const validNodes = payload.nodes.filter(isValidNode);\n      if (validNodes.length === 0) {\n        console.log(\"DEBUG: No valid nodes in event\");\n        return;\n      }\n      const { nodes } = { nodes: validNodes };\n    if (nodes.length === 0) {\n      logger.debug(\"graph\", \"No nodes in bulk addition, skipping relationship detection\");\n      return;\n    }\n\n    console.log(\"DEBUG: About to trigger relationship detection for\", nodes.length, \"nodes\");\n\n    logger.debug(\"graph\", \"Nodes added to graph, triggering relationship detection\", {\n      nodeCount: nodes.length,\n      nodeTypes: [...new Set(nodes.map((node: NodeLike) => node.type))],\n      nodeIds: nodes.map((node: NodeLike) => node.id)\n    });\n\n    // Get all current node IDs for relationship detection\n    const store = useGraphStore.getState();\n    const allNodeIds = Object.keys(store.nodes);\n\n    // Trigger relationship detection asynchronously for all nodes\n    relationshipDetectionService.detectRelationships(allNodeIds)\n      .then((detectedEdges: unknown) => {\n        // Type guard to ensure we have GraphEdge array\n        if (!Array.isArray(detectedEdges)) {\n          logger.warn(\"graph\", \"Expected array of edges from relationship detection service\", { detectedEdges });\n          return;\n        }\n        const edgesArray = detectedEdges as GraphEdge[];\n        // Service returns properly typed GraphEdge[], but validate for safety\n        const validEdges = edgesArray.filter(isValidGraphEdge);\n        if (validEdges.length > 0) {\n          logger.debug(\"graph\", \"Detected relationships between nodes\", {\n            edgeCount: validEdges.length,\n            edgeTypes: [...new Set(validEdges.map(edge => edge.type))],\n            edgeDetails: validEdges.map(edge => ({\n              type: edge.type,\n              source: edge.source,\n              target: edge.target\n            }))\n          });\n\n\n          store.addEdges(validEdges);\n\n          logger.debug(\"graph\", \"Added relationship edges to graph store\", {\n            edgeCount: validEdges.length\n          });\n        } else {\n          logger.debug(\"graph\", \"No relationships detected between nodes\");\n        }\n      })\n      .catch((error: unknown) => {\n        logger.error(\"graph\", \"Failed to detect relationships between nodes\", {\n          error: error instanceof Error ? error.message : \"Unknown error\",\n          nodeCount: nodes.length,\n          nodeTypes: [...new Set(nodes.map((node: NodeLike) => node.type))]\n        });\n      });\n    };\n\n    eventBus.on(GraphEventType.BULK_NODES_ADDED, handler);\n\n    return () => {\n      eventBus.off(GraphEventType.BULK_NODES_ADDED, handler);\n    };\n  }, [eventBus, relationshipDetectionService]);\n\n  // Return nothing - this is a side-effect only hook\n  return undefined;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-context-menu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-document-title.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":53,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":55,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[1336,1420],"text":"originalTitle.current ??= document.title;"},"desc":"Fix to nullish coalescing operator (`??=`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for managing document title dynamically\n * Allows setting page titles based on entity data or route content\n */\n\nimport { useEffect, useRef } from \"react\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface UseDocumentTitleOptions {\n  /**\n   * Base title to append after the main title\n   * @default \"Academic Explorer\"\n   */\n  baseTitle?: string;\n  /**\n   * Whether to restore the original title when the component unmounts\n   * @default false\n   */\n  restoreOnUnmount?: boolean;\n}\n\n/**\n * Hook to set the document title dynamically\n *\n * @param title - The main title to set (entity name, page name, etc.)\n * @param options - Configuration options\n *\n * @example\n * ```typescript\n * // Set title for entity page\n * useDocumentTitle(entity?.display_name);\n *\n * // Set title with custom base\n * useDocumentTitle(\"Search Results\", { baseTitle: \"Academic Explorer\" });\n *\n * // Restore original title on unmount\n * useDocumentTitle(\"Temporary Title\", { restoreOnUnmount: true });\n * ```\n */\nexport const useDocumentTitle = (\n\ttitle: string | null | undefined,\n\toptions: UseDocumentTitleOptions = {}\n) => {\n\tconst {\n\t\tbaseTitle = \"Academic Explorer\",\n\t\trestoreOnUnmount = false\n\t} = options;\n\n\tconst originalTitle = useRef<string | null>(null);\n\n\tuseEffect(() => {\n\t\t// Store original title on first mount\n\t\tif (originalTitle.current === null) {\n\t\t\toriginalTitle.current = document.title;\n\t\t}\n\n\t\t// Safely handle title with proper type guards\n\t\tconst trimmedTitle = typeof title === \"string\" ? title.trim() : \"\";\n\n\t\t// Only update title if we have a valid non-empty title\n\t\tif (trimmedTitle) {\n\t\t\tconst newTitle = `${trimmedTitle} - ${baseTitle}`;\n\t\t\tdocument.title = newTitle;\n\n\t\t\tlogger.debug(\"ui\", \"Document title updated\", {\n\t\t\t\tnewTitle,\n\t\t\t\tentityTitle: trimmedTitle,\n\t\t\t\tbaseTitle\n\t\t\t}, \"useDocumentTitle\");\n\t\t} else {\n\t\t\t// Reset to base title if no specific title provided\n\t\t\tdocument.title = baseTitle;\n\n\t\t\tlogger.debug(\"ui\", \"Document title reset to base\", {\n\t\t\t\tbaseTitle,\n\t\t\t\t...(title !== undefined && title !== null && { receivedTitle: title })\n\t\t\t}, \"useDocumentTitle\");\n\t\t}\n\t}, [title, baseTitle]);\n\n\tuseEffect(() => {\n\t\t// Cleanup effect for restoring original title\n\t\tif (restoreOnUnmount) {\n\t\t\treturn () => {\n\t\t\t\tif (originalTitle.current) {\n\t\t\t\t\tdocument.title = originalTitle.current;\n\t\t\t\t\tlogger.debug(\"ui\", \"Document title restored\", {\n\t\t\t\t\t\trestoredTitle: originalTitle.current\n\t\t\t\t\t}, \"useDocumentTitle\");\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t}, [restoreOnUnmount]);\n};\n\n/**\n * Hook specifically for entity pages that extracts display_name from entity data\n *\n * @param entity - OpenAlex entity with display_name property\n * @param options - Configuration options\n *\n * @example\n * ```typescript\n * const { data: author } = useRawEntityData({ entityId: authorId });\n * useEntityDocumentTitle(author);\n * ```\n */\nexport const useEntityDocumentTitle = (\n\tentity: { display_name?: string } | null | undefined,\n\toptions: UseDocumentTitleOptions = {}\n) => {\n\tconst displayName = entity?.display_name;\n\tuseDocumentTitle(displayName, options);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-entity-interaction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-graph-activity-tracker.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":148,"column":11,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":151,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":152,"column":11,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":154,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":155,"column":11,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":158,"endColumn":19}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for tracking graph and simulation activity\n * Uses the unified event system for improved tracking\n */\n\nimport { useEffect, useCallback, useRef, useMemo } from \"react\";\nimport { useAppActivityStore } from \"@/stores/app-activity-store\";\nimport { useEventBus, useEventSubscriptions } from \"@academic-explorer/graph\";\nimport {\n  GraphEventType,\n  EntityEventType,\n  WorkerEventType\n} from \"@academic-explorer/graph\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\n// Type guards for better type safety\nconst GRAPH_EVENT_VALUES: readonly string[] = Object.values(GraphEventType);\nconst ENTITY_EVENT_VALUES: readonly string[] = Object.values(EntityEventType);\nconst WORKER_EVENT_VALUES: readonly string[] = Object.values(WorkerEventType);\n\nfunction isGraphEventType(eventType: string): eventType is GraphEventType {\n  return GRAPH_EVENT_VALUES.includes(eventType);\n}\n\nfunction isEntityEventType(eventType: string): eventType is EntityEventType {\n  return ENTITY_EVENT_VALUES.includes(eventType);\n}\n\nfunction isWorkerEventType(eventType: string): eventType is WorkerEventType {\n  return WORKER_EVENT_VALUES.includes(eventType);\n}\n\nfunction isRecordObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\n/**\n * Hook to track graph and simulation activity using unified event system\n */\nexport function useGraphActivityTracker() {\n  const { addEvent } = useAppActivityStore();\n  const bus = useEventBus(\"academic-explorer-activity\");\n  const trackingActiveRef = useRef(false);\n\n  // Unified event handler for all activity events\n  const handleUnifiedEvent = useCallback((event: { type: string; payload?: unknown }) => {\n    let eventType: string = \"unknown\";\n    try {\n      eventType = event.type;\n      const { payload } = event;\n\n      // Debug logging to see all events\n      logger.debug(\"ui\", \"Unified activity tracker received event\", {\n        eventType,\n        payloadKeys: payload && typeof payload === \"object\" ? Object.keys(payload) : \"non-object\",\n        allGraphEventTypes: Object.values(GraphEventType),\n        isGraphEvent: isGraphEventType(eventType)\n      }, \"GraphActivityTracker\");\n\n      // Handle graph structure events\n      if (isGraphEventType(eventType)) {\n        const graphPayload = isRecordObject(payload) ? payload : {};\n\n        let description = \"\";\n        let duration: number | undefined;\n\n        switch (eventType) {\n          case GraphEventType.ANY_NODE_ADDED:\n            description = \"Added node to graph\";\n            break;\n          case GraphEventType.ANY_NODE_REMOVED:\n            description = \"Removed node from graph\";\n            break;\n          case GraphEventType.BULK_NODES_ADDED:\n            description = \"Added multiple nodes to graph\";\n            break;\n          case GraphEventType.ANY_EDGE_ADDED:\n            description = \"Added edge to graph\";\n            break;\n          case GraphEventType.BULK_EDGES_ADDED:\n            description = \"Added multiple edges to graph\";\n            break;\n          case GraphEventType.GRAPH_CLEARED:\n            description = \"Graph cleared\";\n            break;\n          default:\n            description = `Graph event: ${eventType}`;\n        }\n\n        addEvent({\n          type: \"system\",\n          category: \"data\",\n          event: eventType,\n          description,\n          severity: \"info\",\n          duration: duration ?? 0,\n          metadata: {\n            data: {\n              eventType,\n              graphOperation: true,\n              payload: graphPayload,\n            },\n          },\n        });\n      }\n\n      // Handle entity expansion events\n      else if (isEntityEventType(eventType) && eventType === EntityEventType.ENTITY_EXPANDED) {\n        const entityPayload = isRecordObject(payload) ? payload : {};\n        const description = \"Entity expanded with related data\";\n\n        addEvent({\n          type: \"user\",\n          category: \"data\",\n          event: eventType,\n          description,\n          severity: \"info\",\n          metadata: {\n            data: {\n              eventType,\n              expansion: true,\n              payload: entityPayload,\n            },\n          },\n        });\n      }\n\n      // Handle worker events (force simulation & data fetching)\n      else if (isWorkerEventType(eventType)) {\n        const workerPayload = isRecordObject(payload) ? payload : {};\n\n        let description = \"\";\n        let severity: \"info\" | \"warning\" | \"error\" | \"debug\" = \"info\";\n        let duration: number | undefined;\n\n        switch (eventType) {\n          case WorkerEventType.FORCE_SIMULATION_PROGRESS:\n            description = \"Force simulation progress\";\n            severity = \"debug\";\n            break;\n          case WorkerEventType.FORCE_SIMULATION_COMPLETE:\n            description = \"Force simulation completed\";\n            break;\n          case WorkerEventType.FORCE_SIMULATION_ERROR:\n            description = \"Force simulation error\";\n            severity = \"error\";\n            break;\n          case \"data-fetch-progress\":\n            description = \"Data fetch progress\";\n            severity = \"debug\";\n            break;\n          case \"data-fetch-complete\":\n            description = \"Data fetch completed\";\n            break;\n          case \"data-fetch-error\":\n            description = \"Data fetch error\";\n            severity = \"error\";\n            break;\n          default:\n            description = `Worker event: ${eventType}`;\n        }\n\n        addEvent({\n          type: \"system\",\n          category: \"background\",\n          event: eventType,\n          description,\n          severity,\n          duration: duration ?? 0,\n          metadata: {\n            data: {\n              eventType,\n              simulation: eventType.includes(\"simulation\"),\n              dataFetch: eventType.includes(\"fetch\"),\n              payload: workerPayload,\n            },\n          },\n        });\n      }\n    } catch (error) {\n      logger.error(\"ui\", \"Failed to process graph event\", {\n        eventType,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      }, \"GraphActivityTracker\");\n    }\n  }, [addEvent]);\n\n  // Set up unified event subscriptions (memoized to prevent unnecessary re-renders)\n  const eventSubscriptions = useMemo(() => [\n    // Graph structure events\n    { eventType: GraphEventType.ANY_NODE_ADDED, handler: handleUnifiedEvent },\n    { eventType: GraphEventType.ANY_NODE_REMOVED, handler: handleUnifiedEvent },\n    { eventType: GraphEventType.ANY_EDGE_ADDED, handler: handleUnifiedEvent },\n    { eventType: GraphEventType.ANY_NODE_REMOVED, handler: handleUnifiedEvent },\n    { eventType: GraphEventType.BULK_NODES_ADDED, handler: handleUnifiedEvent },\n    { eventType: GraphEventType.BULK_EDGES_ADDED, handler: handleUnifiedEvent },\n    { eventType: GraphEventType.GRAPH_CLEARED, handler: handleUnifiedEvent },\n    // Entity events\n    { eventType: EntityEventType.ENTITY_EXPANDED, handler: handleUnifiedEvent },\n\n    // Worker/Task events\n    { eventType: \"TASK_PROGRESS\", handler: handleUnifiedEvent },\n    { eventType: \"TASK_COMPLETED\", handler: handleUnifiedEvent },\n    { eventType: \"TASK_FAILED\", handler: handleUnifiedEvent },\n    { eventType: \"FORCE_SIMULATION_PROGRESS\", handler: handleUnifiedEvent },\n    { eventType: \"FORCE_SIMULATION_COMPLETE\", handler: handleUnifiedEvent },\n    { eventType: \"DATA_FETCH_COMPLETE\", handler: handleUnifiedEvent },\n    { eventType: \"QUEUE_TASK_ASSIGNED\", handler: handleUnifiedEvent },\n    { eventType: \"QUEUE_TASK_COMPLETED\", handler: handleUnifiedEvent }\n  ], [handleUnifiedEvent]);\n\n  useEventSubscriptions(bus, eventSubscriptions);\n\n  // Lifecycle tracking\n  useEffect(() => {\n    if (!trackingActiveRef.current) {\n      trackingActiveRef.current = true;\n\n      // Log initial setup\n      addEvent({\n        type: \"system\",\n        category: \"lifecycle\",\n        event: \"activity_tracker_started\",\n        description: \"Unified graph activity tracking started\",\n        severity: \"info\",\n        metadata: {\n          data: {\n            trackingTypes: [\"graph\", \"tasks\", \"simulation\", \"data-fetch\"],\n            unifiedSystem: true,\n            eventCount: eventSubscriptions.length\n          },\n        },\n      });\n\n      logger.debug(\"ui\", \"Unified graph activity tracker started\", {\n        eventCount: eventSubscriptions.length,\n        trackingTypes: [\"graph\", \"tasks\", \"simulation\", \"data-fetch\"]\n      }, \"GraphActivityTracker\");\n    }\n\n    return () => {\n      if (trackingActiveRef.current) {\n        trackingActiveRef.current = false;\n\n        addEvent({\n          type: \"system\",\n          category: \"lifecycle\",\n          event: \"activity_tracker_stopped\",\n          description: \"Unified graph activity tracking stopped\",\n          severity: \"info\",\n          metadata: {\n            data: {\n              unifiedSystem: true\n            },\n          },\n        });\n\n        logger.debug(\"ui\", \"Unified graph activity tracker stopped\", {}, \"GraphActivityTracker\");\n      }\n    };\n  }, [addEvent, eventSubscriptions.length]);\n\n  return {\n    // Expose any manual tracking methods if needed\n    isTracking: trackingActiveRef.current,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-graph-data.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":4,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":15,"suggestions":[{"fix":{"range":[2925,2999],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":73,"column":4,"nodeType":"MemberExpression","messageId":"unexpected","endLine":73,"endColumn":17,"suggestions":[{"fix":{"range":[3003,3091],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":16,"suggestions":[{"fix":{"range":[3106,3153],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":16,"suggestions":[{"fix":{"range":[3202,3286],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":4,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":15,"suggestions":[{"fix":{"range":[3357,3467],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":16,"suggestions":[{"fix":{"range":[3488,3551],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":14,"suggestions":[{"fix":{"range":[3657,3751],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":4,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":15,"suggestions":[{"fix":{"range":[3811,3904],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":91,"column":53,"nodeType":"Property","messageId":"anyAssignment","endLine":91,"endColumn":93},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":93,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":93,"endColumn":16,"suggestions":[{"fix":{"range":[3946,4013],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":107,"column":6,"nodeType":"Property","messageId":"anyAssignment","endLine":107,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":108,"column":6,"nodeType":"Property","messageId":"anyAssignment","endLine":108,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":161,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":161,"endColumn":43},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":174,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":174,"endColumn":16,"suggestions":[{"fix":{"range":[7037,7164],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":230,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":230,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8819,8821],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":233,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":233,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[9027,9029],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React hook for graph data operations\n * Provides a clean interface for loading and manipulating graph data\n */\n\nimport { useUnifiedExecutionWorker } from \"@/hooks/use-unified-execution-worker\";\nimport { createGraphDataService } from \"@/services/graph-data-service\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport type { EntityType, ExpansionOptions, SearchOptions } from \"@academic-explorer/graph\";\nimport { safeParseExpansionTarget } from \"@academic-explorer/utils\";\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { useCallback, useMemo } from \"react\";\n\nexport function useGraphData() {\n\tconst queryClient = useQueryClient();\n\tconst service = useMemo(() => createGraphDataService(queryClient), [queryClient]);\n\tconst isLoading = useGraphStore((state) => state.isLoading);\n\tconst error = useGraphStore((state) => state.error);\n\n\t// Enhanced background worker for data fetching and expansion\n\tconst forceWorker = useUnifiedExecutionWorker({\n\t\tonExpansionProgress: (nodeId, progress) => {\n\t\t\tlogger.debug(\"graph\", \"Node expansion progress\", { nodeId, progress }, \"useGraphData\");\n\t\t},\n\t\tonExpansionComplete: (result) => {\n\t\t\tlogger.debug(\"graph\", \"Node expansion completed via force worker\", {\n\t\t\t\tnodeId: result.requestId,\n\t\t\t\tnodesAdded: result.nodes.length,\n\t\t\t\tedgesAdded: result.edges.length\n\t\t\t}, \"useGraphData\");\n\t\t\t// The worker has fetched the data, now we need to integrate it into the graph\n\t\t\t// This would typically be handled by a graph service or store\n\t\t\t// TODO: Integrate expansion result into graph store\n\t\t\t// const store = useGraphStore.getState();\n\t\t\t// store.addNodes(result.nodes);\n\t\t\t// store.addEdges(result.edges);\n\t\t},\n\t\tonExpansionError: (nodeId, error) => {\n\t\t\tlogger.error(\"graph\", \"Node expansion failed via force worker\", { nodeId, error }, \"useGraphData\");\n\t\t\tconst store = useGraphStore.getState();\n\t\t\tstore.setError(`Failed to expand node ${nodeId}: ${error}`);\n\t\t}\n\t});\n\n\n\tconst loadEntity = useCallback(async (entityId: string) => {\n\t\ttry {\n\t\t\tawait service.loadEntityGraph(entityId);\n\t\t} catch (err) {\n\t\t\tlogError(logger, \"Failed to load entity in graph data hook\", err, \"useGraphData\", \"graph\");\n\t\t}\n\t}, [service]);\n\n\tconst loadEntityIntoGraph = useCallback(async (entityId: string) => {\n\t\ttry {\n\t\t\tawait service.loadEntityIntoGraph(entityId);\n\t\t} catch (err) {\n\t\t\tlogError(logger, \"Failed to load entity into graph in graph data hook\", err, \"useGraphData\", \"graph\");\n\t\t}\n\t}, [service]);\n\n\tconst loadEntityIntoRepository = useCallback(async (entityId: string) => {\n\t\ttry {\n\t\t\tawait service.loadEntityIntoRepository(entityId);\n\t\t} catch (err) {\n\t\t\tlogError(logger, \"Failed to load entity into repository in graph data hook\", err, \"useGraphData\", \"repository\");\n\t\t}\n\t}, [service]);\n\n \tconst expandNode = useCallback(async (nodeId: string, options?: Partial<ExpansionOptions>) => {\n \t\tconsole.log(\"DEBUG: useGraphData.expandNode called\", { nodeId, options });\n \t\tconsole.error(\"DEBUG: useGraphData.expandNode called - ERROR LOG\", { nodeId, options });\n\n \t\ttry {\n \t\t\tconsole.log(\"DEBUG: About to get store state\");\n \t\t\tconst store = useGraphStore.getState();\n \t\t\tconsole.log(\"DEBUG: Got store state, node count:\", Object.keys(store.nodes).length);\n\n \t\t// Get the node to expand\n \t\tconst node = store.nodes[nodeId];\n \t\tconsole.log(\"DEBUG: Checking for node\", { nodeId, nodeExists: !!node, allNodeIds: Object.keys(store.nodes) });\n \t\tif (!node) {\n \t\t\tconsole.log(\"DEBUG: Node not found for expansion\", { nodeId });\n \t\t\tlogger.warn(\"graph\", \"Node not found for expansion\", { nodeId }, \"useGraphData\");\n \t\t\treturn;\n \t\t}\n\t\tconsole.log(\"DEBUG: Node found, calling service.expandNode\", { nodeId, nodeType: node.type });\n\n \t\t// Check if force worker is ready, with retry logic\n \t\tconsole.log(\"DEBUG: Force worker ready check\", { isWorkerReady: forceWorker.isWorkerReady });\n \t\tif (!forceWorker.isWorkerReady) {\n \t\t\tconsole.log(\"DEBUG: Force worker not ready, starting retry logic\");\n \t\t\tlogger.warn(\"graph\", \"Force worker not ready initially, waiting for readiness\", { nodeId }, \"useGraphData\");\n\n\t\t\t// Wait a short time for state propagation and retry\n\t\t\tlet retryCount = 0;\n\t\t\tconst maxRetries = 10;\n\t\t\tconst retryDelay = 100; // 100ms\n\n\t\t\twhile (!forceWorker.isWorkerReady && retryCount < maxRetries) {\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, retryDelay));\n\t\t\t\tretryCount++;\n\t\t\t\tlogger.warn(\"graph\", \"Retry checking worker readiness\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tretryCount,\n\t\t\t\t\tisReady: forceWorker.isWorkerReady,\n\t\t\t\t\thasWorker: forceWorker.isWorkerReady,\n\t\t\t\t\tworkerState: typeof forceWorker\n\t\t\t\t}, \"useGraphData\");\n\t\t\t}\n\n\t\t\t// If still not ready after retries, fall back to service\n\t\t\tif (!forceWorker.isWorkerReady) {\n\t\t\t\tlogger.warn(\"graph\", \"Force worker not ready after retries, falling back to service\", { nodeId, retriesUsed: retryCount }, \"useGraphData\");\n\n\t\t\t\t// Fallback to service\n\t\t\t\tstore.setLoading(true);\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn(\"graph\", \"About to call service.expandNode\", { nodeId, options }, \"useGraphData\");\n\t\t\t\t\tawait service.expandNode(nodeId, options);\n\t\t\t\t\tlogger.warn(\"graph\", \"service.expandNode completed\", { nodeId }, \"useGraphData\");\n\n\t\t\t\t// Recalculate depths after expansion using first pinned node\n\t\t\t\tconst pinnedNodes = Object.keys(store.pinnedNodes);\n\t\t\t\tconst firstPinnedNodeId = pinnedNodes[0];\n\t\t\t\tif (firstPinnedNodeId) {\n\t\t\t\t\tstore.calculateNodeDepths(firstPinnedNodeId);\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\"graph\", \"Node expansion completed via service fallback\", { nodeId }, \"useGraphData\");\n\t\t\t} catch (err) {\n\t\t\t\tlogger.error(\"graph\", \"Service fallback expansion failed\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\terror: err instanceof Error ? err.message : \"Unknown error\"\n\t\t\t\t}, \"useGraphData\");\n\t\t\t\tlogError(logger, \"Failed to expand node via service fallback\", err, \"useGraphData\", \"graph\");\n\t\t\t\tstore.setError(err instanceof Error ? err.message : \"Failed to expand node\");\n\t\t\t} finally {\n\t\t\t\tstore.setLoading(false);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tlogger.debug(\"graph\", \"Worker became ready after retries\", { nodeId, retriesUsed: retryCount }, \"useGraphData\");\n\t\t}\n\t}\n\n\t// Verify node type is valid\n\t\tconst expansionTarget = safeParseExpansionTarget(node.type);\n\t\tif (!expansionTarget) {\n\t\t\tlogger.warn(\"graph\", \"Invalid node type for expansion\", { nodeId, nodeType: node.type }, \"useGraphData\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Use force worker for expansion\n\t\ttry {\n\t\t\tlogger.debug(\"graph\", \"Starting node expansion via force worker\", {\n\t\t\t\tnodeId,\n\t\t\t\tentityType: node.type,\n\t\t\t\toptions,\n\t\t\t\tworkerReady: forceWorker.isWorkerReady\n\t\t\t}, \"useGraphData\");\n\n\t\t\tawait service.expandNode(nodeId, options);\n\t\t} catch (err) {\n\t\t\tlogger.error(\"graph\", \"Force worker expansion failed\", {\n\t\t\t\tnodeId,\n\t\t\t\terror: err instanceof Error ? err.message : \"Unknown error\"\n\t\t\t}, \"useGraphData\");\n\t\t\tlogError(logger, \"Failed to expand node via force worker\", err, \"useGraphData\", \"graph\");\n\t\t\t\t\tstore.setError(err instanceof Error ? err.message : \"Failed to expand node\");\n\t\t\t\t}\n \t\t} catch (error) {\n \t\t\tconsole.log(\"DEBUG: useGraphData.expandNode ERROR\", { nodeId, error: error instanceof Error ? error.message : String(error) });\n \t\t}\n \t}, [forceWorker, service]);\n\n\tconst expandAllNodesOfType = useCallback(async (entityType: EntityType, options?: {\n\t\tdepth?: number;\n\t\tlimit?: number;\n\t\tforce?: boolean;\n\t}) => {\n\t\tconst store = useGraphStore.getState();\n\t\tstore.setLoading(true);\n\n\t\t// Use traversal depth from store if not specified\n\t\tconst depth = options?.depth ?? store.traversalDepth;\n\t\tconst limit = options?.limit ?? 10;\n\t\tconst force = options?.force ?? true;\n\n\t\tlogger.debug(\"graph\", \"expandAllNodesOfType called\", {\n\t\t\tentityType,\n\t\t\tdepth,\n\t\t\tlimit,\n\t\t\tforce\n\t\t}, \"useGraphData\");\n\n\t\ttry {\n\t\t\tawait service.expandAllNodesOfType(entityType, {\n\t\t\t\tdepth,\n\t\t\t\tlimit,\n\t\t\t\tforce\n\t\t\t});\n\n\t\t\t// Recalculate depths after expansion using first pinned node\n\t\t\tconst pinnedNodes = Object.keys(store.pinnedNodes);\n\t\t\tconst firstPinnedNodeId = pinnedNodes[0];\n\t\t\tif (firstPinnedNodeId) {\n\t\t\t\tstore.calculateNodeDepths(firstPinnedNodeId);\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", \"expandAllNodesOfType completed successfully\", {\n\t\t\t\tentityType\n\t\t\t}, \"useGraphData\");\n\t\t} catch (err) {\n\t\t\tlogger.error(\"graph\", \"expandAllNodesOfType failed\", {\n\t\t\t\tentityType,\n\t\t\t\terror: err instanceof Error ? err.message : \"Unknown error\"\n\t\t\t}, \"useGraphData\");\n\t\t\tlogError(logger, \"Failed to expand all nodes of type in graph data hook\", err, \"useGraphData\", \"graph\");\n\t\t\tstore.setError(err instanceof Error ? err.message : `Failed to expand all ${entityType} nodes`);\n\t\t} finally {\n\t\t\tstore.setLoading(false);\n\t\t}\n\t}, [service]);\n\n\tconst search = useCallback(async (query: string, options?: Partial<SearchOptions>) => {\n\t\tconst searchOptions: SearchOptions = {\n\t\t\tquery,\n\t\t\tentityTypes: options?.entityTypes || [\"works\", \"authors\", \"sources\", \"institutions\"],\n\t\t\tincludeExternalIds: options?.includeExternalIds ?? true,\n\t\t\tpreferExternalIdResults: options?.preferExternalIdResults ?? false,\n\t\t\tlimit: options?.limit || 20,\n\t\t};\n\n\t\ttry {\n\t\t\tawait service.searchAndVisualize(query, searchOptions);\n\t\t} catch (err) {\n\t\t\tlogError(logger, \"Failed to perform graph search operation\", err, \"useGraphData\", \"graph\");\n\t\t}\n\t}, [service]);\n\n\tconst loadAllCachedNodes = useCallback(() => {\n\t\ttry {\n\t\t\tservice.loadAllCachedNodes();\n\t\t} catch (err) {\n\t\t\tlogError(logger, \"Failed to load cached nodes in graph data hook\", err, \"useGraphData\", \"graph\");\n\t\t}\n\t}, [service]);\n\n\n\tconst clearGraph = useCallback(() => {\n\t\tconst { clear } = useGraphStore.getState();\n\t\tclear();\n\t}, []);\n\n\tconst hydrateNode = useCallback(async (nodeId: string) => {\n\t\ttry {\n\t\t\tawait service.hydrateNode(nodeId);\n\t\t} catch (err) {\n\t\t\tlogError(logger, \"Failed to hydrate node in graph data hook\", err, \"useGraphData\", \"graph\");\n\t\t}\n\t}, [service]);\n\n\treturn {\n\t\tloadEntity,\n\t\tloadEntityIntoGraph,\n\t\tloadEntityIntoRepository,\n\t\tloadAllCachedNodes,\n\t\texpandNode,\n\t\texpandAllNodesOfType,\n\t\tsearch,\n\t\tclearGraph,\n\t\thydrateNode,\n\t\tisLoading,\n\t\terror,\n\t};\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-graph-persistence.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":116,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":116,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3962,3964],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":221,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":221,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7039,7041],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.","line":225,"column":21,"nodeType":"ConditionalExpression","messageId":"preferNullishOverTernary","endLine":225,"endColumn":108,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[7154,7241],"text":"updates.description ?? session.metadata?.description"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for persisting and restoring graph sessions\n * Enables researchers to save their work and continue later\n */\n\nimport { useCallback } from \"react\"\nimport { useGraphStore } from \"@/stores/graph-store\"\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphSnapshot } from \"@academic-explorer/graph\";\n\ninterface GraphSession {\n  id: string\n  name: string\n  createdAt: Date\n  lastModified: Date\n  snapshot: GraphSnapshot\n  metadata?: {\n    entityCounts: {\n      works: number\n      authors: number\n      sources: number\n      institutions: number\n      total: number\n    }\n    description?: string | undefined\n  }\n}\n\nconst STORAGE_KEY = \"academic-explorer-sessions\"\nconst MAX_SESSIONS = 10 // Limit to prevent localStorage bloat\n\n// Type guard for Record<string, unknown>\nfunction isRecord(obj: unknown): obj is Record<string, unknown> {\n\treturn obj !== null && typeof obj === \"object\"\n}\n\n// Helper function for safe property access\nfunction hasProperty(obj: unknown, prop: string): boolean {\n\treturn isRecord(obj) && Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n// Helper function for safe property value extraction\nfunction getProperty(obj: unknown, prop: string): unknown {\n\tif (!hasProperty(obj, prop) || !isRecord(obj)) return undefined\n\treturn obj[prop]\n}\n\n// Type guard for GraphSession objects\nfunction isValidGraphSession(obj: unknown): obj is GraphSession {\n\tif (!obj || typeof obj !== \"object\") return false\n\n\t// Check required properties exist\n\tif (!hasProperty(obj, \"id\") || !hasProperty(obj, \"name\") || !hasProperty(obj, \"snapshot\")) return false\n\n\t// Validate property types\n\tconst id = getProperty(obj, \"id\")\n\tconst name = getProperty(obj, \"name\")\n\tif (typeof id !== \"string\" || typeof name !== \"string\") return false\n\n\t// Validate optional date properties\n\tconst createdAt = getProperty(obj, \"createdAt\")\n\tconst lastModified = getProperty(obj, \"lastModified\")\n\n\tconst createdAtValid = createdAt === undefined || typeof createdAt === \"string\" || createdAt instanceof Date\n\tconst lastModifiedValid = lastModified === undefined || typeof lastModified === \"string\" || lastModified instanceof Date\n\n\tif (!createdAtValid || !lastModifiedValid) return false\n\n\t// Validate snapshot structure\n\tconst snapshot = getProperty(obj, \"snapshot\")\n\tif (!snapshot || typeof snapshot !== \"object\") return false\n\n\t// Check snapshot has required array properties\n\tconst nodes = getProperty(snapshot, \"nodes\")\n\tconst edges = getProperty(snapshot, \"edges\")\n\n\treturn Array.isArray(nodes) && Array.isArray(edges)\n}\n\nexport function useGraphPersistence() {\n\t// Load all saved sessions\n\tconst loadSessions = useCallback((): GraphSession[] => {\n\t\ttry {\n\t\t\tconst stored = localStorage.getItem(STORAGE_KEY)\n\t\t\tif (!stored) return []\n\n\t\t\tconst parsed: unknown = JSON.parse(stored)\n\t\t\tif (!Array.isArray(parsed)) {\n\t\t\t\tlogger.warn(\"storage\", \"Invalid sessions data format, expected array\", { parsed: String(parsed) }, \"useGraphPersistence\")\n\t\t\t\treturn []\n\t\t\t}\n\t\t\tconst sessions = parsed.filter(isValidGraphSession)\n\t\t\treturn sessions.map(session => ({\n\t\t\t\t...session,\n\t\t\t\tcreatedAt: new Date(session.createdAt),\n\t\t\t\tlastModified: new Date(session.lastModified)\n\t\t\t}))\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to load graph sessions from storage\", error, \"useGraphPersistence\", \"storage\")\n\t\t\treturn []\n\t\t}\n\t}, [])\n\n\t// Save current graph as new session\n\tconst saveSession = useCallback((name: string, description?: string): string => {\n\t\tconst store = useGraphStore.getState()\n\n\t\tif (Object.keys(store.nodes).length === 0) {\n\t\t\tthrow new Error(\"Cannot save empty graph\")\n\t\t}\n\n\t\tconst sessionId = `session_${Date.now().toString()}`\n\t\tconst snapshot: GraphSnapshot = {\n\t\t\tnodes: Object.values(store.nodes).filter((node): node is NonNullable<typeof node> => node != null),\n\t\t\tedges: Object.values(store.edges).filter((edge): edge is NonNullable<typeof edge> => edge != null),\n\t\t\tviewport: store.provider?.getSnapshot().viewport || {\n\t\t\t\tzoom: 1,\n\t\t\t\tcenter: { x: 0, y: 0 }\n\t\t\t}\n\t\t}\n\n\t\t// Calculate metadata\n\t\tconst entityCounts = {\n\t\t\tworks: snapshot.nodes.filter(n => n.type === \"works\").length,\n\t\t\tauthors: snapshot.nodes.filter(n => n.type === \"authors\").length,\n\t\t\tsources: snapshot.nodes.filter(n => n.type === \"sources\").length,\n\t\t\tinstitutions: snapshot.nodes.filter(n => n.type === \"institutions\").length,\n\t\t\ttotal: snapshot.nodes.length\n\t\t}\n\n\t\tconst session: GraphSession = {\n\t\t\tid: sessionId,\n\t\t\tname,\n\t\t\tcreatedAt: new Date(),\n\t\t\tlastModified: new Date(),\n\t\t\tsnapshot,\n\t\t\tmetadata: {\n\t\t\t\tentityCounts,\n\t\t\t\tdescription\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst sessions = loadSessions()\n\t\t\tconst updatedSessions = [session, ...sessions].slice(0, MAX_SESSIONS) // Keep most recent\n\t\t\tlocalStorage.setItem(STORAGE_KEY, JSON.stringify(updatedSessions))\n\t\t\treturn sessionId\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to save graph session to storage\", error, \"useGraphPersistence\", \"storage\")\n\t\t\tthrow new Error(\"Failed to save session. Storage might be full.\")\n\t\t}\n\t}, [loadSessions])\n\n\t// Load a session by ID\n\tconst loadSession = useCallback((sessionId: string): boolean => {\n\t\ttry {\n\t\t\tconst sessions = loadSessions()\n\t\t\tconst session = sessions.find(s => s.id === sessionId)\n\n\t\t\tif (!session) {\n\t\t\t\tthrow new Error(\"Session not found\")\n\t\t\t}\n\n\t\t\tconst store = useGraphStore.getState()\n\n\t\t\t// Clear existing graph\n\t\t\tstore.clear()\n\n\t\t\t// Load nodes and edges\n\t\t\tstore.addNodes(session.snapshot.nodes)\n\t\t\tstore.addEdges(session.snapshot.edges)\n\n\t\t\t// Apply layout and fit view\n\t\t\tif (store.provider) {\n\t\t\t\tstore.provider.applyLayout(store.currentLayout)\n\n\t\t\t\t// Restore viewport state if available, otherwise fit view\n\t\t\t\tif (session.snapshot.viewport) {\n\t\t\t\t\tstore.provider.loadSnapshot(session.snapshot)\n\t\t\t\t} else {\n\t\t\t\t\tstore.provider.fitView()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update last modified\n\t\t\tsession.lastModified = new Date()\n\t\t\tconst allSessions = loadSessions()\n\t\t\tconst updatedSessions = allSessions.map(s =>\n\t\t\t\ts.id === sessionId ? session : s\n\t\t\t)\n\t\t\tlocalStorage.setItem(STORAGE_KEY, JSON.stringify(updatedSessions))\n\n\t\t\treturn true\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to load graph session from storage\", error, \"useGraphPersistence\", \"storage\")\n\t\t\treturn false\n\t\t}\n\t}, [loadSessions])\n\n\t// Delete a session\n\tconst deleteSession = useCallback((sessionId: string): boolean => {\n\t\ttry {\n\t\t\tconst sessions = loadSessions()\n\t\t\tconst filteredSessions = sessions.filter(s => s.id !== sessionId)\n\t\t\tlocalStorage.setItem(STORAGE_KEY, JSON.stringify(filteredSessions))\n\t\t\treturn true\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to delete graph session from storage\", error, \"useGraphPersistence\", \"storage\")\n\t\t\treturn false\n\t\t}\n\t}, [loadSessions])\n\n\t// Update session name/description\n\tconst updateSession = useCallback((sessionId: string, updates: { name?: string; description?: string }): boolean => {\n\t\ttry {\n\t\t\tconst sessions = loadSessions()\n\t\t\tconst updatedSessions = sessions.map(session => {\n\t\t\t\tif (session.id === sessionId) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...session,\n\t\t\t\t\t\tname: updates.name || session.name,\n\t\t\t\t\t\tlastModified: new Date(),\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t...session.metadata,\n\t\t\t\t\t\t\tdescription: updates.description !== undefined ? updates.description : session.metadata?.description\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn session\n\t\t\t})\n\t\t\tlocalStorage.setItem(STORAGE_KEY, JSON.stringify(updatedSessions))\n\t\t\treturn true\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to update graph session in storage\", error, \"useGraphPersistence\", \"storage\")\n\t\t\treturn false\n\t\t}\n\t}, [loadSessions])\n\n\t// Auto-save current session (debounced)\n\tconst autoSave = useCallback((sessionName: string = \"Auto-saved Session\") => {\n\t\t// Simple auto-save that creates a new session\n\t\t// In a production app, you might want to update an existing auto-save session\n\t\ttry {\n\t\t\tsaveSession(sessionName, \"Automatically saved\")\n\t\t} catch (error) {\n\t\t\t// Silently fail for auto-save\n\t\t\tlogger.warn(\"storage\", \"Auto-save failed\", { error }, \"useGraphPersistence\")\n\t\t}\n\t}, [saveSession])\n\n\treturn {\n\t\tloadSessions,\n\t\tsaveSession,\n\t\tloadSession,\n\t\tdeleteSession,\n\t\tupdateSession,\n\t\tautoSave\n\t}\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-graph-utilities.ts","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'operationName' is defined but never used. Allowed unused args must match /^_/u.","line":88,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":16},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":252,"column":38,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":252,"endColumn":53},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":274,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":274,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[10155,10157],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":280,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":280,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[10300,10302],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for graph utilities integration with Academic Explorer\n * Provides access to graph manipulation functions with proper store integration\n */\n\nimport { useCallback, useMemo } from \"react\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { graphUtilitiesService, type GraphUtilityResult } from \"@academic-explorer/graph\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { GraphNode, GraphEdge } from \"@academic-explorer/graph\";\n\n// Extended result type for graph utility operations\ninterface GraphOperationResult {\n\tnodes: GraphNode[];\n\tedges: GraphEdge[];\n\tremovedCount: number;\n\toperation: string;\n}\n\n// Type guard to check if result has graph operation properties\nfunction isGraphOperationResult(result: unknown): result is GraphOperationResult {\n\treturn (\n\t\ttypeof result === \"object\" &&\n\t\tresult !== null &&\n\t\t\"nodes\" in result &&\n\t\t\"edges\" in result &&\n\t\t\"removedCount\" in result &&\n\t\t\"operation\" in result &&\n\t\tArray.isArray((result as GraphOperationResult).nodes) &&\n\t\tArray.isArray((result as GraphOperationResult).edges) &&\n\t\ttypeof (result as GraphOperationResult).removedCount === \"number\" &&\n\t\ttypeof (result as GraphOperationResult).operation === \"string\"\n\t);\n}\n\n// Type guard for GraphUtilityResult with data property\nfunction hasDataProperty(result: GraphUtilityResult): result is GraphUtilityResult & { data: unknown } {\n\treturn \"data\" in result && result.data != null;\n}\n\nexport const useGraphUtilities = () => {\n\t// Get current graph state with stable selectors\n\tconst nodesMap = useGraphStore((state) => state.nodes);\n\tconst edgesMap = useGraphStore((state) => state.edges);\n\tconst setGraphData = useGraphStore((state) => state.setGraphData);\n\tconst setLoading = useGraphStore((state) => state.setLoading);\n\tconst setError = useGraphStore((state) => state.setError);\n\n\t// Convert Records to arrays with stable dependencies\n\tconst nodes = useMemo(() => Object.values(nodesMap).filter((node): node is NonNullable<typeof node> => node != null), [nodesMap]);\n\tconst edges = useMemo(() => Object.values(edgesMap).filter((edge): edge is NonNullable<typeof edge> => edge != null), [edgesMap]);\n\n\t// Apply utility result to store\n\tconst applyUtilityResult = useCallback((result: GraphUtilityResult | GraphOperationResult) => {\n\t\t// Handle direct GraphOperationResult\n\t\tif (isGraphOperationResult(result)) {\n\t\t\tlogger.debug(\"graph\", `Applied graph utility: ${result.operation}`, {\n\t\t\t\toperation: result.operation,\n\t\t\t\tnodesAfter: result.nodes.length,\n\t\t\t\tedgesAfter: result.edges.length,\n\t\t\t\tremovedCount: result.removedCount\n\t\t\t});\n\t\t\tsetGraphData(result.nodes, result.edges);\n\t\t\treturn;\n\t\t}\n\n\t\t// Handle GraphUtilityResult with data property\n\t\tif (hasDataProperty(result) && isGraphOperationResult(result.data)) {\n\t\t\tconst operationResult = result.data;\n\t\t\tlogger.debug(\"graph\", `Applied graph utility: ${operationResult.operation}`, {\n\t\t\t\toperation: operationResult.operation,\n\t\t\t\tnodesAfter: operationResult.nodes.length,\n\t\t\t\tedgesAfter: operationResult.edges.length,\n\t\t\t\tremovedCount: operationResult.removedCount\n\t\t\t});\n\t\t\tsetGraphData(operationResult.nodes, operationResult.edges);\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback - log the actual structure for debugging\n\t\tlogger.warn(\"graph\", \"Unexpected result structure from graph utility\", { result });\n\t}, [setGraphData]);\n\n\t// Safe method caller for graph utilities service\n\tconst callServiceMethod = useCallback((\n\t\tmethodName: string,\n\t\targs: unknown[],\n\t\toperationName: string\n\t): GraphOperationResult | GraphUtilityResult => {\n\t\tconst service = graphUtilitiesService as unknown as Record<string, unknown>;\n\n\t\tif (typeof service[methodName] === \"function\") {\n\t\t\tconst method = service[methodName] as (...args: unknown[]) => unknown;\n\t\t\treturn method(...args) as GraphOperationResult | GraphUtilityResult;\n\t\t}\n\n\t\t// Return a stub result if method doesn't exist\n\t\tlogger.warn(\"graph\", `Method ${methodName} not available on graphUtilitiesService`);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage: `Method ${methodName} not implemented`,\n\t\t\terrors: [`${methodName} is not available on the current graph utilities service`]\n\t\t} as GraphUtilityResult;\n\t}, []);\n\n\t// Utility functions with proper error handling\n\tconst trimLeafNodes = useCallback(() => {\n\t\tsetLoading(true);\n\t\tsetError(null);\n\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"trimLeafNodes\", [nodes, edges], \"trimLeafNodes\");\n\t\t\tapplyUtilityResult(result);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Trim leaf nodes failed\", { error: errorMessage });\n\t\t\tsetError(`Failed to trim leaf nodes: ${errorMessage}`);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tsetLoading(false);\n\t\t}\n\t}, [nodes, edges, applyUtilityResult, setLoading, setError, callServiceMethod]);\n\n\tconst trimRootNodes = useCallback(() => {\n\t\tsetLoading(true);\n\t\tsetError(null);\n\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"trimRootNodes\", [nodes, edges], \"trimRootNodes\");\n\t\t\tapplyUtilityResult(result);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Trim root nodes failed\", { error: errorMessage });\n\t\t\tsetError(`Failed to trim root nodes: ${errorMessage}`);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tsetLoading(false);\n\t\t}\n\t}, [nodes, edges, applyUtilityResult, setLoading, setError, callServiceMethod]);\n\n\tconst trimDegree1Nodes = useCallback(() => {\n\t\tsetLoading(true);\n\t\tsetError(null);\n\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"trimDegree1Nodes\", [nodes, edges], \"trimDegree1Nodes\");\n\t\t\tapplyUtilityResult(result);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Trim degree 1 nodes failed\", { error: errorMessage });\n\t\t\tsetError(`Failed to trim degree 1 nodes: ${errorMessage}`);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tsetLoading(false);\n\t\t}\n\t}, [nodes, edges, applyUtilityResult, setLoading, setError, callServiceMethod]);\n\n\tconst removeIsolatedNodes = useCallback(() => {\n\t\tsetLoading(true);\n\t\tsetError(null);\n\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"removeIsolatedNodes\", [nodes, edges], \"removeIsolatedNodes\");\n\t\t\tapplyUtilityResult(result);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Remove isolated nodes failed\", { error: errorMessage });\n\t\t\tsetError(`Failed to remove isolated nodes: ${errorMessage}`);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tsetLoading(false);\n\t\t}\n\t}, [nodes, edges, applyUtilityResult, setLoading, setError, callServiceMethod]);\n\n\tconst filterByPublicationYear = useCallback((minYear: number, maxYear: number) => {\n\t\tsetLoading(true);\n\t\tsetError(null);\n\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"filterByPublicationYear\", [nodes, edges, minYear, maxYear], \"filterByPublicationYear\");\n\t\t\tapplyUtilityResult(result);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Filter by publication year failed\", {\n\t\t\t\terror: errorMessage,\n\t\t\t\tminYear,\n\t\t\t\tmaxYear\n\t\t\t});\n\t\t\tsetError(`Failed to filter by publication year: ${errorMessage}`);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tsetLoading(false);\n\t\t}\n\t}, [nodes, edges, applyUtilityResult, setLoading, setError, callServiceMethod]);\n\n\tconst extractEgoNetwork = useCallback((centerNodeId: string, hops: number = 2) => {\n\t\tsetLoading(true);\n\t\tsetError(null);\n\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"extractEgoNetwork\", [nodes, edges, centerNodeId, hops], \"extractEgoNetwork\");\n\t\t\tapplyUtilityResult(result);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Extract ego network failed\", {\n\t\t\t\terror: errorMessage,\n\t\t\t\tcenterNodeId,\n\t\t\t\thops\n\t\t\t});\n\t\t\tsetError(`Failed to extract ego network: ${errorMessage}`);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tsetLoading(false);\n\t\t}\n\t}, [nodes, edges, applyUtilityResult, setLoading, setError, callServiceMethod]);\n\n\tconst getLargestConnectedComponent = useCallback(() => {\n\t\tsetLoading(true);\n\t\tsetError(null);\n\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"getLargestConnectedComponent\", [nodes, edges], \"getLargestConnectedComponent\");\n\t\t\tapplyUtilityResult(result);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Get largest connected component failed\", { error: errorMessage });\n\t\t\tsetError(`Failed to get largest connected component: ${errorMessage}`);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tsetLoading(false);\n\t\t}\n\t}, [nodes, edges, applyUtilityResult, setLoading, setError, callServiceMethod]);\n\n\t// Analysis functions that don't modify the graph\n\tconst findConnectedComponents = useCallback((): string[][] => {\n\t\ttry {\n\t\t\tconst result = callServiceMethod(\"findConnectedComponents\", [nodes, edges], \"findConnectedComponents\");\n\n\t\t\t// Handle direct array result\n\t\t\tif (Array.isArray(result)) {\n\t\t\t\treturn result as string[][];\n\t\t\t}\n\n\t\t\t// Handle GraphUtilityResult with data property\n\t\t\tif (typeof result === \"object\" && result !== null && \"data\" in result && Array.isArray((result as GraphUtilityResult & { data: unknown }).data)) {\n\t\t\t\treturn (result as GraphUtilityResult & { data: string[][] }).data;\n\t\t\t}\n\n\t\t\t// Fallback for no actual implementation\n\t\t\tlogger.warn(\"graph\", \"findConnectedComponents returned unexpected result\", { result });\n\t\t\treturn [];\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tlogger.error(\"graph\", \"Find connected components failed\", { error: errorMessage });\n\t\t\treturn []; // Return empty array instead of throwing\n\t\t}\n\t}, [nodes, edges, callServiceMethod]);\n\n\t// Graph statistics\n\tconst getGraphStats = useCallback(() => {\n\t\tconst components = findConnectedComponents();\n\t\tconst nodesByType: Record<string, number> = {};\n\t\tconst edgesByType: Record<string, number> = {};\n\n\t\t// Count nodes by type\n\t\tnodes.forEach((node) => {\n\t\t\tconst count = nodesByType[node.type] || 0;\n\t\t\tnodesByType[node.type] = count + 1;\n\t\t});\n\n\t\t// Count edges by type\n\t\tedges.forEach((edge) => {\n\t\t\tconst count = edgesByType[edge.type] || 0;\n\t\t\tedgesByType[edge.type] = count + 1;\n\t\t});\n\n\t\treturn {\n\t\t\ttotalNodes: nodes.length,\n\t\t\ttotalEdges: edges.length,\n\t\t\tconnectedComponents: components.length,\n\t\t\tlargestComponentSize: components.length > 0 ? Math.max(...components.map((component: string[]) => component.length)) : 0,\n\t\t\tnodesByType,\n\t\t\tedgesByType,\n\t\t};\n\t}, [nodes, edges, findConnectedComponents]);\n\n\treturn {\n\t\t// Graph modification utilities\n\t\ttrimLeafNodes,\n\t\ttrimRootNodes,\n\t\ttrimDegree1Nodes,\n\t\tremoveIsolatedNodes,\n\t\tfilterByPublicationYear,\n\t\textractEgoNetwork,\n\t\tgetLargestConnectedComponent,\n\n\t\t// Analysis utilities (read-only)\n\t\tfindConnectedComponents,\n\t\tgetGraphStats,\n\n\t\t// Current state\n\t\tnodeCount: nodes.length,\n\t\tedgeCount: edges.length,\n\t};\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-raw-entity-data.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":43,"column":7,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":43,"endColumn":27},{"ruleId":"prefer-destructuring","severity":2,"message":"Use object destructuring.","line":44,"column":4,"nodeType":"AssignmentExpression","messageId":"preferDestructuring","endLine":44,"endColumn":37},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'queryFn' has no 'await' expression.","line":61,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":61,"endColumn":18,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2163,2169],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":88,"column":8,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":88,"endColumn":41}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook to fetch raw OpenAlex entity data on demand\n * Uses the proper cache system with Memory → IndexedDB → localStorage → API hierarchy\n */\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { EntityDetector } from \"@academic-explorer/graph\";\nimport type { OpenAlexEntity } from \"@academic-explorer/client\";\nimport type { EntityType } from \"../config/cache\";\nimport { ENTITY_CACHE_TIMES } from \"../config/cache\";\nimport { logger } from \"@academic-explorer/utils\";\n\ninterface UseRawEntityDataOptions {\n  entityId?: string | null;\n  enabled?: boolean;\n}\n\n\n/**\n * Type guard to check if we have a valid entity type for the query\n */\nfunction isValidEntityData(entityId: string | null | undefined, entityType: EntityType | null): entityType is EntityType {\n\treturn !!entityId && !!entityType;\n}\n\nexport const useRawEntityData = (options: UseRawEntityDataOptions) => {\n\tconst { entityId, enabled = true } = options;\n\n\t// Detect entity type from ID to use proper cache configuration\n\tlet entityType: EntityType | null = null;\n\tlet detectedEntityId: string | null = null;\n\n\tif (entityId) {\n\t\tconst detector = new EntityDetector();\n\t\tconst detection = detector.detectEntityIdentifier(entityId);\n\n\t\tif (!detection.entityType) {\n\t\t\tthrow new Error(`Unable to detect entity type for: ${entityId}`);\n\t\t}\n\n\t\t// Since cache configuration now uses plural forms that match OpenAlex API endpoints,\n\t\t// we can use the detected entity type directly if it's a valid cache entity type\n\t\tif (detection.entityType && detection.entityType in ENTITY_CACHE_TIMES) {\n\t\t\tentityType = detection.entityType;\n\t\t} else {\n\t\t\tthrow new Error(`Detected entity type \"${detection.entityType}\" is not a valid cache entity type`);\n\t\t}\n\t\tdetectedEntityId = detection.normalizedId;\n\t\tlogger.debug(\"cache\", \"Detected entity type for raw data cache\", {\n\t\t\tentityId,\n\t\t\tdetectedType: detection.entityType,\n\t\t\tcacheType: entityType\n\t\t}, \"useRawEntityData\");\n\t}\n\n\t// Always call the hook, but conditionally enable it\n\tconst shouldFetch = enabled && isValidEntityData(detectedEntityId, entityType);\n\n\tconst query = useQuery({\n\t\tqueryKey: [\"raw-entity\", entityType, detectedEntityId],\n\t\tqueryFn: async () => {\n\t\t\tif (!entityType || !detectedEntityId) {\n\t\t\t\tthrow new Error(\"Entity type and ID required for fetching\");\n\t\t\t}\n\n\t\t\t// This would be replaced with actual OpenAlex API call\n\t\t\t// For now, return a mock response to match expected structure\n\t\t\tlogger.debug(\"api\", \"Fetching raw entity data\", {\n\t\t\t\tentityType,\n\t\t\t\tentityId: detectedEntityId\n\t\t\t}, \"useRawEntityData\");\n\n\t\t\t// TODO: Replace with actual OpenAlex API client call\n\t\t\treturn null as OpenAlexEntity | null;\n\t\t},\n\t\tenabled: shouldFetch,\n\t\tstaleTime: entityType ? ENTITY_CACHE_TIMES[entityType].stale : ENTITY_CACHE_TIMES.works.stale,\n\t\tgcTime: entityType ? ENTITY_CACHE_TIMES[entityType].gc : ENTITY_CACHE_TIMES.works.gc,\n\t});\n\n\t// Enhanced logging for cache behavior tracking\n\tif (query.data) {\n\t\tlogger.debug(\"cache\", \"Raw entity data loaded from cache system\", {\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\tfromCache: !query.isFetching,\n\t\t\tcacheStatus: query.status,\n\t\t\t...(query.dataUpdatedAt !== undefined && { dataAge: Date.now() - query.dataUpdatedAt })\n\t\t}, \"useRawEntityData\");\n\t}\n\n\tif (query.error) {\n\t\tlogger.error(\"cache\", \"Failed to fetch raw entity data\", {\n\t\t\tentityId,\n\t\t\tentityType,\n\t\t\terror: query.error instanceof Error ? query.error.message : \"Unknown error\"\n\t\t}, \"useRawEntityData\");\n\t}\n\n\treturn query;\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-theme-colors.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":28,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":28,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[842,844],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":38,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":38,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1112,1114],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":38,"column":66,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":38,"endColumn":68,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1137,1139],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":39,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":39,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1183,1185],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":39,"column":65,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":39,"endColumn":67,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1208,1210],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":40,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":40,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1253,1255],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":40,"column":64,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":40,"endColumn":66,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1278,1280],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":46,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":46,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1470,1472],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":46,"column":66,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":46,"endColumn":68,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1495,1497],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":47,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":47,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1541,1543],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":47,"column":65,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":47,"endColumn":67,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1566,1568],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":55,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":55,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1907,1909],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":55,"column":66,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":55,"endColumn":68,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1932,1934],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":59,"column":29,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":59,"endColumn":31,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1994,1996],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":60,"column":30,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":60,"endColumn":32,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2043,2045],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":61,"column":31,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":61,"endColumn":33,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2093,2095],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":62,"column":26,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":62,"endColumn":28,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2138,2140],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":63,"column":26,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":63,"endColumn":28,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2183,2185],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":67,"column":27,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":67,"endColumn":29,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2270,2272],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":68,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":68,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2313,2315],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":68,"column":42,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":68,"endColumn":44,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2331,2333],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":69,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":69,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2368,2370],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":69,"column":42,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":69,"endColumn":44,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2386,2388],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":70,"column":29,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":70,"endColumn":31,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2428,2430],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":70,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":70,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2451,2453],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":71,"column":29,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":71,"endColumn":31,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2493,2495],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":72,"column":27,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":72,"endColumn":29,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2539,2541],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":73,"column":32,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":73,"endColumn":34,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2590,2592],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":74,"column":29,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":74,"endColumn":31,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2638,2640],"text":""},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":119,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":119,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3781,3783],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":30,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Theme colors utility hook\n * Provides consistent access to theme colors across light and dark modes\n */\n\nimport { useMantineColorScheme, useMantineTheme } from \"@mantine/core\";\n\nexport function useThemeColors() {\n\tconst theme = useMantineTheme();\n\tconst { colorScheme } = useMantineColorScheme();\n\n\t// Resolve the actual color scheme when colorScheme is 'auto'\n\tconst resolvedColorScheme = colorScheme === \"auto\"\n\t\t? (() => {\n\t\t\ttry {\n\t\t\t\treturn window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n\t\t\t} catch {\n\t\t\t\treturn \"light\"; // Fallback to light mode if matchMedia fails\n\t\t\t}\n\t\t})()\n\t\t: colorScheme;\n\n\tconst isDark = resolvedColorScheme === \"dark\";\n\n\t// Base color utilities\n\tconst getColor = (color: string, shade: number = 5) => {\n\t\tif (color in theme.colors) {\n\t\t\treturn theme.colors[color]?.[shade] || color;\n\t\t}\n\t\treturn color;\n\t};\n\n\t// Semantic colors that adapt to light/dark mode\n\tconst colors = {\n\t\t// Text colors - using Mantine CSS variables for better theme integration\n\t\ttext: {\n\t\t\tprimary: \"var(--mantine-color-text)\",\n\t\t\tsecondary: isDark ? theme.colors.gray?.[3] : theme.colors.gray?.[6],\n\t\t\ttertiary: isDark ? theme.colors.gray?.[4] : theme.colors.gray?.[5],\n\t\t\tinverse: isDark ? theme.colors.gray?.[9] : theme.colors.gray?.[0],\n\t\t},\n\n\t\t// Background colors - using Mantine CSS variables for better theme integration\n\t\tbackground: {\n\t\t\tprimary: \"var(--mantine-color-body)\",\n\t\t\tsecondary: isDark ? theme.colors.gray?.[8] : theme.colors.gray?.[0],\n\t\t\ttertiary: isDark ? theme.colors.gray?.[7] : theme.colors.gray?.[1],\n\t\t\toverlay: isDark ? \"rgba(0, 0, 0, 0.8)\" : \"rgba(255, 255, 255, 0.95)\",\n\t\t\tblur: isDark ? \"rgba(31, 41, 55, 0.95)\" : \"rgba(255, 255, 255, 0.95)\",\n\t\t},\n\n\t\t// Border colors - using Mantine CSS variables for better theme integration\n\t\tborder: {\n\t\t\tprimary: \"var(--mantine-color-default-border)\",\n\t\t\tsecondary: isDark ? theme.colors.gray?.[6] : theme.colors.gray?.[3],\n\t\t},\n\n\t\t// Semantic colors\n\t\tprimary: theme.colors.blue?.[5] || \"#228be6\",\n\t\tsuccess: theme.colors.green?.[5] || \"#10b981\",\n\t\twarning: theme.colors.yellow?.[5] || \"#f59e0b\",\n\t\terror: theme.colors.red?.[5] || \"#ef4444\",\n\t\tinfo: theme.colors.blue?.[5] || \"#228be6\",\n\n\t\t// Academic entity colors\n\t\tentity: {\n\t\t\twork: theme.colors.blue?.[5] || \"#228be6\",\n\t\t\tauthor: theme.colors?.['author']?.[5] || \"#10b981\",\n\t\t\tsource: theme.colors?.['source']?.[5] || \"#8b5cf6\",\n\t\t\tinstitution: theme.colors?.['institution']?.[5] || \"#f59e0b\",\n\t\t\tconcept: theme.colors.red?.[5] || \"#ef4444\",\n\t\t\ttopic: theme.colors.red?.[5] || \"#ef4444\",\n\t\t\tpublisher: theme.colors.cyan?.[5] || \"#06b6d4\",\n\t\t\tfunder: theme.colors.pink?.[5] || \"#ec4899\",\n\t\t},\n\t};\n\n\t// Type guard for valid entity color keys\n\tconst isValidEntityColorKey = (key: string): key is keyof typeof colors.entity => {\n\t\tconst validKeys = [\n\t\t\t\"work\", \"author\", \"source\", \"institution\", \"concept\", \"topic\", \"publisher\", \"funder\"\n\t\t];\n\t\treturn validKeys.includes(key);\n\t};\n\n\t// Entity color utilities\n\tconst getEntityColor = (entityType: string): string => {\n\t\tconst normalizedType = entityType.toLowerCase();\n\n\t\tif (isValidEntityColorKey(normalizedType)) {\n\t\t\treturn colors.entity[normalizedType];\n\t\t}\n\n\t\treturn colors.primary;\n\t};\n\n\tconst getEntityColorShade = (entityType: string, shade: number = 5): string => {\n\t\tconst normalizedType = entityType.toLowerCase();\n\n\t\tconst colorMap: Record<string, string> = {\n\t\t\twork: \"blue\",\n\t\t\tworks: \"blue\",\n\t\t\tauthor: \"author\",\n\t\t\tauthors: \"author\",\n\t\t\tsource: \"source\",\n\t\t\tsources: \"source\",\n\t\t\tinstitution: \"institution\",\n\t\t\tinstitutions: \"institution\",\n\t\t\tconcept: \"red\",\n\t\t\tconcepts: \"red\",\n\t\t\ttopic: \"red\",\n\t\t\ttopics: \"red\",\n\t\t\tpublisher: \"cyan\",\n\t\t\tpublishers: \"cyan\",\n\t\t\tfunder: \"pink\",\n\t\t\tfunders: \"pink\",\n\t\t};\n\n\t\tconst colorKey = colorMap[normalizedType] || \"blue\";\n\t\treturn getColor(colorKey, shade);\n\t};\n\n\treturn {\n\t\tcolors,\n\t\tgetColor,\n\t\tgetEntityColor,\n\t\tgetEntityColorShade,\n\t\tisDark,\n\t\ttheme,\n\t};\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-unified-event-system.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":34,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":38,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[1322,1456],"text":"busRef.current ??= channelName\n      ? createCrossTabEventBus(channelName)\n      : createLocalEventBus();"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.","line":81,"column":23,"nodeType":"SpreadElement","endLine":81,"endColumn":30},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":101,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":103,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[2994,3084],"text":"taskQueueRef.current ??= createTaskQueue(bus, options);"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":181,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":183,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[4834,4927],"text":"workerPoolRef.current ??= createWorkerPool(bus, options);"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":263,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":265,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[6983,7093],"text":"coordinatorRef.current ??= createQueuedResourceCoordinator(bus, options);"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":371,"column":51,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":371,"endColumn":67},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":395,"column":51,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":395,"endColumn":67},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":406,"column":51,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":406,"endColumn":67},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":419,"column":51,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":419,"endColumn":67},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":425,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":425,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[11492,11494],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":431,"column":51,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":431,"endColumn":67}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Unified Event System Hooks\n * React hooks for integrating with the unified EventBus, TaskQueue, and QueuedResourceCoordinator\n * Based on the ChatGPT document specification for React integration\n */\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { EventBus, EventHandler, createLocalEventBus, createCrossTabEventBus } from \"@academic-explorer/graph\";\nimport { TaskQueue, TaskDescriptor, TaskResult, TaskStatus, createTaskQueue } from \"@academic-explorer/graph\";\nimport { WorkerPool, WorkerPoolOptions, createWorkerPool } from \"@academic-explorer/graph\";\nimport { QueuedResourceCoordinator, QueueCoordinatorOptions, createQueuedResourceCoordinator } from \"@academic-explorer/graph\";\n\n// Type guard for TaskResult\nfunction isTaskResult(value: unknown): value is TaskResult {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"id\" in value &&\n    typeof value.id === \"string\" &&\n    \"duration\" in value &&\n    typeof value.duration === \"number\" &&\n    \"executedBy\" in value &&\n    (value.executedBy === \"main\" || value.executedBy === \"worker\")\n  );\n}\n\n/**\n * Hook for managing EventBus instances\n */\nexport function useEventBus(channelName?: string): EventBus {\n  const busRef = useRef<EventBus | null>(null);\n\n  if (!busRef.current) {\n    busRef.current = channelName\n      ? createCrossTabEventBus(channelName)\n      : createLocalEventBus();\n  }\n\n  useEffect(() => {\n    return () => {\n      if (busRef.current) {\n        busRef.current.close();\n        busRef.current = null;\n      }\n    };\n  }, []);\n\n  return busRef.current;\n}\n\n/**\n * Hook for listening to specific event types\n */\nexport function useEventListener(\n  bus: EventBus,\n  eventType: string,\n  handler: (payload?: unknown) => void,\n  deps: React.DependencyList = []\n): void {\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  useEffect(() => {\n    const wrappedHandler: EventHandler = (event) => {\n      handlerRef.current(event.payload);\n    };\n\n    const listenerId = bus.on(eventType, wrappedHandler);\n\n    logger.debug(\"hooks\", \"Event listener registered\", {\n      eventType,\n      listenerId,\n      isBroadcasting: bus.isBroadcasting()\n    });\n\n    return () => {\n      bus.off(eventType, wrappedHandler);\n      logger.debug(\"hooks\", \"Event listener removed\", { eventType, listenerId });\n    };\n  }, [bus, eventType, ...deps]);\n}\n\n/**\n * Hook for managing TaskQueue\n */\nexport function useTaskQueue(\n  bus: EventBus,\n  options: { maxConcurrency?: number } = {}\n): {\n  taskQueue: TaskQueue;\n  submitTask: (task: TaskDescriptor) => Promise<string>;\n  cancelTask: (taskId: string) => boolean;\n  getTaskStatus: (taskId: string) => TaskStatus | null;\n  clearQueue: () => void;\n  stats: ReturnType<TaskQueue[\"getStats\"]>;\n} {\n  const taskQueueRef = useRef<TaskQueue | null>(null);\n  const [stats, setStats] = useState({ queueLength: 0, activeTasks: 0, processing: false, maxConcurrency: 1 });\n\n  if (!taskQueueRef.current) {\n    taskQueueRef.current = createTaskQueue(bus, options);\n  }\n\n  const taskQueue = taskQueueRef.current;\n\n  // Update stats when tasks change\n  useEventListener(bus, \"TASK_ENQUEUED\", () => {\n    setStats(taskQueue.getStats());\n  });\n\n  useEventListener(bus, \"TASK_STARTED\", () => {\n    setStats(taskQueue.getStats());\n  });\n\n  useEventListener(bus, \"TASK_COMPLETED\", () => {\n    setStats(taskQueue.getStats());\n  });\n\n  useEventListener(bus, \"TASK_FAILED\", () => {\n    setStats(taskQueue.getStats());\n  });\n\n  useEventListener(bus, \"QUEUE_CLEARED\", () => {\n    setStats(taskQueue.getStats());\n  });\n\n  const submitTask = useCallback((task: TaskDescriptor) => {\n    return Promise.resolve(taskQueue.enqueue(task));\n  }, [taskQueue]);\n\n  const cancelTask = useCallback((taskId: string) => {\n    return taskQueue.cancel(taskId);\n  }, [taskQueue]);\n\n  const getTaskStatus = useCallback((taskId: string) => {\n    return taskQueue.getTaskStatus(taskId);\n  }, [taskQueue]);\n\n  const clearQueue = useCallback(() => {\n    taskQueue.clear();\n  }, [taskQueue]);\n\n  useEffect(() => {\n    setStats(taskQueue.getStats());\n  }, [taskQueue]);\n\n  return {\n    taskQueue,\n    submitTask,\n    cancelTask,\n    getTaskStatus,\n    clearQueue,\n    stats\n  };\n}\n\n/**\n * Hook for managing WorkerPool\n */\nexport function useWorkerPool(\n  bus: EventBus,\n  options: WorkerPoolOptions\n): {\n  workerPool: WorkerPool;\n  submitTask: (taskId: string, payload: unknown, timeout?: number) => Promise<unknown>;\n  stats: ReturnType<WorkerPool[\"getStats\"]>;\n  shutdown: () => Promise<void>;\n} {\n  const workerPoolRef = useRef<WorkerPool | null>(null);\n  const [stats, setStats] = useState({\n    totalWorkers: 0,\n    idleWorkers: 0,\n    busyWorkers: 0,\n    errorWorkers: 0,\n    queuedTasks: 0,\n    totalTasksCompleted: 0,\n    totalErrors: 0\n  });\n\n  if (!workerPoolRef.current) {\n    workerPoolRef.current = createWorkerPool(bus, options);\n  }\n\n  const workerPool = workerPoolRef.current;\n\n  // Update stats when pool state changes\n  useEventListener(bus, \"POOL_WORKER_CREATED\", () => {\n    setStats(workerPool.getStats());\n  });\n\n  useEventListener(bus, \"POOL_WORKER_TERMINATED\", () => {\n    setStats(workerPool.getStats());\n  });\n\n  useEventListener(bus, \"POOL_TASK_QUEUED\", () => {\n    setStats(workerPool.getStats());\n  });\n\n  useEventListener(bus, \"POOL_TASK_ASSIGNED\", () => {\n    setStats(workerPool.getStats());\n  });\n\n  useEventListener(bus, \"POOL_WORKER_ERROR\", () => {\n    setStats(workerPool.getStats());\n  });\n\n  const submitTask = useCallback((taskId: string, payload: unknown, timeout?: number) => {\n    return workerPool.submitTask(taskId, payload, timeout);\n  }, [workerPool]);\n\n  const shutdown = useCallback((): Promise<void> => {\n    workerPool.shutdown();\n    return Promise.resolve();\n  }, [workerPool]);\n\n  useEffect(() => {\n    setStats(workerPool.getStats());\n\n    return () => {\n      workerPool.shutdown();\n    };\n  }, [workerPool]);\n\n  return {\n    workerPool,\n    submitTask,\n    stats,\n    shutdown\n  };\n}\n\n/**\n * Hook for managing QueuedResourceCoordinator\n */\nexport function useQueuedResourceCoordinator(\n  bus: EventBus,\n  options: QueueCoordinatorOptions\n): {\n  coordinator: QueuedResourceCoordinator;\n  submitTask: (task: TaskDescriptor) => Promise<string>;\n  cancelTask: (taskId: string) => boolean;\n  getTaskStatus: (taskId: string) => TaskStatus | null;\n  clearQueue: () => void;\n  leaderStatus: ReturnType<QueuedResourceCoordinator[\"getStatus\"]>;\n  queueStats: ReturnType<QueuedResourceCoordinator[\"getQueueStats\"]>;\n  release: () => Promise<void>;\n} {\n  const coordinatorRef = useRef<QueuedResourceCoordinator | null>(null);\n  const [leaderStatus, setLeaderStatus] = useState<ReturnType<QueuedResourceCoordinator[\"getStatus\"]>>({\n    isLeader: false,\n    followers: []\n  });\n  const [queueStats, setQueueStats] = useState({\n    pendingTasks: 0,\n    activeTasks: 0,\n    completedTasks: 0,\n    totalTasks: 0,\n    isLeader: false,\n    queueCapacity: 0\n  });\n\n  if (!coordinatorRef.current) {\n    coordinatorRef.current = createQueuedResourceCoordinator(bus, options);\n  }\n\n  const coordinator = coordinatorRef.current;\n\n  // Track leadership changes\n  useEffect(() => {\n    const unsubscribe = coordinator.onLeadershipChange((status) => {\n      setLeaderStatus(status);\n      setQueueStats(coordinator.getQueueStats());\n    });\n\n    setLeaderStatus(coordinator.getStatus());\n    setQueueStats(coordinator.getQueueStats());\n\n    return unsubscribe;\n  }, [coordinator]);\n\n  // Update queue stats when tasks change\n  useEventListener(bus, \"QUEUE_TASK_SUBMITTED\", () => {\n    setQueueStats(coordinator.getQueueStats());\n  });\n\n  useEventListener(bus, \"QUEUE_TASK_ASSIGNED\", () => {\n    setQueueStats(coordinator.getQueueStats());\n  });\n\n  useEventListener(bus, \"QUEUE_TASK_COMPLETED\", () => {\n    setQueueStats(coordinator.getQueueStats());\n  });\n\n  useEventListener(bus, \"QUEUE_TASK_FAILED\", () => {\n    setQueueStats(coordinator.getQueueStats());\n  });\n\n  useEventListener(bus, \"QUEUE_TASK_CANCELLED\", () => {\n    setQueueStats(coordinator.getQueueStats());\n  });\n\n  useEventListener(bus, \"QUEUE_CLEARED\", () => {\n    setQueueStats(coordinator.getQueueStats());\n  });\n\n  const submitTask = useCallback((task: TaskDescriptor) => {\n    return Promise.resolve(coordinator.submitTask(task));\n  }, [coordinator]);\n\n  const cancelTask = useCallback((taskId: string) => {\n    return coordinator.cancelTask(taskId);\n  }, [coordinator]);\n\n  const getTaskStatus = useCallback((taskId: string) => {\n    return coordinator.getTaskStatus(taskId);\n  }, [coordinator]);\n\n  const clearQueue = useCallback(() => {\n    coordinator.clearQueue();\n  }, [coordinator]);\n\n  const release = useCallback((): Promise<void> => {\n    coordinator.release();\n    return Promise.resolve();\n  }, [coordinator]);\n\n  useEffect(() => {\n    return () => {\n      coordinator.release();\n    };\n  }, [coordinator]);\n\n  return {\n    coordinator,\n    submitTask,\n    cancelTask,\n    getTaskStatus,\n    clearQueue,\n    leaderStatus,\n    queueStats,\n    release\n  };\n}\n\n/**\n * Hook for task progress tracking\n */\nexport function useTaskProgress(\n  bus: EventBus,\n  taskId: string\n): {\n  status: TaskStatus | null;\n  progress: number;\n  message?: string;\n  result?: TaskResult;\n  error?: Error;\n} {\n  const [state, setState] = useState<{\n    status: TaskStatus | null;\n    progress: number;\n    message?: string;\n    result?: TaskResult;\n    error?: Error;\n  }>({\n    status: null,\n    progress: 0\n  });\n\n  useEventListener(bus, \"TASK_PROGRESS\", (payload?: unknown) => {\n    if (payload && typeof payload === \"object\" && payload !== null &&\n        \"id\" in payload && typeof payload.id === \"string\" && payload.id === taskId &&\n        \"progress\" in payload && typeof payload.progress === \"number\") {\n      // Safe to access properties since we validated above\n      const message = \"message\" in payload && typeof payload.message === \"string\" ? payload.message : undefined;\n      setState(prev => {\n        if (\"progress\" in payload && typeof payload.progress === \"number\") {\n          const update: Partial<typeof prev> = {\n            progress: payload.progress\n          };\n          if (message !== undefined) {\n            update.message = message;\n          }\n          return {\n            ...prev,\n            ...update\n          };\n        }\n        return prev;\n      });\n    }\n  });\n\n  useEventListener(bus, \"TASK_STARTED\", (payload?: unknown) => {\n    if (payload && typeof payload === \"object\" && payload !== null &&\n        \"id\" in payload && typeof payload.id === \"string\" && payload.id === taskId) {\n      setState(prev => ({\n        ...prev,\n        status: TaskStatus.RUNNING,\n        progress: 0\n      }));\n    }\n  });\n\n  useEventListener(bus, \"TASK_COMPLETED\", (payload?: unknown) => {\n    if (payload && typeof payload === \"object\" && payload !== null &&\n        \"id\" in payload && typeof payload.id === \"string\" && payload.id === taskId &&\n        isTaskResult(payload)) {\n      setState(prev => ({\n        ...prev,\n        status: TaskStatus.COMPLETED,\n        progress: 100,\n        result: payload\n      }));\n    }\n  });\n\n  useEventListener(bus, \"TASK_FAILED\", (payload?: unknown) => {\n    if (payload && typeof payload === \"object\" && payload !== null &&\n        \"id\" in payload && typeof payload.id === \"string\" && payload.id === taskId &&\n        isTaskResult(payload)) {\n      setState(prev => ({\n        ...prev,\n        status: TaskStatus.FAILED,\n        error: new Error(payload.error || \"Task failed\")\n      }));\n    }\n  });\n\n  useEventListener(bus, \"TASK_CANCELLED\", (payload?: unknown) => {\n    if (payload && typeof payload === \"object\" && payload !== null &&\n        \"id\" in payload && typeof payload.id === \"string\" && payload.id === taskId) {\n      setState(prev => ({\n        ...prev,\n        status: TaskStatus.CANCELLED,\n        error: new Error(\"Task cancelled\")\n      }));\n    }\n  });\n\n  return state;\n}\n\n/**\n * Hook for cross-tab event broadcasting\n */\nexport function useCrossTabEvent(\n  channelName: string,\n  eventType: string,\n  handler: (payload?: unknown) => void,\n  deps: React.DependencyList = []\n): {\n  broadcast: (payload?: unknown) => void;\n  isConnected: boolean;\n} {\n  const bus = useEventBus(channelName);\n  const [isConnected, setIsConnected] = useState(bus.isBroadcasting());\n\n  useEventListener(bus, eventType, handler, deps);\n\n  const broadcast = useCallback((payload?: unknown) => {\n    bus.emit({ type: eventType, payload });\n  }, [bus, eventType]);\n\n  useEffect(() => {\n    setIsConnected(bus.isBroadcasting());\n  }, [bus]);\n\n  return {\n    broadcast,\n    isConnected\n  };\n}\n\n/**\n * Hook for managing multiple event subscriptions\n */\nexport function useEventSubscriptions(\n  bus: EventBus,\n  subscriptions: Array<{\n    eventType: string;\n    handler: EventHandler;\n  }>\n): void {\n  useEffect(() => {\n    const unsubscribers: Array<() => void> = [];\n\n    for (const { eventType, handler } of subscriptions) {\n      const listenerId = bus.on(eventType, handler);\n      unsubscribers.push(() => { bus.off(eventType, handler); });\n\n      logger.debug(\"hooks\", \"Event subscription registered\", {\n        eventType,\n        listenerId\n      });\n    }\n\n    return () => {\n      for (const unsubscribe of unsubscribers) {\n        unsubscribe();\n      }\n    };\n  }, [bus, subscriptions]);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-unified-execution-worker.ts","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'onExpansionComplete' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":117,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":24},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'executionMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":119,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":18},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'enableWorkerFallback' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":120,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":120,"endColumn":25},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'progressThrottleMs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":122,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":23},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'workerModulePath' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":129,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":25},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'setNodePositions' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":146,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":41},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":196,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":196,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5992,5994],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":197,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":197,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6029,6031],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":212,"column":22,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":212,"endColumn":24,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6541,6543],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, comparison is always true, since `\"FORCE_SIMULATION_CONTROL_ACK\" === \"FORCE_SIMULATION_CONTROL_ACK\"` is true.","line":240,"column":30,"nodeType":"BinaryExpression","messageId":"comparisonBetweenLiteralTypes","endLine":240,"endColumn":91},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":310,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9574,9577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9574,9577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":311,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":311,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":311,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":311,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":312,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":312,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":314,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":314,"endColumn":96},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":314,"column":56,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":314,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":314,"column":82,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":314,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .type on an `any` value.","line":319,"column":82,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":319,"endColumn":86},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'forceProgressUnsub' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":323,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":323,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10264,10267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10264,10267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":327,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":327,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":327,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":327,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":327,"column":86,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":327,"endColumn":93},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":330,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":330,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":332,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":332,"endColumn":96},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":332,"column":56,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":332,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":332,"column":82,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":332,"endColumn":84},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'forceCompleteUnsub' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":339,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":339,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":342,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10856,10859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10856,10859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":343,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":343,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":343,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":343,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":343,"column":82,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":343,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":344,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":344,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .payload on an `any` value.","line":344,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":344,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":345,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":345,"endColumn":110},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":345,"column":66,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":345,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":345,"column":96,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":345,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .error on an `any` value.","line":352,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":352,"endColumn":45},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'errorUnsub' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":355,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":355,"endColumn":21},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":381,"column":11,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":381,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":381,"column":16,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":381,"endColumn":18,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[12192,12194],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":382,"column":11,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":382,"endColumn":38},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":382,"column":16,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":382,"endColumn":18,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[12263,12265],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":387,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":387,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":448,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":448,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[14244,14246],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":449,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":449,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[14298,14300],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":568,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":568,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":591,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":591,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[18693,18695],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":592,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":592,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[18732,18734],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":593,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":593,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[18786,18788],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":603,"column":14,"nodeType":"Identifier","messageId":"neverNullish","endLine":603,"endColumn":26},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":620,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":620,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":641,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":641,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[20163,20165],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":671,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":671,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":701,"column":17,"nodeType":"Identifier","messageId":"neverNullish","endLine":701,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":721,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":721,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22572,22575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22572,22575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":724,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":724,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22698,22701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22698,22701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe array destructuring of a tuple element with an `any` value.","line":731,"column":10,"nodeType":"Identifier","messageId":"unsafeArrayPatternFromTuple","endLine":731,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":744,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":744,"endColumn":50},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":751,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":751,"endColumn":19,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[23373,23373],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[23373,23373],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":752,"column":34,"nodeType":"Identifier","messageId":"voidReturnArgument","endLine":752,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":762,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":762,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":763,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":763,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .initialized on an `any` value.","line":763,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":763,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":764,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":764,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .processing on an `any` value.","line":764,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":764,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .processing on an `any` value.","line":788,"column":83,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":788,"endColumn":93}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":45,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Unified Execution Worker Hook\n * Provides the same API as the background worker but works with or without workers\n * Automatically falls back to main thread execution when workers are not available\n */\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { z } from \"zod\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { createLocalEventBus } from \"@academic-explorer/graph\";\nimport { useUnifiedTaskSystem } from \"@academic-explorer/graph\";\nimport type {\n  ForceSimulationConfig,\n  ForceSimulationNode\n} from \"@academic-explorer/graph\";\nimport type { SimulationLink, NodePosition } from \"@academic-explorer/simulation/types\";\nimport type { GraphNode, GraphEdge } from \"@academic-explorer/graph\";\n\n// Reuse schemas from the original hook\nconst NodePositionSchema = z.object({\n  id: z.string(),\n  x: z.number(),\n  y: z.number(),\n});\n\nconst ForceSimulationProgressSchema = z.object({\n  id: z.string().optional(),\n  type: z.literal(\"worker:force-simulation-progress\").optional(),\n  requestId: z.string().optional(),\n  messageType: z.string().optional(),\n  alpha: z.number().optional(),\n  iteration: z.number().optional(),\n  nodeCount: z.number().optional(),\n  linkCount: z.number().optional(),\n  fps: z.number().optional(),\n  progress: z.number().optional(),\n  positions: z.array(NodePositionSchema).optional(),\n});\n\nconst ForceSimulationCompleteSchema = z.object({\n  type: z.literal(\"worker:force-simulation-complete\"),\n  requestId: z.string().optional(),\n  positions: z.array(NodePositionSchema),\n  totalIterations: z.number(),\n  finalAlpha: z.number(),\n  reason: z.string(),\n});\n\nconst ForceSimulationCompleteEnvelopeSchema = z.object({\n  id: z.string().optional(),\n  result: ForceSimulationCompleteSchema\n});\n\nconst ForceSimulationControlAckSchema = z.object({\n  type: z.literal(\"FORCE_SIMULATION_CONTROL_ACK\"),\n  action: z.string(),\n  status: z.string().optional(),\n  timestamp: z.number().optional()\n}).strict();\n\nconst ForceSimulationControlAckEnvelopeSchema = z.object({\n  id: z.string().optional(),\n  result: ForceSimulationControlAckSchema\n});\n\ninterface AnimationState {\n  isRunning: boolean;\n  isPaused: boolean;\n  alpha: number;\n  iteration: number;\n  progress: number;\n  fps: number;\n  nodeCount: number;\n  linkCount: number;\n}\n\ninterface PerformanceMetrics {\n  averageFPS: number;\n  minFPS: number;\n  maxFPS: number;\n  frameCount: number;\n  totalAnimationTime: number;\n  averageResponseTime: number;\n}\n\ninterface UseUnifiedExecutionWorkerOptions {\n  // Animation callbacks\n  onPositionUpdate?: (positions: NodePosition[]) => void;\n  onAnimationComplete?: (\n    positions: NodePosition[],\n    stats: { totalIterations: number; finalAlpha: number; reason: string }\n  ) => void;\n  onAnimationError?: (error: string) => void;\n\n  // Data fetching callbacks\n  onExpansionProgress?: (nodeId: string, progress: { completed: number; total: number; stage: string }) => void;\n  onExpansionComplete?: (result: {\n    requestId: string;\n    nodes: GraphNode[];\n    edges: GraphEdge[];\n    statistics?: unknown\n  }) => void;\n  onExpansionError?: (nodeId: string, error: string) => void;\n\n  // Execution options\n  executionMode?: \"auto\" | \"worker\" | \"main-thread\";\n  enableWorkerFallback?: boolean;\n  maxConcurrency?: number;\n  progressThrottleMs?: number;\n}\n\nexport function useUnifiedExecutionWorker(options: UseUnifiedExecutionWorkerOptions = {}) {\n  const {\n    onPositionUpdate,\n    onAnimationComplete,\n    onAnimationError,\n    onExpansionComplete,\n    onExpansionError,\n    executionMode = \"auto\",\n    enableWorkerFallback = true,\n    maxConcurrency = 2,\n    progressThrottleMs = 16\n  } = options;\n\n  // Create event bus\n  const [bus] = useState(() => createLocalEventBus());\n\n  // Worker module path\n  const workerModulePath = new URL(\"../workers/background.worker.ts\", import.meta.url).href;\n\n  // Create unified task system\n  const taskSystem = useUnifiedTaskSystem() as TaskSystem;\n\n  // State management\n  const [animationState, setAnimationState] = useState<AnimationState>({\n    isRunning: false,\n    isPaused: false,\n    alpha: 1,\n    iteration: 0,\n    progress: 0,\n    fps: 0,\n    nodeCount: 0,\n    linkCount: 0\n  });\n\n  const [nodePositions, setNodePositions] = useState<NodePosition[]>([]);\n  const nodePositionsRef = useRef<NodePosition[]>([]);\n  const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetrics>({\n    averageFPS: 0,\n    minFPS: Infinity,\n    maxFPS: 0,\n    frameCount: 0,\n    totalAnimationTime: 0,\n    averageResponseTime: 0\n  });\n\n  // Refs for tracking\n  const isAnimatingRef = useRef(false);\n  const progressThrottleRef = useRef<NodeJS.Timeout | null>(null);\n  const animationStartTimeRef = useRef<number>(0);\n  const currentTaskRef = useRef<string | null>(null);\n  const activeTaskIdsRef = useRef<Set<string>>(new Set());\n\n  const addActiveTask = useCallback((taskId: string | null | undefined) => {\n    if (!taskId) return;\n    activeTaskIdsRef.current.add(taskId);\n  }, []);\n\n  const removeActiveTask = useCallback((taskId: string | null | undefined) => {\n    if (!taskId) return;\n    activeTaskIdsRef.current.delete(taskId);\n  }, []);\n\n  // Event handlers (reuse from original hook with minor adjustments)\n  const handleForceSimulationProgress = useCallback((payload: unknown) => {\n    const validationResult = ForceSimulationProgressSchema.safeParse(payload);\n    if (!validationResult.success) {\n      logger.warn(\"execution\", \"Invalid force simulation progress payload\", { payload, error: validationResult.error });\n      return;\n    }\n\n    const { messageType, alpha, iteration, positions, fps, nodeCount, linkCount, progress, id } = validationResult.data;\n\n    if (id) {\n      addActiveTask(id);\n    }\n\n    switch (messageType) {\n      case \"started\":\n        isAnimatingRef.current = true;\n        animationStartTimeRef.current = Date.now();\n        setAnimationState(prev => ({\n          ...prev,\n          isRunning: true,\n          isPaused: false,\n          nodeCount: nodeCount || 0,\n          linkCount: linkCount || 0\n        }));\n        break;\n\n       case \"tick\":\n         if (Array.isArray(positions) && typeof alpha === \"number\" && typeof iteration === \"number\" && typeof progress === \"number\") {\n          // Update position reference and notify via callback\n          nodePositionsRef.current = positions.map(pos => ({ ...pos }));\n          onPositionUpdate?.(positions);\n\n          setAnimationState(prev => ({\n            ...prev,\n            alpha,\n            iteration,\n            progress,\n            fps: fps || prev.fps\n          }));\n\n          if (fps) {\n            setPerformanceMetrics(prev => ({\n              averageFPS: (prev.averageFPS * prev.frameCount + fps) / (prev.frameCount + 1),\n              minFPS: Math.min(prev.minFPS, fps),\n              maxFPS: Math.max(prev.maxFPS, fps),\n              frameCount: prev.frameCount + 1,\n              totalAnimationTime: Date.now() - animationStartTimeRef.current,\n              averageResponseTime: prev.averageResponseTime\n            }));\n          }\n        }\n        break;\n\n      case \"paused\":\n        setAnimationState(prev => ({ ...prev, isPaused: true }));\n        break;\n\n      case \"resumed\":\n        setAnimationState(prev => ({ ...prev, isPaused: false }));\n        break;\n    }\n  }, [addActiveTask, onPositionUpdate]);\n\n  const handleForceSimulationComplete = useCallback((payload: unknown) => {\n    const ackResult = ForceSimulationControlAckEnvelopeSchema.safeParse(payload);\n    if (ackResult.success && ackResult.data.result.type === \"FORCE_SIMULATION_CONTROL_ACK\") {\n      const ackId = ackResult.data.id;\n      if (ackId) {\n        removeActiveTask(ackId);\n        if (currentTaskRef.current === ackId) {\n          currentTaskRef.current = null;\n        }\n      }\n      return;\n    }\n\n    const envelopeResult = ForceSimulationCompleteEnvelopeSchema.safeParse(payload);\n    if (!envelopeResult.success) {\n      logger.warn(\"execution\", \"Invalid force simulation complete payload\", { payload, error: envelopeResult.error });\n      return;\n    }\n\n    const { id, result } = envelopeResult.data;\n\n    if (id) {\n      removeActiveTask(id);\n      if (currentTaskRef.current === id) {\n        currentTaskRef.current = null;\n      }\n    }\n\n    const { positions, totalIterations, finalAlpha, reason } = result;\n\n    isAnimatingRef.current = false;\n    if (!id) {\n      currentTaskRef.current = null;\n    }\n\n    if (progressThrottleRef.current) {\n      clearTimeout(progressThrottleRef.current);\n      progressThrottleRef.current = null;\n    }\n\n    if (Array.isArray(positions)) {\n      nodePositionsRef.current = positions.map(pos => ({ ...pos }));\n      onPositionUpdate?.(positions);\n      onAnimationComplete?.(positions, { totalIterations, finalAlpha, reason });\n    }\n\n    setAnimationState(prev => ({\n      ...prev,\n      isRunning: false,\n      isPaused: false,\n      progress: 1,\n      alpha: finalAlpha\n    }));\n\n    setPerformanceMetrics(prev => ({\n      ...prev,\n      totalAnimationTime: Date.now() - animationStartTimeRef.current\n    }));\n  }, [onPositionUpdate, onAnimationComplete, removeActiveTask]);\n\n  const handleError = useCallback((error: string) => {\n    logger.error(\"execution\", \"Unified execution error\", { error });\n    onAnimationError?.(error);\n    onExpansionError?.(\"unknown\", error);\n  }, [onAnimationError, onExpansionError]);\n\n  // Event listeners\n  useEffect(() => {\n    logger.debug(\"execution\", \"Setting up unified execution event listeners\");\n\n    const unsubscribers: Array<() => void> = [];\n\n    const forceProgressHandler = (event: any) => {\n      if (!event.payload || typeof event.payload !== \"object\") return;\n      const {payload} = event;\n\n      const taskId = \"id\" in payload && typeof payload.id === \"string\" ? payload.id : undefined;\n      if (taskId && !activeTaskIdsRef.current.has(taskId)) {\n        return;\n      }\n\n      if (payload && typeof payload === \"object\" && \"type\" in payload && payload.type === \"worker:force-simulation-progress\") {\n        handleForceSimulationProgress(payload);\n      }\n    };\n    const forceProgressUnsub = bus.on(\"TASK_PROGRESS\", forceProgressHandler);\n    unsubscribers.push(() => { bus.off(\"TASK_PROGRESS\", forceProgressHandler); });\n\n    const forceCompleteHandler = (event: any) => {\n      if (!event.payload || typeof event.payload !== \"object\" || !(\"result\" in event.payload)) {\n        return;\n      }\n      const {payload} = event;\n\n      const taskId = \"id\" in payload && typeof payload.id === \"string\" ? payload.id : undefined;\n      if (taskId && !activeTaskIdsRef.current.has(taskId)) {\n        return;\n      }\n\n      handleForceSimulationComplete(payload);\n    };\n    const forceCompleteUnsub = bus.on(\"TASK_SUCCESS\", forceCompleteHandler);\n    unsubscribers.push(() => { bus.off(\"TASK_SUCCESS\", forceCompleteHandler); });\n\n    const errorHandler = (event: any) => {\n      if (event.payload && typeof event.payload === \"object\" && \"error\" in event.payload) {\n        const taskPayload = event.payload;\n        const taskId = \"id\" in taskPayload && typeof taskPayload.id === \"string\" ? taskPayload.id : undefined;\n        if (taskId && !activeTaskIdsRef.current.has(taskId)) {\n          return;\n        }\n        if (taskId) {\n          removeActiveTask(taskId);\n        }\n        handleError(String(taskPayload.error));\n      }\n    };\n    const errorUnsub = bus.on(\"TASK_FAILED\", errorHandler);\n    unsubscribers.push(() => { bus.off(\"TASK_FAILED\", errorHandler); });\n\n    return () => {\n      unsubscribers.forEach(unsub => { unsub(); });\n\n      if (progressThrottleRef.current) {\n        clearTimeout(progressThrottleRef.current);\n        progressThrottleRef.current = null;\n      }\n    };\n  }, [bus, handleForceSimulationProgress, handleForceSimulationComplete, handleError, removeActiveTask]);\n\n  // Animation control methods (same API as original hook)\n  const startAnimation = useCallback(async ({\n    nodes,\n    links,\n    config,\n    pinnedNodes\n  }: {\n    nodes: ForceSimulationNode[];\n    links: SimulationLink[];\n    config?: ForceSimulationConfig;\n    pinnedNodes?: Set<string>;\n  }) => {\n    logger.debug(\"execution\", \"Starting animation with unified execution\", {\n      ...(nodes?.length !== undefined && { nodeCount: nodes.length }),\n      ...(links?.length !== undefined && { linkCount: links.length }),\n      ...(pinnedNodes?.size !== undefined && { pinnedCount: pinnedNodes.size }),\n      executionMode: taskSystem.getExecutionMode()\n    });\n\n    if (!nodes || nodes.length === 0) {\n      logger.warn(\"execution\", \"Cannot start animation with no nodes\");\n      return;\n    }\n\n    // Cancel existing animation\n    const previousTaskId = currentTaskRef.current;\n    if (previousTaskId) {\n      await taskSystem.cancelTask(previousTaskId);\n      removeActiveTask(previousTaskId);\n      isAnimatingRef.current = false;\n      currentTaskRef.current = null;\n    }\n\n    // Merge with existing positions\n    const positionMap = new Map(nodePositionsRef.current.map(pos => [pos.id, pos]));\n    const seededNodes = nodes.map((node) => {\n      const existingPosition = positionMap.get(node.id);\n      if (!existingPosition) {\n        return node;\n      }\n\n      return {\n        ...node,\n        x: existingPosition.x,\n        y: existingPosition.y,\n        fx: typeof node.fx === \"number\" ? existingPosition.x : undefined,\n        fy: typeof node.fy === \"number\" ? existingPosition.y : undefined\n      };\n    });\n\n    // Reset performance metrics\n    setPerformanceMetrics({\n      averageFPS: 0,\n      minFPS: Infinity,\n      maxFPS: 0,\n      frameCount: 0,\n      totalAnimationTime: 0,\n      averageResponseTime: 0\n    });\n\n    const taskId = `force-simulation-${Date.now().toString()}`;\n    try {\n      addActiveTask(taskId);\n\n      const submittedTaskId = await taskSystem.submitTask({\n        id: taskId,\n        payload: {\n          type: \"FORCE_SIMULATION_START\",\n          nodes: seededNodes,\n          links,\n          config,\n          pinnedNodes: pinnedNodes ? Array.from(pinnedNodes) : []\n        },\n        timeout: 300000\n      });\n\n      currentTaskRef.current = submittedTaskId;\n\n      logger.debug(\"execution\", \"Animation started with unified execution\", {\n        nodeCount: seededNodes.length,\n        linkCount: links?.length || 0,\n        pinnedCount: pinnedNodes?.size || 0,\n        taskId: submittedTaskId,\n        executionMode: taskSystem.getExecutionMode()\n      });\n\n      return submittedTaskId;\n    } catch (error) {\n      removeActiveTask(taskId);\n      const errorMessage = `Failed to start animation: ${error instanceof Error ? error.message : String(error)}`;\n      logger.error(\"execution\", errorMessage, { error });\n      onAnimationError?.(errorMessage);\n      return null;\n    }\n  }, [taskSystem, addActiveTask, removeActiveTask, onAnimationError]);\n\n  // Other animation controls (similar pattern to startAnimation)\n  const stopAnimation = useCallback(async () => {\n    if (!currentTaskRef.current) {\n      logger.debug(\"execution\", \"No animation task to stop\");\n      return;\n    }\n\n    const stopTaskId = `force-simulation-stop-${Date.now().toString()}`;\n    addActiveTask(stopTaskId);\n    try {\n      await taskSystem.submitTask({\n        id: stopTaskId,\n        payload: {\n          type: \"FORCE_SIMULATION_STOP\"\n        }\n      });\n\n      removeActiveTask(stopTaskId);\n      const previousTaskId = currentTaskRef.current;\n      if (previousTaskId) {\n        removeActiveTask(previousTaskId);\n      }\n      isAnimatingRef.current = false;\n      currentTaskRef.current = null;\n\n      setAnimationState(prev => ({\n        ...prev,\n        isRunning: false,\n        isPaused: false\n      }));\n    } catch (error) {\n      removeActiveTask(stopTaskId);\n      logger.error(\"execution\", \"Failed to stop animation\", { error });\n    }\n  }, [taskSystem, addActiveTask, removeActiveTask]);\n\n  const pauseAnimation = useCallback(async () => {\n    if (animationState.isRunning && !animationState.isPaused) {\n      const taskId = `force-simulation-pause-${Date.now().toString()}`;\n      addActiveTask(taskId);\n      try {\n        await taskSystem.submitTask({\n          id: taskId,\n          payload: {\n            type: \"FORCE_SIMULATION_PAUSE\"\n          }\n        });\n      } catch (error) {\n        removeActiveTask(taskId);\n        logger.error(\"execution\", \"Failed to pause animation\", { error });\n      }\n    }\n  }, [animationState.isRunning, animationState.isPaused, taskSystem, addActiveTask, removeActiveTask]);\n\n  const resumeAnimation = useCallback(async () => {\n    if (animationState.isRunning && animationState.isPaused) {\n      const taskId = `force-simulation-resume-${Date.now().toString()}`;\n      addActiveTask(taskId);\n      try {\n        await taskSystem.submitTask({\n          id: taskId,\n          payload: {\n            type: \"FORCE_SIMULATION_RESUME\"\n          }\n        });\n      } catch (error) {\n        removeActiveTask(taskId);\n        logger.error(\"execution\", \"Failed to resume animation\", { error });\n      }\n    }\n  }, [animationState.isRunning, animationState.isPaused, taskSystem, addActiveTask, removeActiveTask]);\n\n  const updateParameters = useCallback(async (config: Partial<ForceSimulationConfig>) => {\n    if (animationState.isRunning) {\n      const taskId = `force-simulation-update-${Date.now().toString()}`;\n      addActiveTask(taskId);\n      try {\n        await taskSystem.submitTask({\n          id: taskId,\n          payload: {\n            type: \"FORCE_SIMULATION_UPDATE_PARAMETERS\",\n            config\n          }\n        });\n      } catch (error) {\n        removeActiveTask(taskId);\n        logger.error(\"execution\", \"Failed to update parameters\", { error });\n      }\n    }\n  }, [animationState.isRunning, taskSystem, addActiveTask, removeActiveTask]);\n\n  const reheatAnimation = useCallback(async ({\n    nodes,\n    links,\n    config,\n    pinnedNodes,\n    alpha = 0.5\n  }: {\n    nodes: ForceSimulationNode[];\n    links: SimulationLink[];\n    config?: ForceSimulationConfig;\n    pinnedNodes?: Set<string>;\n    alpha?: number;\n  }) => {\n    if (!nodes || nodes.length === 0) {\n      logger.warn(\"execution\", \"Cannot reheat animation with no nodes\");\n      return;\n    }\n\n    const taskId = `force-simulation-reheat-${Date.now().toString()}`;\n    try {\n      addActiveTask(taskId);\n\n      const resultTaskId = await taskSystem.submitTask({\n        id: taskId,\n        payload: {\n          type: \"FORCE_SIMULATION_REHEAT\",\n          nodes,\n          links,\n          config,\n          pinnedNodes: pinnedNodes ? Array.from(pinnedNodes) : [],\n          alpha\n        },\n        timeout: 300000\n      });\n\n      logger.debug(\"execution\", \"Animation reheat started with unified execution\", {\n        nodeCount: nodes?.length || 0,\n        linkCount: links?.length || 0,\n        pinnedCount: pinnedNodes?.size || 0,\n        alpha,\n        taskId: resultTaskId,\n        executionMode: taskSystem.getExecutionMode()\n      });\n\n      if (resultTaskId && resultTaskId !== taskId) {\n        addActiveTask(resultTaskId);\n      }\n\n      return resultTaskId ?? taskId;\n    } catch (error) {\n      removeActiveTask(taskId);\n      const errorMessage = `Failed to reheat animation: ${error instanceof Error ? error.message : String(error)}`;\n      logger.error(\"execution\", errorMessage, { error });\n      onAnimationError?.(errorMessage);\n      return null;\n    }\n  }, [taskSystem, addActiveTask, removeActiveTask, onAnimationError]);\n\n  const updateSimulationLinks = useCallback(async ({\n    links,\n    alpha = 1.0\n  }: {\n    links: SimulationLink[];\n    alpha?: number;\n  }) => {\n    if (!links || links.length === 0) {\n      logger.warn(\"execution\", \"Cannot update simulation with no links\");\n      return;\n    }\n\n    const taskId = `force-simulation-update-links-${Date.now().toString()}`;\n    try {\n      addActiveTask(taskId);\n\n      const resultTaskId = await taskSystem.submitTask({\n        id: taskId,\n        payload: {\n          type: \"FORCE_SIMULATION_UPDATE_LINKS\",\n          links,\n          alpha\n        },\n        priority: 100,\n        timeout: 300000\n      });\n\n      logger.debug(\"execution\", \"Simulation links update started with unified execution\", {\n        linkCount: links?.length || 0,\n        alpha,\n        priority: 100,\n        taskId: resultTaskId,\n        executionMode: taskSystem.getExecutionMode()\n      });\n\n      if (resultTaskId && resultTaskId !== taskId) {\n        addActiveTask(resultTaskId);\n      }\n\n      return resultTaskId;\n    } catch (error: unknown) {\n      removeActiveTask(taskId);\n      const errorMessage = `Failed to update simulation links: ${error instanceof Error ? error.message : String(error)}`;\n      logger.error(\"execution\", errorMessage, { error });\n      onAnimationError?.(errorMessage);\n      return null;\n    }\n  }, [taskSystem, addActiveTask, removeActiveTask, onAnimationError]);\n\n  const updateSimulationNodes = useCallback(async ({\n    nodes,\n    pinnedNodes,\n    alpha = 1.0\n  }: {\n    nodes: ForceSimulationNode[];\n    pinnedNodes?: Set<string> | string[];\n    alpha?: number;\n  }) => {\n    if (!nodes || nodes.length === 0) {\n      logger.warn(\"execution\", \"Cannot update simulation with no nodes\");\n      return;\n    }\n\n    const taskId = `force-simulation-update-nodes-${Date.now().toString()}`;\n    try {\n      addActiveTask(taskId);\n\n      const pinnedArray = Array.isArray(pinnedNodes)\n        ? pinnedNodes\n        : Array.from(pinnedNodes ?? []);\n\n      const resultTaskId = await taskSystem.submitTask({\n        id: taskId,\n        payload: {\n          type: \"FORCE_SIMULATION_UPDATE_NODES\",\n          nodes,\n          pinnedNodes: pinnedArray,\n          alpha\n        },\n        priority: 100,\n        timeout: 300000\n      });\n\n      logger.debug(\"execution\", \"Simulation nodes update started with unified execution\", {\n        nodeCount: nodes.length,\n        pinnedCount: pinnedArray.length,\n        alpha,\n        priority: 100,\n        taskId: resultTaskId ?? taskId,\n        executionMode: taskSystem.getExecutionMode()\n      });\n\n      if (resultTaskId && resultTaskId !== taskId) {\n        addActiveTask(resultTaskId);\n      }\n\n      return resultTaskId;\n    } catch (error) {\n      removeActiveTask(taskId);\n      const errorMessage = `Failed to update simulation nodes: ${error instanceof Error ? error.message : String(error)}`;\n      logger.error(\"execution\", errorMessage, { error });\n      onAnimationError?.(errorMessage);\n      return null;\n    }\n  }, [taskSystem, addActiveTask, removeActiveTask, onAnimationError]);\n\n  // TaskSystem interface based on usage\n  interface TaskSystem {\n    submitTask(task: any): Promise<string>;\n    cancelTask(taskId: string): Promise<void>;\n    getExecutionMode(): string;\n    getStats(): Promise<any>;\n    isUsingWorkers(): boolean;\n    isInitialized(): boolean;\n    shutdown(): Promise<void>;\n  }\n\n  // Get execution statistics\n  const [systemStats, setSystemStats] = useState<Awaited<ReturnType<TaskSystem[\"getStats\"]>>>({\n    queueLength: 0,\n    activeTasks: 0,\n    processing: false,\n    maxConcurrency,\n    strategyMode: \"main-thread\",\n    supportsWorkers: false,\n    initialized: false\n  });\n\n  useEffect(() => {\n    const updateStats = async () => {\n      try {\n        const stats = await taskSystem.getStats();\n        setSystemStats(stats);\n      } catch (error) {\n        logger.debug(\"execution\", \"Failed to get system stats\", { error });\n      }\n    };\n\n    updateStats();\n    const interval = setInterval(updateStats, 1000); // Update every second\n\n    return () => { clearInterval(interval); };\n  }, [taskSystem]);\n\n  return {\n    // State\n    animationState,\n    nodePositions,\n    performanceMetrics,\n    systemStats,\n    isWorkerReady: systemStats.initialized,\n    isLoading: systemStats.processing,\n    error: null,\n\n    // Animation controls\n    startAnimation,\n    stopAnimation,\n    pauseAnimation,\n    resumeAnimation,\n    updateParameters,\n    reheatAnimation,\n    updateSimulationLinks,\n    updateSimulationNodes,\n\n    // System info\n    isUsingWorkers: () => taskSystem.isUsingWorkers(),\n    getExecutionMode: () => taskSystem.getExecutionMode(),\n    isInitialized: () => taskSystem.isInitialized(),\n\n    // Worker management\n    terminate: () => {\n      void taskSystem.shutdown();\n    },\n\n    // Computed properties\n    isIdle: !animationState.isRunning && !animationState.isPaused && !systemStats.processing,\n    canPause: animationState.isRunning && !animationState.isPaused,\n    canResume: animationState.isRunning && animationState.isPaused,\n    canStop: animationState.isRunning || animationState.isPaused,\n\n    // Performance insights\n    performanceInsights: {\n      ...performanceMetrics,\n      isOptimal: performanceMetrics.averageFPS >= 30,\n      hasFrameDrops: performanceMetrics.minFPS < 15,\n      efficiency: performanceMetrics.frameCount > 0 ?\n        (performanceMetrics.averageFPS / 60) * 100 : 0\n    }\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/hooks/use-web-worker.ts","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'TaskSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":73,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5143,5146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5143,5146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .nodeId on an `any` value.","line":156,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":156,"endColumn":68},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":171,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":171,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5721,5723],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":175,"column":59,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":175,"endColumn":61,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5964,5966],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":252,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":252,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8477,8479],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Web Worker Hook\n * Based on the ChatGPT document recommendations for modern worker management\n * Provides type-safe worker communication with progress tracking and error handling\n */\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type { SimulationLink, NodePosition } from \"@academic-explorer/simulation/types\";\nimport type { GraphNode, GraphEdge } from \"@academic-explorer/graph\";\n\nexport interface WebWorkerTaskSystem {\n  submitTask: (task: WorkerRequest) => Promise<void>;\n  getStats: () => WorkerStats;\n  isWorkerReady: boolean;\n  postMessage: (data: WorkerRequest) => string | null;\n  terminate: () => void;\n  isLoading: boolean;\n  error: string | null;\n  stats: WorkerStats;\n  isWorkerAvailable: () => boolean;\n  getWorker: () => Worker | null;\n  // Computed properties\n  isIdle: boolean;\n  hasError: boolean;\n  // Performance metrics\n  averageResponseTime: number;\n  totalMessages: number;\n  errorRate: number;\n}\n\nexport interface WorkerRequest {\n  type: string;\n  data?: unknown;\n  options?: Record<string, unknown>;\n  requestId?: string;\n}\n\nexport interface WorkerResponse {\n  type: \"PROGRESS\" | \"SUCCESS\" | \"ERROR\";\n  requestId?: string;\n  result?: unknown;\n  progress?: number;\n  error?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface UseWebWorkerOptions {\n  onMessage?: (data: WorkerResponse) => void;\n  onError?: (error: ErrorEvent) => void;\n  onProgress?: (progress: number, requestId?: string) => void;\n  onSuccess?: (result: unknown, requestId?: string) => void;\n  onExpansionProgress?: (nodeId: string, progress: number) => void;\n  onExpansionComplete?: (result: {requestId: string; nodes: GraphNode[]; edges: GraphEdge[]}) => void;\n  onExpansionError?: (nodeId: string, error: string) => void;\n  autoTerminate?: boolean; // Auto-terminate on unmount (default: true)\n}\n\nexport interface WorkerStats {\n  messagesReceived: number;\n  messagesSent: number;\n  errors: number;\n  averageResponseTime: number;\n  lastActivity: number;\n}\n\ninterface UnifiedTask<T = unknown> {\n  type: string;\n  data?: T;\n  requestId?: string;\n}\n\ninterface TaskSystem<T = unknown> {\n  submitTask: (task: UnifiedTask<T>) => Promise<void>;\n  getStats: () => WorkerStats;\n  isWorkerReady: boolean;\n  onExpansionProgress?: (nodeId: string, progress: number) => void;\n  onExpansionComplete?: (result: {requestId: string; nodes: GraphNode[]; edges: GraphEdge[]; links?: SimulationLink[]; positions?: NodePosition[] }) => void;\n  onExpansionError?: (nodeId: string, error: string) => void;\n}\n\nexport function useWebWorker(\n  workerFactory: () => Worker,\n  options: UseWebWorkerOptions = {}\n): WebWorkerTaskSystem {\n  const {\n    onMessage,\n    onError,\n    onProgress,\n    onSuccess,\n    onExpansionProgress,\n    onExpansionComplete,\n    onExpansionError,\n    autoTerminate = true\n  } = options;\n\n  const workerRef = useRef<Worker | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [stats, setStats] = useState<WorkerStats>({\n    messagesReceived: 0,\n    messagesSent: 0,\n    errors: 0,\n    averageResponseTime: 0,\n    lastActivity: 0\n  });\n  const [isWorkerReady, setIsWorkerReady] = useState(false);\n\n  // Track pending requests for response time calculation\n  const pendingRequests = useRef(new Map<string, number>());\n  const responseTimes = useRef<number[]>([]);\n\n  // Initialize worker\n  useEffect(() => {\n    let worker: Worker | null = null;\n\n    try {\n      worker = workerFactory();\n      workerRef.current = worker;\n      setIsWorkerReady(true);\n\n      // Setup message handler\n      const messageHandler = (event: MessageEvent<WorkerResponse>) => {\n        const {data} = event;\n\n        setStats(prev => ({\n          ...prev,\n          messagesReceived: prev.messagesReceived + 1,\n          lastActivity: Date.now()\n        }));\n\n        // Calculate response time if requestId is present\n        if (data.requestId && pendingRequests.current.has(data.requestId)) {\n          const startTime = pendingRequests.current.get(data.requestId);\n          if (startTime !== undefined) {\n            const responseTime = Date.now() - startTime;\n            responseTimes.current.push(responseTime);\n            pendingRequests.current.delete(data.requestId);\n          }\n\n          // Keep only last 100 response times for average calculation\n          if (responseTimes.current.length > 100) {\n            responseTimes.current = responseTimes.current.slice(-100);\n          }\n\n          const averageResponseTime = responseTimes.current.reduce((sum, time) => sum + time, 0) / responseTimes.current.length;\n          setStats(prev => ({ ...prev, averageResponseTime }));\n        }\n\n        // Handle different response types\n        switch (data.type) {\n          case \"PROGRESS\":\n            if (typeof data.progress === \"number\") {\n              onProgress?.(data.progress, data.requestId);\n              if (data.requestId && typeof data.metadata === \"object\" && 'nodeId' in data.metadata) {\n                onExpansionProgress?.((data.metadata as any).nodeId as string, data.progress);\n              }\n            }\n            break;\n\n          case \"SUCCESS\":\n            setError(null);\n            setIsLoading(false);\n            onSuccess?.(data.result, data.requestId);\n            if (data.requestId && onExpansionComplete && typeof data.result === \"object\") {\n              onExpansionComplete(data.result as {requestId: string; nodes: GraphNode[]; edges: GraphEdge[]; links?: SimulationLink[]; positions?: NodePosition[] });\n            }\n            break;\n\n          case \"ERROR\":\n            setError(data.error || \"Unknown worker error\");\n            setIsLoading(false);\n            setStats(prev => ({ ...prev, errors: prev.errors + 1 }));\n            if (data.requestId && onExpansionError) {\n              onExpansionError(data.requestId, data.error || \"Unknown error\");\n            }\n            break;\n        }\n\n        // Call general message handler\n        onMessage?.(data);\n      };\n\n      worker.onmessage = messageHandler;\n\n      // Setup error handler\n      const errorHandler = (errorEvent: ErrorEvent) => {\n        const errorMessage = `Worker error: ${errorEvent.message}`;\n        setError(errorMessage);\n        setIsLoading(false);\n        setStats(prev => ({ ...prev, errors: prev.errors + 1 }));\n        onError?.(errorEvent);\n\n        logger.error(\"worker\", \"Worker error occurred\", {\n          message: errorEvent.message,\n          filename: errorEvent.filename,\n          lineno: errorEvent.lineno,\n          colno: errorEvent.colno\n        });\n      };\n\n      worker.onerror = errorHandler;\n\n      // Setup unhandled error handler\n      const messageErrorHandler = (event: MessageEvent) => {\n        const errorMessage = \"Worker message error (serialization/deserialization failed)\";\n        setError(errorMessage);\n        setIsLoading(false);\n        setStats(prev => ({ ...prev, errors: prev.errors + 1 }));\n\n        logger.error(\"worker\", \"Worker message error\", { event });\n      };\n\n      worker.onmessageerror = messageErrorHandler;\n\n      logger.debug(\"worker\", \"Worker initialized successfully\");\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : \"Failed to create worker\";\n      setError(errorMessage);\n      logger.error(\"worker\", \"Failed to initialize worker\", { error: errorMessage });\n      setIsWorkerReady(false);\n    }\n\n    // Cleanup on unmount\n    return () => {\n      if (worker) {\n        worker.onmessage = null;\n        worker.onerror = null;\n        worker.onmessageerror = null;\n        if (autoTerminate) {\n          worker.terminate();\n          workerRef.current = null;\n          logger.debug(\"worker\", \"Worker terminated on cleanup\");\n        }\n        setIsWorkerReady(false);\n      }\n    };\n  }, [workerFactory, onMessage, onError, onProgress, onSuccess, onExpansionProgress, onExpansionComplete, onExpansionError, autoTerminate]);\n\n  // Post message to worker with automatic request ID generation\n  const postMessage = useCallback((data: WorkerRequest) => {\n    if (!workerRef.current) {\n      const error = \"Worker not available\";\n      setError(error);\n      logger.warn(\"worker\", \"Attempted to post message to unavailable worker\", { data });\n      return null;\n    }\n\n    try {\n      // Generate request ID if not provided\n      const requestId = data.requestId || `req-${Date.now().toString()}-${Math.random().toString(36).substring(2)}`;\n      const messageWithId: WorkerRequest = { ...data, requestId };\n\n      // Track request timing\n      pendingRequests.current.set(requestId, Date.now());\n\n      setIsLoading(true);\n      setError(null);\n      workerRef.current.postMessage(messageWithId);\n\n      setStats(prev => ({\n        ...prev,\n        messagesSent: prev.messagesSent + 1,\n        lastActivity: Date.now()\n      }));\n\n      logger.debug(\"worker\", \"Message posted to worker\", {\n        type: data.type,\n        requestId,\n        hasData: !!data.data\n      });\n\n      return requestId;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : \"Failed to post message\";\n      setError(errorMessage);\n      setIsLoading(false);\n      logger.error(\"worker\", \"Failed to post message to worker\", { error: errorMessage, data });\n      return null;\n    }\n  }, []);\n\n  // Submit task to worker\n  const submitTask = useCallback(async (task: WorkerRequest): Promise<void> => {\n    const requestId = postMessage(task);\n    if (!requestId) {\n      throw new Error(\"Failed to submit task: worker not available\");\n    }\n    // Wait for completion or error (simplified - in real impl, use promise from queue)\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => { reject(new Error(\"Task timeout\")); }, 30000);\n      const checkStatus = () => {\n        if (stats.averageResponseTime > 0) {\n          clearTimeout(timeout);\n          resolve();\n        } else {\n          setTimeout(checkStatus, 100);\n        }\n      };\n      checkStatus();\n    });\n  }, [postMessage, stats.averageResponseTime]);\n\n  // Get stats\n  const getStats = useCallback(() => stats, [stats]);\n\n  // Terminate worker manually\n  const terminate = useCallback(() => {\n    if (workerRef.current) {\n      workerRef.current.onmessage = null;\n      workerRef.current.onerror = null;\n      workerRef.current.onmessageerror = null;\n      workerRef.current.terminate();\n      workerRef.current = null;\n      setIsLoading(false);\n      setError(null);\n      setIsWorkerReady(false);\n\n      // Clear pending requests\n      pendingRequests.current.clear();\n\n      logger.debug(\"worker\", \"Worker terminated manually\");\n    }\n  }, []);\n\n  // Check if worker is available\n  const isWorkerAvailable = useCallback(() => {\n    return workerRef.current !== null;\n  }, []);\n\n  // Get worker instance (for advanced usage)\n  const getWorker = useCallback(() => {\n    return workerRef.current;\n  }, []);\n\n  return {\n    // TaskSystem methods\n    submitTask,\n    getStats,\n    isWorkerReady,\n\n    // Legacy\n    postMessage,\n    terminate,\n\n    // State\n    isLoading,\n    error,\n    stats,\n\n    // Utilities\n    isWorkerAvailable,\n    getWorker,\n\n    // Computed properties\n    isIdle: !isLoading && !error,\n    hasError: !!error,\n\n    // Performance metrics\n    averageResponseTime: stats.averageResponseTime,\n    totalMessages: stats.messagesReceived + stats.messagesSent,\n    errorRate: stats.messagesSent > 0 ? stats.errors / stats.messagesSent : 0\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/$externalId.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/__root.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/about.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/authors/$authorId.tsx","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":71,"column":101,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":71,"endColumn":103,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2714,2716],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":74,"column":137,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":74,"endColumn":139,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2958,2960],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":124,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":124,"endColumn":16,"suggestions":[{"fix":{"range":[5479,5564],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":127,"column":6,"nodeType":"MemberExpression","messageId":"unexpected","endLine":127,"endColumn":17,"suggestions":[{"fix":{"range":[5634,5690],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":129,"column":6,"nodeType":"MemberExpression","messageId":"unexpected","endLine":129,"endColumn":17,"suggestions":[{"fix":{"range":[5727,5783],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createFileRoute, useNavigate } from \"@tanstack/react-router\";\nimport { useEffect, useRef, useCallback } from \"react\";\nimport { useGraphData } from \"@/hooks/use-graph-data\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useRawEntityData } from \"@/hooks/use-raw-entity-data\";\nimport { useEntityDocumentTitle } from \"@/hooks/use-document-title\";\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\nimport { EntityDetector } from \"@academic-explorer/graph\";\n\nexport const Route = createFileRoute(\"/authors/$authorId\")({\n\tcomponent: AuthorRoute,\n});\n\nfunction AuthorRoute() {\n \tconst { authorId } = Route.useParams();\n \tconst navigate = useNavigate();\n\n \t// Debug logging for route params\n \tlogger.debug(\"routing\", \"AuthorRoute component mounted\", { authorId, type: typeof authorId }, \"AuthorRoute\");\n\tconst graphData = useGraphData();\n\n\tconst {loadEntity} = graphData;\n\tconst {loadEntityIntoGraph} = graphData;\n\tconst {expandNode} = graphData;\n\n\t// Track which authors have been loaded to prevent infinite loops\n\tconst loadedAuthorsRef = useRef<Set<string>>(new Set());\n\n  // Check if ID needs normalization and redirect if necessary\n  useEffect(() => {\n    if (!authorId || typeof authorId !== 'string' || authorId.trim() === '') {\n      logger.debug(\"routing\", \"authorId is invalid, skipping normalization check\", { authorId, type: typeof authorId }, \"AuthorRoute\");\n      return;\n    }\n\n    logger.debug(\"routing\", \"Processing authorId for normalization\", { authorId }, \"AuthorRoute\");\n\n    const detector = new EntityDetector();\n    const detection = detector.detectEntityIdentifier(authorId);\n\n\t\t// If ID was normalized and is different from input, redirect\n\t\tif (detection.normalizedId && detection.normalizedId !== authorId) {\n\t\t\tlogger.debug(\"routing\", \"Redirecting to normalized author ID\", {\n\t\t\t\toriginalId: authorId,\n\t\t\t\tnormalizedId: detection.normalizedId\n\t\t\t}, \"AuthorRoute\");\n\n\t\t\t// Replace current URL with normalized version, preserving query params\n\t\t\tvoid navigate({\n\t\t\t\tto: \"/authors/$authorId\",\n\t\t\t\tparams: { authorId: detection.normalizedId },\n\t\t\t\tsearch: (prev) => prev, // Preserve existing search params\n\t\t\t\treplace: true\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}, [authorId, navigate]);\n\n\t// Fetch entity data for title\n\tconst rawEntityDataResult = useRawEntityData({\n\t\tentityId: authorId,\n\t\tenabled: !!authorId\n\t});\n\tconst author = rawEntityDataResult.data;\n\n\t// Update document title with author name\n\tuseEntityDocumentTitle(author);\n\n  // Create stable callback for loading author data - removed nodeCount dependency\n  const loadAuthor = useCallback(async () => {\n    logger.debug(\"routing\", \"loadAuthor called\", { authorId, type: typeof authorId, length: authorId?.length }, \"AuthorRoute\");\n\n    if (!authorId || typeof authorId !== 'string' || authorId.trim() === '') {\n      logger.debug(\"routing\", \"loadAuthor called but authorId is invalid, skipping\", { authorId, type: typeof authorId, length: authorId?.length }, \"AuthorRoute\");\n      return;\n    }\n\n\t\ttry {\n\t\t\t// Get current node count at time of execution rather than as dependency\n\t\t\tconst currentNodeCount = useGraphStore.getState().totalNodeCount;\n\t\t\tlogger.debug(\"routing\", \"loadAuthor called\", {\n\t\t\t\tauthorId,\n\t\t\t\tcurrentNodeCount,\n\t\t\t\tloadedAuthors: Array.from(loadedAuthorsRef.current)\n\t\t\t}, \"AuthorRoute\");\n\n\t\t\t// Check if this author has already been loaded to prevent infinite loops\n\t\t\t// BUT also check if graph actually has nodes - if not, we need to reload\n\t\t\tif (loadedAuthorsRef.current.has(authorId) && currentNodeCount > 0) {\n\t\t\t\tlogger.debug(\"routing\", \"Author already loaded, skipping\", { authorId, currentNodeCount }, \"AuthorRoute\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TEMP DEBUG: If author was marked as loaded but graph is empty, clear the tracking\n\t\t\tif (loadedAuthorsRef.current.has(authorId) && currentNodeCount === 0) {\n\t\t\t\tlogger.debug(\"routing\", \"Author marked as loaded but graph is empty - clearing tracking and reloading\", { authorId, currentNodeCount }, \"AuthorRoute\");\n\t\t\t\tloadedAuthorsRef.current.clear();\n\t\t\t}\n\n\t\t\t// Mark this author as being loaded\n\t\t\tloadedAuthorsRef.current.add(authorId);\n\n \t\t\t// If graph already has nodes, use incremental loading to preserve existing entities\n \t\t\t// This prevents clearing the graph when clicking on nodes or navigating\n \t\t\tif (currentNodeCount > 0) {\n \t\t\t\tlogger.debug(\"routing\", \"Loading author into existing graph\", { authorId, currentNodeCount, type: typeof authorId }, \"AuthorRoute\");\n \t\t\t\tif (!authorId || typeof authorId !== 'string' || authorId.trim() === '') {\n \t\t\t\t\tlogger.error(\"routing\", \"authorId is invalid before loadEntityIntoGraph call, this should not happen\", { authorId, type: typeof authorId }, \"AuthorRoute\");\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\tawait loadEntityIntoGraph(authorId);\n \t\t\t} else {\n \t\t\t\t// If graph is empty, use full loading (clears graph for initial load)\n \t\t\t\tlogger.debug(\"routing\", \"Loading author into empty graph\", { authorId, type: typeof authorId }, \"AuthorRoute\");\n \t\t\t\tif (!authorId || typeof authorId !== 'string' || authorId.trim() === '') {\n \t\t\t\t\tlogger.error(\"routing\", \"authorId is invalid before loadEntity call, this should not happen\", { authorId, type: typeof authorId }, \"AuthorRoute\");\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\tawait loadEntity(authorId);\n\n\t\t\t\t// For initial author page load, automatically expand to show works\n\t\t\t\t// This ensures users see a full graph when directly visiting an author URL\n\t\t\t\tconst authorNodeId = `https://openalex.org/${authorId}`;\n\t\t\t\tconsole.log(\"DEBUG: Author route calling expandNode\", { authorNodeId, force: true });\n\t\t\t\ttry {\n\t\t\t\t\tawait expandNode(authorNodeId, { force: true });\n\t\t\t\t\tconsole.log(\"DEBUG: expandNode completed successfully\");\n\t\t\t\t} catch (expansionError) {\n\t\t\t\t\tconsole.log(\"DEBUG: expandNode failed\", expansionError);\n\t\t\t\t\t// Log expansion failures but don't prevent the author from loading\n\t\t\t\t\tlogger.warn(\"routing\", \"Failed to expand author on initial load\", {\n\t\t\t\t\t\tauthorId,\n\t\t\t\t\t\terror: expansionError instanceof Error ? expansionError.message : String(expansionError)\n\t\t\t\t\t}, \"AuthorRoute\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to load author\", error, \"AuthorRoute\", \"routing\");\n\t\t}\n\t}, [authorId, loadEntity, loadEntityIntoGraph, expandNode]);\n\n\tuseEffect(() => {\n\t\tvoid loadAuthor();\n\t}, [loadAuthor]);\n\n\t// Return null - the graph is visible from MainLayout\n\t// The route content is just for triggering the data load\n\treturn null;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/authors/orcid.$orcid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/error-test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/evaluation.tsx","messages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":36,"column":37,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[985,1306],"text":"\n          Evaluate Academic Explorer&apos;s literature discovery capabilities against published systematic literature reviews\n          using the STAR (Systematic Literature Review) methodology. This provides quantitative metrics for precision,\n          recall, and F1-score analysis required for PhD thesis evaluation.\n\t\t\t\t"},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[985,1306],"text":"\n          Evaluate Academic Explorer&lsquo;s literature discovery capabilities against published systematic literature reviews\n          using the STAR (Systematic Literature Review) methodology. This provides quantitative metrics for precision,\n          recall, and F1-score analysis required for PhD thesis evaluation.\n\t\t\t\t"},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[985,1306],"text":"\n          Evaluate Academic Explorer&#39;s literature discovery capabilities against published systematic literature reviews\n          using the STAR (Systematic Literature Review) methodology. This provides quantitative metrics for precision,\n          recall, and F1-score analysis required for PhD thesis evaluation.\n\t\t\t\t"},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[985,1306],"text":"\n          Evaluate Academic Explorer&rsquo;s literature discovery capabilities against published systematic literature reviews\n          using the STAR (Systematic Literature Review) methodology. This provides quantitative metrics for precision,\n          recall, and F1-score analysis required for PhD thesis evaluation.\n\t\t\t\t"},"desc":"Replace with `&rsquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":263,"column":61,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[8018,8320],"text":" This evaluation demonstrates Academic Explorer&apos;s ability to\n            improve upon existing systematic reviews by identifying previously missed papers and providing more\n            efficient literature discovery pathways. Results provide quantitative evidence for thesis Chapter 6 evaluation.\n\t\t\t\t\t"},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[8018,8320],"text":" This evaluation demonstrates Academic Explorer&lsquo;s ability to\n            improve upon existing systematic reviews by identifying previously missed papers and providing more\n            efficient literature discovery pathways. Results provide quantitative evidence for thesis Chapter 6 evaluation.\n\t\t\t\t\t"},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[8018,8320],"text":" This evaluation demonstrates Academic Explorer&#39;s ability to\n            improve upon existing systematic reviews by identifying previously missed papers and providing more\n            efficient literature discovery pathways. Results provide quantitative evidence for thesis Chapter 6 evaluation.\n\t\t\t\t\t"},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[8018,8320],"text":" This evaluation demonstrates Academic Explorer&rsquo;s ability to\n            improve upon existing systematic reviews by identifying previously missed papers and providing more\n            efficient literature discovery pathways. Results provide quantitative evidence for thesis Chapter 6 evaluation.\n\t\t\t\t\t"},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Main evaluation dashboard for STAR methodology integration\n * Provides PhD thesis evaluation capabilities using systematic literature reviews\n */\n\nimport { createFileRoute, useNavigate } from \"@tanstack/react-router\"\nimport React from \"react\"\nimport { IconChartBar, IconSearch, IconTrendingUp, IconBulb } from \"@tabler/icons-react\"\nimport { logger } from \"@academic-explorer/utils/logger\";\n\nexport const Route = createFileRoute(\"/evaluation\")({\n\tcomponent: EvaluationDashboard,\n})\n\nfunction EvaluationDashboard() {\n\tconst navigate = useNavigate();\n\n\treturn (\n\t\t<div style={{ padding: \"24px\", maxWidth: \"1200px\", margin: \"0 auto\" }}>\n\t\t\t{/* Header */}\n\t\t\t<div style={{ marginBottom: \"32px\" }}>\n\t\t\t\t<h1 style={{\n\t\t\t\t\tfontSize: \"32px\",\n\t\t\t\t\tfontWeight: \"bold\",\n\t\t\t\t\tcolor: \"#1f2937\",\n\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t}}>\n          STAR Methodology Evaluation\n\t\t\t\t</h1>\n\t\t\t\t<p style={{\n\t\t\t\t\tfontSize: \"16px\",\n\t\t\t\t\tcolor: \"#6b7280\",\n\t\t\t\t\tlineHeight: \"1.6\",\n\t\t\t\t\tmaxWidth: \"800px\"\n\t\t\t\t}}>\n          Evaluate Academic Explorer's literature discovery capabilities against published systematic literature reviews\n          using the STAR (Systematic Literature Review) methodology. This provides quantitative metrics for precision,\n          recall, and F1-score analysis required for PhD thesis evaluation.\n\t\t\t\t</p>\n\t\t\t</div>\n\n\t\t\t{/* Dashboard Cards */}\n\t\t\t<div style={{\n\t\t\t\tdisplay: \"grid\",\n\t\t\t\tgridTemplateColumns: \"repeat(auto-fit, minmax(300px, 1fr))\",\n\t\t\t\tgap: \"24px\",\n\t\t\t\tmarginBottom: \"32px\"\n\t\t\t}}>\n\t\t\t\t{/* Datasets Card */}\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\tpadding: \"24px\",\n\t\t\t\t\tboxShadow: \"0 1px 3px rgba(0, 0, 0, 0.1)\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{ display: \"flex\", alignItems: \"center\", marginBottom: \"16px\" }}>\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tbackgroundColor: \"#dbeafe\",\n\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\tpadding: \"8px\",\n\t\t\t\t\t\t\tmarginRight: \"12px\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<IconChartBar size={20} />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<h3 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#1f2937\", margin: 0 }}>\n              STAR Datasets\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t</div>\n\t\t\t\t\t<p style={{ color: \"#6b7280\", marginBottom: \"16px\", lineHeight: \"1.5\" }}>\n            Upload and manage systematic literature review datasets for ground truth comparison\n\t\t\t\t\t</p>\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tlogger.debug(\"ui\", \"Navigate to datasets clicked\", {}, \"EvaluationDashboard\");\n\t\t\t\t\t\t\tvoid navigate({ to: \"/evaluation/datasets\" });\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\t\ttransition: \"background-color 0.2s\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = \"#2563eb\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = \"#3b82f6\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n            Manage Datasets\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Comparison Card */}\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\tpadding: \"24px\",\n\t\t\t\t\tboxShadow: \"0 1px 3px rgba(0, 0, 0, 0.1)\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{ display: \"flex\", alignItems: \"center\", marginBottom: \"16px\" }}>\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tbackgroundColor: \"#dcfce7\",\n\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\tpadding: \"8px\",\n\t\t\t\t\t\t\tmarginRight: \"12px\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<IconSearch size={20} />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<h3 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#1f2937\", margin: 0 }}>\n              Run Comparisons\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t</div>\n\t\t\t\t\t<p style={{ color: \"#6b7280\", marginBottom: \"16px\", lineHeight: \"1.5\" }}>\n            Execute Academic Explorer searches against STAR datasets and calculate precision/recall metrics\n\t\t\t\t\t</p>\n\t\t\t\t\t<button\n\t\t\t\t\t\tdisabled\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tbackgroundColor: \"#9ca3af\",\n\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\tcursor: \"not-allowed\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n            Start Comparison\n\t\t\t\t\t</button>\n\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#9ca3af\", marginTop: \"8px\" }}>\n            Requires datasets to be uploaded first\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Results Card */}\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\tpadding: \"24px\",\n\t\t\t\t\tboxShadow: \"0 1px 3px rgba(0, 0, 0, 0.1)\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{ display: \"flex\", alignItems: \"center\", marginBottom: \"16px\" }}>\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tbackgroundColor: \"#fef3c7\",\n\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\tpadding: \"8px\",\n\t\t\t\t\t\t\tmarginRight: \"12px\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<IconTrendingUp size={20} />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<h3 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#1f2937\", margin: 0 }}>\n              Results & Analytics\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t</div>\n\t\t\t\t\t<p style={{ color: \"#6b7280\", marginBottom: \"16px\", lineHeight: \"1.5\" }}>\n            View detailed comparison results, precision/recall charts, and thesis-ready statistics\n\t\t\t\t\t</p>\n\t\t\t\t\t<button\n\t\t\t\t\t\tdisabled\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tbackgroundColor: \"#9ca3af\",\n\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\tcursor: \"not-allowed\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n            View Results\n\t\t\t\t\t</button>\n\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#9ca3af\", marginTop: \"8px\" }}>\n            No comparison results available yet\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t{/* Methodology Information */}\n\t\t\t<div style={{\n\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\tborderRadius: \"12px\",\n\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\tpadding: \"24px\"\n\t\t\t}}>\n\t\t\t\t<h2 style={{\n\t\t\t\t\tfontSize: \"20px\",\n\t\t\t\t\tfontWeight: \"600\",\n\t\t\t\t\tcolor: \"#1f2937\",\n\t\t\t\t\tmarginBottom: \"16px\"\n\t\t\t\t}}>\n          STAR Methodology Overview\n\t\t\t\t</h2>\n\n\t\t\t\t<div style={{\n\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\tgridTemplateColumns: \"repeat(auto-fit, minmax(250px, 1fr))\",\n\t\t\t\t\tgap: \"20px\"\n\t\t\t\t}}>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n              1. Dataset Upload\n\t\t\t\t\t\t</h4>\n\t\t\t\t\t\t<p style={{ fontSize: \"13px\", color: \"#6b7280\", lineHeight: \"1.4\", margin: 0 }}>\n              Import existing systematic literature reviews as CSV/JSON with included/excluded papers\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n              2. Search Replication\n\t\t\t\t\t\t</h4>\n\t\t\t\t\t\t<p style={{ fontSize: \"13px\", color: \"#6b7280\", lineHeight: \"1.4\", margin: 0 }}>\n              Run Academic Explorer searches using original STAR search criteria and strategies\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n              3. Paper Matching\n\t\t\t\t\t\t</h4>\n\t\t\t\t\t\t<p style={{ fontSize: \"13px\", color: \"#6b7280\", lineHeight: \"1.4\", margin: 0 }}>\n              Match discovered papers to ground truth using DOI, title, and OpenAlex ID fuzzy matching\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h4 style={{ fontSize: \"14px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n              4. Metrics Calculation\n\t\t\t\t\t\t</h4>\n\t\t\t\t\t\t<p style={{ fontSize: \"13px\", color: \"#6b7280\", lineHeight: \"1.4\", margin: 0 }}>\n              Calculate precision, recall, F1-score, and identify additional papers for innovation metrics\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div style={{\n\t\t\t\t\tmarginTop: \"20px\",\n\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\tborder: \"1px solid #e5e7eb\"\n\t\t\t\t}}>\n\t\t\t\t\t<p style={{\n\t\t\t\t\t\tfontSize: \"13px\",\n\t\t\t\t\t\tcolor: \"#374151\",\n\t\t\t\t\t\tmargin: 0,\n\t\t\t\t\t\tfontStyle: \"italic\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<span style={{ display: \"inline-flex\", alignItems: \"center\", gap: \"4px\" }}>\n\t\t\t\t\t\t\t<IconBulb size={14} />\n\t\t\t\t\t\t\t<strong>PhD Evaluation Context:</strong>\n\t\t\t\t\t\t</span> This evaluation demonstrates Academic Explorer's ability to\n            improve upon existing systematic reviews by identifying previously missed papers and providing more\n            efficient literature discovery pathways. Results provide quantitative evidence for thesis Chapter 6 evaluation.\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t)\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/evaluation/datasets.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":65,"column":75,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":65,"endColumn":77,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2180,2182],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"jsx-a11y/no-static-element-interactions","severity":1,"message":"Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.","line":172,"column":7,"nodeType":"JSXOpeningElement","endLine":188,"endColumn":8},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":224,"column":9,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":224,"endColumn":25}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * STAR datasets management interface\n * Upload, manage, and process systematic literature review datasets\n */\n\nimport { createFileRoute } from \"@tanstack/react-router\"\nimport React, { useState } from \"react\"\nimport { IconUpload, IconChartBar } from \"@tabler/icons-react\"\nimport { parseSTARFile, createSTARDatasetFromParseResult, DEFAULT_COLUMN_MAPPINGS } from \"@academic-explorer/utils\";\nimport type { STARDataset } from \"@academic-explorer/utils\";\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\n\nexport const Route = createFileRoute(\"/evaluation/datasets\")({\n\tcomponent: DatasetsManagement,\n})\n\n// Types are imported from @academic-explorer/utils\n\nfunction DatasetsManagement() {\n\tconst [datasets, setDatasets] = useState<STARDataset[]>([])\n\tconst [showUploadModal, setShowUploadModal] = useState(false)\n\tconst [uploadFile, setUploadFile] = useState<File | null>(null)\n\tconst [uploadProgress, setUploadProgress] = useState(0)\n\tconst [isUploading, setIsUploading] = useState(false)\n\n\tconst handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {\n\t\tconst file = event.target.files?.[0]\n\t\tif (file) {\n\t\t\tsetUploadFile(file)\n\t\t}\n\t}\n\n\tconst handleUpload = async () => {\n\t\tif (!uploadFile) return\n\n\t\tsetIsUploading(true)\n\t\tsetUploadProgress(0)\n\n\t\ttry {\n\t\t\t// Show initial progress\n\t\t\tsetUploadProgress(10)\n\n\t\t\t// Parse file using actual file parser\n\t\t\tsetUploadProgress(30)\n\t\t\tconst parseResult = await parseSTARFile(uploadFile, DEFAULT_COLUMN_MAPPINGS)\n\n\t\t\t// Check for parsing errors\n\t\t\tif (parseResult.metadata.errors.length > 0) {\n\t\t\t\tlogger.warn(\"ui\", \"File parsing warnings\", { errors: parseResult.metadata.errors }, \"DatasetsManagement\")\n\n\t\t\t\t// Show error details to user for critical errors\n\t\t\t\tconst criticalErrors = parseResult.metadata.errors.filter(error =>\n\t\t\t\t\terror.includes(\"Failed to parse\")\n\t\t\t\t)\n\n\t\t\t\tif (criticalErrors.length > 0) {\n\t\t\t\t\talert(`Upload failed: ${criticalErrors.join(\", \")}\\n\\nSupported formats: CSV, JSON, Excel`)\n\t\t\t\t\tthrow new Error(\"File parsing failed\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetUploadProgress(70)\n\n\t\t\t// Create dataset from parse result\n\t\t\tconst reviewTopic = prompt(\"Enter the review topic for this dataset:\") || \"Systematic Literature Review\"\n\t\t\tconst newDataset = createSTARDatasetFromParseResult(uploadFile, parseResult, reviewTopic)\n\n\t\t\tsetUploadProgress(100)\n\n\t\t\t// Add to datasets\n\t\t\tsetDatasets(prev => [...prev, newDataset])\n\n\t\t\t// Reset upload state\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetIsUploading(false)\n\t\t\t\tsetUploadProgress(0)\n\t\t\t\tsetUploadFile(null)\n\t\t\t\tsetShowUploadModal(false)\n\t\t\t}, 1000)\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Upload failed:\", error, \"DatasetsManagement\", \"routing\")\n\t\t\tsetIsUploading(false)\n\t\t}\n\t}\n\n\tconst formatDate = (date: Date) => {\n\t\treturn new Intl.DateTimeFormat(\"en-US\", {\n\t\t\tmonth: \"short\",\n\t\t\tday: \"numeric\",\n\t\t\tyear: \"numeric\",\n\t\t\thour: \"2-digit\",\n\t\t\tminute: \"2-digit\"\n\t\t}).format(date)\n\t}\n\n\treturn (\n\t\t<div style={{ padding: \"24px\", maxWidth: \"1200px\", margin: \"0 auto\" }}>\n\t\t\t{/* Header */}\n\t\t\t<div style={{ display: \"flex\", alignItems: \"center\", justifyContent: \"space-between\", marginBottom: \"32px\" }}>\n\t\t\t\t<div>\n\t\t\t\t\t<h1 style={{ fontSize: \"28px\", fontWeight: \"bold\", color: \"#1f2937\", marginBottom: \"8px\" }}>\n            STAR Datasets\n\t\t\t\t\t</h1>\n\t\t\t\t\t<p style={{ fontSize: \"16px\", color: \"#6b7280\" }}>\n            Manage systematic literature review datasets for evaluation comparisons\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\n\t\t\t\t<button\n\t\t\t\t\tonClick={() => { setShowUploadModal(true); }}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\tpadding: \"12px 20px\",\n\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\tgap: \"8px\"\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<IconUpload size={16} />\n          Upload Dataset\n\t\t\t\t</button>\n\t\t\t</div>\n\n\t\t\t{/* Datasets Grid */}\n\t\t\t{datasets.length === 0 ? (\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\tpadding: \"48px 24px\",\n\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{ marginBottom: \"16px\", opacity: 0.3 }}>\n\t\t\t\t\t\t<IconChartBar size={48} />\n\t\t\t\t\t</div>\n\t\t\t\t\t<h3 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n            No datasets uploaded yet\n\t\t\t\t\t</h3>\n\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", marginBottom: \"24px\", maxWidth: \"400px\", margin: \"0 auto 24px\" }}>\n            Upload your first STAR dataset to begin evaluation. Supported formats: CSV, JSON, Excel.\n\t\t\t\t\t</p>\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={() => { setShowUploadModal(true); }}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\tpadding: \"10px 18px\",\n\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n            Upload Your First Dataset\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t) : (\n\t\t\t\t<div style={{\n\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\tgridTemplateColumns: \"repeat(auto-fill, minmax(350px, 1fr))\",\n\t\t\t\t\tgap: \"24px\"\n\t\t\t\t}}>\n\t\t\t\t\t{datasets.map((dataset) => (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tkey={dataset.id}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\tboxShadow: \"0 1px 3px rgba(0, 0, 0, 0.1)\",\n\t\t\t\t\t\t\t\ttransition: \"box-shadow 0.2s\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\t\t\te.currentTarget.style.boxShadow = \"0 4px 6px rgba(0, 0, 0, 0.1)\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\t\t\te.currentTarget.style.boxShadow = \"0 1px 3px rgba(0, 0, 0, 0.1)\"\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div style={{ marginBottom: \"16px\" }}>\n\t\t\t\t\t\t\t\t<h3 style={{ fontSize: \"16px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"4px\" }}>\n\t\t\t\t\t\t\t\t\t{dataset.name}\n\t\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", marginBottom: \"8px\" }}>\n                  Topic: {dataset.reviewTopic}\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#9ca3af\" }}>\n                  Uploaded {formatDate(dataset.uploadDate)}\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\t\t\t\tgridTemplateColumns: \"1fr 1fr\",\n\t\t\t\t\t\t\t\tgap: \"12px\",\n\t\t\t\t\t\t\t\tmarginBottom: \"16px\",\n\t\t\t\t\t\t\t\tpadding: \"12px\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\t\t\t\tborderRadius: \"6px\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#1f2937\" }}>\n\t\t\t\t\t\t\t\t\t\t{dataset.originalPaperCount}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>Total Papers</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#10b981\" }}>\n\t\t\t\t\t\t\t\t\t\t{dataset.includedPapers.length}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>Included</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t{dataset.metadata && typeof dataset.metadata['description'] === 'string' && (\n\t\t\t\t\t\t\t\t<p style={{\n\t\t\t\t\t\t\t\t\tfontSize: \"13px\",\n\t\t\t\t\t\t\t\t\tcolor: \"#6b7280\",\n\t\t\t\t\t\t\t\t\tmarginBottom: \"16px\",\n\t\t\t\t\t\t\t\t\tlineHeight: \"1.4\"\n\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t{dataset.metadata['description']}\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t<div style={{ display: \"flex\", gap: \"8px\" }}>\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"ui\", \"View dataset details clicked\", { datasetId: dataset.id }, \"DatasetsManagement\");\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tflex: 1,\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\t\t\t\t\tcolor: \"#374151\",\n\t\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\tfontSize: \"13px\",\n\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n                  View Details\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"ui\", \"Run comparison clicked\", { datasetId: dataset.id }, \"DatasetsManagement\");\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tflex: 1,\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#10b981\",\n\t\t\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\tfontSize: \"13px\",\n\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n                  Run Comparison\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{/* Upload Modal */}\n\t\t\t{showUploadModal && (\n\t\t\t\t<div style={{\n\t\t\t\t\tposition: \"fixed\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tbackgroundColor: \"rgba(0, 0, 0, 0.5)\",\n\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\tjustifyContent: \"center\",\n\t\t\t\t\tzIndex: 1000\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\t\twidth: \"500px\",\n\t\t\t\t\t\tmaxWidth: \"90vw\",\n\t\t\t\t\t\tmaxHeight: \"80vh\",\n\t\t\t\t\t\toverflow: \"hidden\",\n\t\t\t\t\t\tboxShadow: \"0 20px 25px -5px rgba(0, 0, 0, 0.1)\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tpadding: \"24px 24px 16px\",\n\t\t\t\t\t\t\tborderBottom: \"1px solid #e5e7eb\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<h2 style={{ fontSize: \"20px\", fontWeight: \"600\", color: \"#1f2937\", margin: 0 }}>\n                Upload STAR Dataset\n\t\t\t\t\t\t\t</h2>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div style={{ padding: \"24px\" }}>\n\t\t\t\t\t\t\t{!uploadFile ? (\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\t\ttabIndex={0}\n\t\t\t\t\t\t\t\t\taria-label=\"Click to select a file or press Enter\"\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tborder: \"2px dashed #d1d5db\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\t\t\tpadding: \"48px 24px\",\n\t\t\t\t\t\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\tonClick={() => document.getElementById(\"file-upload\")?.click()}\n\t\t\t\t\t\t\t\t\tonKeyDown={(e) => {\n\t\t\t\t\t\t\t\t\t\tif (e.key === \"Enter\" || e.key === \" \") {\n\t\t\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t\t\t\tdocument.getElementById(\"file-upload\")?.click();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div style={{ marginBottom: \"12px\" }}>\n\t\t\t\t\t\t\t\t\t\t<IconUpload size={32} />\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"16px\", fontWeight: \"500\", color: \"#374151\", marginBottom: \"8px\" }}>\n                    Upload your dataset file\n\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", marginBottom: \"16px\" }}>\n                    Supported formats: CSV, JSON, Excel (.xlsx)\n\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tid=\"file-upload\"\n\t\t\t\t\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\t\t\t\t\taccept=\".csv,.json,.xlsx,.xls\"\n\t\t\t\t\t\t\t\t\t\tonChange={(e) => { handleFileUpload(e); }}\n\t\t\t\t\t\t\t\t\t\tstyle={{ display: \"none\" }}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n                    Choose File\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\t\t\tmarginBottom: \"16px\"\n\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", fontWeight: \"500\", color: \"#374151\", marginBottom: \"4px\" }}>\n                      Selected file: {uploadFile.name}\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#6b7280\" }}>\n                      Size: {(uploadFile.size / 1024).toFixed(1)} KB\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t{isUploading && (\n\t\t\t\t\t\t\t\t\t\t<div style={{ marginBottom: \"16px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\t\t\t\t\tjustifyContent: \"space-between\",\n\t\t\t\t\t\t\t\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t\t\t<span style={{ fontSize: \"14px\", color: \"#374151\" }}>Uploading...</span>\n\t\t\t\t\t\t\t\t\t\t\t\t<span style={{ fontSize: \"14px\", color: \"#6b7280\" }}>{uploadProgress}%</span>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#e5e7eb\",\n\t\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\t\t\t\t\theight: \"8px\",\n\t\t\t\t\t\t\t\t\t\t\t\toverflow: \"hidden\"\n\t\t\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\t\t\t\t\t\t\t\theight: \"100%\",\n\t\t\t\t\t\t\t\t\t\t\t\t\twidth: `${String(uploadProgress)}%`,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttransition: \"width 0.3s ease\"\n\t\t\t\t\t\t\t\t\t\t\t\t}} />\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\tjustifyContent: \"flex-end\",\n\t\t\t\t\t\t\t\tgap: \"12px\",\n\t\t\t\t\t\t\t\tmarginTop: \"24px\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\tsetShowUploadModal(false)\n\t\t\t\t\t\t\t\t\t\tsetUploadFile(null)\n\t\t\t\t\t\t\t\t\t\tsetUploadProgress(0)\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\tdisabled={isUploading}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\t\t\t\t\tcolor: \"#374151\",\n\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\tcursor: isUploading ? \"not-allowed\" : \"pointer\",\n\t\t\t\t\t\t\t\t\t\topacity: isUploading ? 0.5 : 1\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n                  Cancel\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tonClick={() => void handleUpload()}\n\t\t\t\t\t\t\t\t\tdisabled={!uploadFile || isUploading}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: uploadFile && !isUploading ? \"#3b82f6\" : \"#9ca3af\",\n\t\t\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\tcursor: uploadFile && !isUploading ? \"pointer\" : \"not-allowed\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{isUploading ? \"Processing...\" : \"Upload Dataset\"}\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t</div>\n\t)\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/evaluation/results.tsx","messages":[{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":123,"column":20,"nodeType":"AwaitExpression","messageId":"await","endLine":123,"endColumn":82,"suggestions":[{"messageId":"removeAwait","fix":{"range":[4089,4094],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":274,"column":40,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":274,"endColumn":64},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":341,"column":13,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":341,"endColumn":39},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":341,"column":64,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":341,"endColumn":83},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":345,"column":26,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":345,"endColumn":28,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11178,11180],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":345,"column":70,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":345,"endColumn":72,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11222,11224],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":522,"column":32,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[16917,16950],"text":"\n                        Query: &quot;"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[16917,16950],"text":"\n                        Query: &ldquo;"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[16917,16950],"text":"\n                        Query: &#34;"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[16917,16950],"text":"\n                        Query: &rdquo;"},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":522,"column":62,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[16979,16993],"text":"&quot;\n\t\t\t\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[16979,16993],"text":"&ldquo;\n\t\t\t\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[16979,16993],"text":"&#34;\n\t\t\t\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[16979,16993],"text":"&rdquo;\n\t\t\t\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":783,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":783,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[26288,26290],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":797,"column":30,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":797,"endColumn":56},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":859,"column":58,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[28910,29320],"text":"\n              These results demonstrate Academic Explorer&apos;s quantitative performance improvements over traditional\n              systematic review methodologies. The precision/recall metrics and additional papers discovered provide\n              statistical evidence for Chapter 6 evaluation. Export individual results for detailed statistical analysis\n              and inclusion in thesis appendices.\n\t\t\t\t\t\t"},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[28910,29320],"text":"\n              These results demonstrate Academic Explorer&lsquo;s quantitative performance improvements over traditional\n              systematic review methodologies. The precision/recall metrics and additional papers discovered provide\n              statistical evidence for Chapter 6 evaluation. Export individual results for detailed statistical analysis\n              and inclusion in thesis appendices.\n\t\t\t\t\t\t"},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[28910,29320],"text":"\n              These results demonstrate Academic Explorer&#39;s quantitative performance improvements over traditional\n              systematic review methodologies. The precision/recall metrics and additional papers discovered provide\n              statistical evidence for Chapter 6 evaluation. Export individual results for detailed statistical analysis\n              and inclusion in thesis appendices.\n\t\t\t\t\t\t"},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[28910,29320],"text":"\n              These results demonstrate Academic Explorer&rsquo;s quantitative performance improvements over traditional\n              systematic review methodologies. The precision/recall metrics and additional papers discovered provide\n              statistical evidence for Chapter 6 evaluation. Export individual results for detailed statistical analysis\n              and inclusion in thesis appendices.\n\t\t\t\t\t\t"},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * STAR comparison results dashboard\n * Display precision/recall metrics and thesis-ready statistics\n */\n\nimport { createFileRoute } from \"@tanstack/react-router\"\nimport React, { useState, useMemo, useEffect } from \"react\"\nimport { IconChartBar, IconSearch, IconBulb } from \"@tabler/icons-react\"\nimport { compareAcademicExplorerResults, DEFAULT_MATCHING_CONFIG } from \"@academic-explorer/utils\";\nimport { searchBasedOnSTARDataset, calculateSearchCoverage, DEFAULT_SEARCH_CONFIG } from \"@academic-explorer/utils\";\nimport type { STARDataset, ComparisonResults as ComparisonResultsType, WorkReference, ComparisonProgress } from \"@academic-explorer/utils\";\n\n// Type guard for STARDataset array\nfunction isSTARDatasetArray(data: unknown): data is STARDataset[] {\n\treturn Array.isArray(data) && data.every(item =>\n\t\ttypeof item === \"object\" &&\n\t\titem !== null &&\n\t\t\"id\" in item &&\n\t\t\"name\" in item &&\n\t\t\"reviewTopic\" in item &&\n\t\t\"originalPaperCount\" in item &&\n\t\t\"includedPapers\" in item\n\t)\n}\nimport {\n\tPerformanceComparisonChart,\n\tPrecisionRecallScatterPlot,\n\tConfusionMatrixHeatmap,\n\tDatasetStatisticsOverview\n} from \"@/components/evaluation/MetaAnalysisCharts\"\nimport { MissingPaperDetection } from \"@/components/evaluation/MissingPaperDetection\"\nimport type { MissingPaperDetectionResults } from \"@academic-explorer/utils\";\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\n\nexport const Route = createFileRoute(\"/evaluation/results\")({\n\tcomponent: ComparisonResults,\n})\n\ninterface ComparisonRun {\n  id: string\n  datasetName: string\n  runDate: Date\n  status: \"completed\" | \"running\" | \"failed\" | \"ready\"\n  comparisonResults?: ComparisonResultsType\n  searchCriteria: {\n    query: string\n    entityTypes: string[]\n    dateRange?: {\n      start: number\n      end: number\n    }\n  }\n  executionTime?: number // milliseconds\n  progress?: ComparisonProgress\n  error?: string\n}\n\ninterface LegacyResult {\n  id: string\n  datasetName: string\n  runDate: Date\n  status: string\n  metrics: {\n    precision: number\n    recall: number\n    f1Score: number\n    truePositives: number\n    falsePositives: number\n    falseNegatives: number\n    totalFound: number\n    totalGroundTruth: number\n    additionalPapersFound: number\n  }\n  searchCriteria: {\n    query: string\n    entityTypes: string[]\n  }\n  executionTime: number\n}\n\nfunction ComparisonResults() {\n\tconst [starDatasets, setStarDatasets] = useState<STARDataset[]>([])\n\tconst [comparisonRuns, setComparisonRuns] = useState<ComparisonRun[]>([])\n\tconst [isRunningComparison, setIsRunningComparison] = useState(false)\n\tconst [, setSelectedDatasetId] = useState<string | null>(null)\n\tconst [activeVisualizationTab, setActiveVisualizationTab] = useState<\"performance\" | \"scatter\" | \"heatmap\" | \"overview\">(\"performance\")\n\tconst [, setMissingPaperResults] = useState<{ [datasetId: string]: MissingPaperDetectionResults }>({})\n\tconst [selectedDatasetForMissingPapers, setSelectedDatasetForMissingPapers] = useState<string | null>(null)\n\n\t// Load STAR datasets from localStorage on component mount\n\tuseEffect(() => {\n\t\ttry {\n\t\t\tconst savedDatasets = localStorage.getItem(\"star-datasets\")\n\t\t\tif (savedDatasets) {\n\t\t\t\tconst parsedDatasets: unknown = JSON.parse(savedDatasets)\n\t\t\t\tif (isSTARDatasetArray(parsedDatasets)) {\n\t\t\t\t\tconst datasets = parsedDatasets\n\t\t\t\t\tsetStarDatasets(datasets)\n\n\t\t\t\t\t// Initialize comparison runs for each dataset\n\t\t\t\t\tconst runs: ComparisonRun[] = datasets.map(dataset => ({\n\t\t\t\t\t\tid: `run_${dataset.id}`,\n\t\t\t\t\t\tdatasetName: dataset.name,\n\t\t\t\t\t\trunDate: new Date(),\n\t\t\t\t\t\tstatus: \"ready\",\n\t\t\t\t\t\tsearchCriteria: {\n\t\t\t\t\t\t\tquery: dataset.reviewTopic,\n\t\t\t\t\t\t\tentityTypes: [\"works\"]\n\t\t\t\t\t\t}\n\t\t\t\t\t}))\n\t\t\t\t\tsetComparisonRuns(runs)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to load STAR datasets:\", error, \"ComparisonResults\", \"routing\")\n\t\t}\n\t}, [])\n\n\t// Real Academic Explorer search function using OpenAlex API\n\tconst performAcademicExplorerSearch = async (dataset: STARDataset): Promise<WorkReference[]> => {\n\t\ttry {\n\t\t\t// Use the optimized search based on the STAR dataset criteria\n\t\t\tconst results = await searchBasedOnSTARDataset(dataset, DEFAULT_SEARCH_CONFIG)\n\n\t\t\t// Calculate and log search coverage for debugging\n\t\t\tconst coverage = calculateSearchCoverage(results, dataset)\n\t\t\tlogger.debug(\"api\", \"Search coverage analysis\", { coverage }, \"ComparisonResults\");\n\n\t\t\treturn results\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Academic Explorer search failed:\", error, \"ComparisonResults\", \"routing\")\n\t\t\tthrow error\n\t\t}\n\t}\n\n\t// Run comparison for a specific dataset\n\tconst runComparison = async (datasetId: string) => {\n\t\tconst dataset = starDatasets.find(d => d.id === datasetId)\n\t\tif (!dataset) return\n\n\t\tsetIsRunningComparison(true)\n\t\tsetSelectedDatasetId(datasetId)\n\n\t\t// Update run status\n\t\tsetComparisonRuns(prev => prev.map(run =>\n\t\t\trun.id === `run_${datasetId}`\n\t\t\t\t? { ...run, status: \"running\" as const, runDate: new Date() }\n\t\t\t\t: run\n\t\t))\n\n\t\ttry {\n\t\t\tconst startTime = performance.now()\n\n\t\t\t// Step 1: Perform Academic Explorer search\n\t\t\tconst academicExplorerResults = await performAcademicExplorerSearch(dataset)\n\n\t\t\t// Step 2: Run comparison with progress tracking\n\t\t\tconst comparisonResults = compareAcademicExplorerResults(\n\t\t\t\tacademicExplorerResults,\n\t\t\t\tdataset,\n\t\t\t\tDEFAULT_MATCHING_CONFIG,\n\t\t\t\t(progress) => {\n\t\t\t\t\tsetComparisonRuns(prev => prev.map(run =>\n\t\t\t\t\t\trun.id === `run_${datasetId}`\n\t\t\t\t\t\t\t? { ...run, progress }\n\t\t\t\t\t\t\t: run\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tconst executionTime = performance.now() - startTime\n\n\t\t\t// Update with completed results\n\t\t\tsetComparisonRuns(prev => prev.map(run =>\n\t\t\t\trun.id === `run_${datasetId}`\n\t\t\t\t\t? {\n\t\t\t\t\t\t...run,\n\t\t\t\t\t\tstatus: \"completed\" as const,\n\t\t\t\t\t\tcomparisonResults,\n\t\t\t\t\t\texecutionTime\n\t\t\t\t\t}\n\t\t\t\t\t: run\n\t\t\t))\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Comparison failed:\", error, \"ComparisonResults\", \"routing\")\n\t\t\tsetComparisonRuns(prev => prev.map(run =>\n\t\t\t\trun.id === `run_${datasetId}`\n\t\t\t\t\t? {\n\t\t\t\t\t\t...run,\n\t\t\t\t\t\tstatus: \"failed\" as const,\n\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t\t}\n\t\t\t\t\t: run\n\t\t\t))\n\t\t} finally {\n\t\t\tsetIsRunningComparison(false)\n\t\t\tsetSelectedDatasetId(null)\n\t\t}\n\t}\n\n\t// Mock data for demonstration when no real datasets exist\n\tconst mockResults = useMemo(() => [\n\t\t{\n\t\t\tid: \"mock_comparison_1\",\n\t\t\tdatasetName: \"Machine Learning Systematic Review\",\n\t\t\trunDate: new Date(\"2025-01-10\"),\n\t\t\tstatus: \"completed\",\n\t\t\tmetrics: {\n\t\t\t\tprecision: 0.87,\n\t\t\t\trecall: 0.92,\n\t\t\t\tf1Score: 0.895,\n\t\t\t\ttruePositives: 156,\n\t\t\t\tfalsePositives: 23,\n\t\t\t\tfalseNegatives: 14,\n\t\t\t\ttotalFound: 179,\n\t\t\t\ttotalGroundTruth: 170,\n\t\t\t\tadditionalPapersFound: 12\n\t\t\t},\n\t\t\tsearchCriteria: {\n\t\t\t\tquery: \"machine learning systematic review\",\n\t\t\t\tentityTypes: [\"works\", \"authors\"]\n\t\t\t},\n\t\t\texecutionTime: 45000\n\t\t}\n\t], [])\n\n\t// Use real comparison runs if available, otherwise show mock data\n\tconst displayResults = useMemo(() => {\n\t\treturn comparisonRuns.length > 0 ? comparisonRuns : mockResults\n\t}, [comparisonRuns, mockResults])\n\n\tconst averageMetrics = useMemo(() => {\n\t\tif (displayResults.length === 0) return null\n\n\t\tconst completed = displayResults.filter(r => r.status === \"completed\")\n\t\tconst totalResults = completed.length\n\n\t\tif (totalResults === 0) return null\n\n\t\tconst metricsArray = completed.map(r => getResultMetrics(r)).filter(m => m !== null)\n\n\t\tif (metricsArray.length === 0) return null\n\n\t\treturn {\n\t\t\tavgPrecision: metricsArray.reduce((sum, m) => sum + m.precision, 0) / metricsArray.length,\n\t\t\tavgRecall: metricsArray.reduce((sum, m) => sum + m.recall, 0) / metricsArray.length,\n\t\t\tavgF1Score: metricsArray.reduce((sum, m) => sum + m.f1Score, 0) / metricsArray.length,\n\t\t\ttotalAdditionalPapers: metricsArray.reduce((sum, m) => sum + m.additionalPapersFound, 0),\n\t\t\tavgExecutionTime: completed.reduce((sum, r) => {\n\t\t\t\tconst execTime = \"executionTime\" in r ? r.executionTime : 0\n\t\t\t\treturn sum + (execTime || 0)\n\t\t\t}, 0) / totalResults\n\t\t}\n\t}, [displayResults])\n\n\t// Extract completed comparison results for visualizations\n\tconst completedComparisonResults = useMemo(() => {\n\t\treturn comparisonRuns\n\t\t\t.filter(run => run.status === \"completed\" && run.comparisonResults)\n\t\t\t.map(run => {\n\t\t\t\tif (!run.comparisonResults) {\n\t\t\t\t\tthrow new Error(\"Comparison results missing for completed run\")\n\t\t\t\t}\n\t\t\t\treturn run.comparisonResults\n\t\t\t})\n\t}, [comparisonRuns])\n\n\tconst formatPercent = (value: number) => `${(value * 100).toFixed(1)}%`\n\tconst formatTime = (ms: number) => `${(ms / 1000).toFixed(1)}s`\n\n\t// Helper to get metrics from either ComparisonRun or legacy format\n\tconst getResultMetrics = (result: ComparisonRun | LegacyResult) => {\n\t\tif (\"comparisonResults\" in result && result.comparisonResults) {\n\t\t\tconst comp = result.comparisonResults\n\t\t\treturn {\n\t\t\t\tprecision: comp.precision,\n\t\t\t\trecall: comp.recall,\n\t\t\t\tf1Score: comp.f1Score,\n\t\t\t\ttruePositives: comp.truePositives.length,\n\t\t\t\tfalsePositives: comp.falsePositives.length,\n\t\t\t\tfalseNegatives: comp.falseNegatives.length,\n\t\t\t\ttotalFound: comp.academicExplorerResults.length,\n\t\t\t\ttotalGroundTruth: comp.dataset.includedPapers.length,\n\t\t\t\tadditionalPapersFound: comp.additionalPapersFound.length\n\t\t\t}\n\t\t} else if (\"metrics\" in result) {\n\t\t\treturn result.metrics\n\t\t}\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div style={{ padding: \"24px\", maxWidth: \"1400px\", margin: \"0 auto\" }}>\n\t\t\t{/* Header */}\n\t\t\t<div style={{ marginBottom: \"32px\" }}>\n\t\t\t\t<h1 style={{ fontSize: \"28px\", fontWeight: \"bold\", color: \"#1f2937\", marginBottom: \"8px\" }}>\n          STAR Comparison Results\n\t\t\t\t</h1>\n\t\t\t\t<p style={{ fontSize: \"16px\", color: \"#6b7280\" }}>\n          Detailed analysis of Academic Explorer performance against systematic literature review ground truth\n\t\t\t\t</p>\n\t\t\t</div>\n\n\t\t\t{/* Run Comparison Controls */}\n\t\t\t{starDatasets.length > 0 && (\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\tpadding: \"24px\",\n\t\t\t\t\tmarginBottom: \"32px\"\n\t\t\t\t}}>\n\t\t\t\t\t<h2 style={{ fontSize: \"20px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"16px\" }}>\n            Available STAR Datasets\n\t\t\t\t\t</h2>\n\t\t\t\t\t<div style={{ display: \"grid\", gap: \"12px\" }}>\n\t\t\t\t\t\t{starDatasets.map((dataset) => {\n\t\t\t\t\t\t\tconst run = comparisonRuns.find(r => r.id === `run_${dataset.id}`)\n\t\t\t\t\t\t\tconst isRunning = run?.status === \"running\"\n\t\t\t\t\t\t\tconst isCompleted = run?.status === \"completed\"\n\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tkey={dataset.id}\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\t\t\talignItems: \"center\",\n\t\t\t\t\t\t\t\t\t\tjustifyContent: \"space-between\",\n\t\t\t\t\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\"\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t<h3 style={{ fontSize: \"16px\", fontWeight: \"500\", color: \"#1f2937\", marginBottom: \"4px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t{dataset.name}\n\t\t\t\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\" }}>\n\t\t\t\t\t\t\t\t\t\t\t{dataset.originalPaperCount ?? 'Unknown'} papers • {dataset.reviewTopic ?? 'No topic specified'}\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t{run?.progress && (\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#3b82f6\", marginTop: \"4px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t{run.progress?.message ?? 'Processing...'} ({run.progress?.progress ?? 0}%)\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\tonClick={() => void runComparison(dataset.id)}\n\t\t\t\t\t\t\t\t\t\tdisabled={isRunningComparison || isRunning}\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tpadding: \"8px 16px\",\n\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: isCompleted ? \"#10b981\" : (isRunning ? \"#f59e0b\" : \"#3b82f6\"),\n\t\t\t\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\t\tcursor: isRunningComparison || isRunning ? \"not-allowed\" : \"pointer\",\n\t\t\t\t\t\t\t\t\t\t\topacity: isRunningComparison || isRunning ? 0.6 : 1\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{isCompleted ? \"Re-run\" : (isRunning ? \"Running...\" : \"Run Comparison\")}\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{displayResults.length === 0 ? (\n\t\t\t\t<div style={{\n\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\tpadding: \"48px 24px\",\n\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t}}>\n\t\t\t\t\t<div style={{ marginBottom: \"16px\", opacity: 0.3 }}>\n\t\t\t\t\t\t<IconChartBar size={48} />\n\t\t\t\t\t</div>\n\t\t\t\t\t<h3 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n            No comparison results available\n\t\t\t\t\t</h3>\n\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", marginBottom: \"24px\" }}>\n\t\t\t\t\t\t{starDatasets.length === 0\n\t\t\t\t\t\t\t? \"Upload STAR datasets first, then run comparisons to see detailed performance metrics here\"\n\t\t\t\t\t\t\t: \"Run comparisons against uploaded STAR datasets to see detailed performance metrics here\"\n\t\t\t\t\t\t}\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t) : (\n\t\t\t\t<>\n\t\t\t\t\t{/* Summary Metrics */}\n\t\t\t\t\t{averageMetrics && (\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\t\t\tgridTemplateColumns: \"repeat(auto-fit, minmax(200px, 1fr))\",\n\t\t\t\t\t\t\tgap: \"16px\",\n\t\t\t\t\t\t\tmarginBottom: \"32px\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#3b82f6\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{formatPercent(averageMetrics.avgPrecision)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\", fontWeight: \"500\" }}>\n                  Average Precision\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#10b981\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{formatPercent(averageMetrics.avgRecall)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\", fontWeight: \"500\" }}>\n                  Average Recall\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#8b5cf6\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{formatPercent(averageMetrics.avgF1Score)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\", fontWeight: \"500\" }}>\n                  Average F1-Score\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#f59e0b\", marginBottom: \"8px\" }}>\n                  +{averageMetrics.totalAdditionalPapers}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\", fontWeight: \"500\" }}>\n                  Additional Papers Found\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\ttextAlign: \"center\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"32px\", fontWeight: \"bold\", color: \"#6b7280\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t\t\t{formatTime(averageMetrics.avgExecutionTime)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ fontSize: \"14px\", color: \"#6b7280\", fontWeight: \"500\" }}>\n                  Average Execution Time\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Individual Results */}\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\toverflow: \"hidden\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\tborderBottom: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<h2 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#1f2937\", margin: 0 }}>\n                Individual Comparison Results\n\t\t\t\t\t\t\t</h2>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div style={{ overflow: \"auto\" }}>\n\t\t\t\t\t\t\t{displayResults.map((result, index) => {\n\t\t\t\t\t\t\t\tconst metrics = getResultMetrics(result)\n\t\t\t\t\t\t\t\tif (!metrics) return null\n\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tkey={result.id}\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\t\t\t\tborderBottom: index < displayResults.length - 1 ? \"1px solid #f3f4f6\" : \"none\"\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\t\t\t\tjustifyContent: \"space-between\",\n\t\t\t\t\t\t\t\t\t\t\talignItems: \"flex-start\",\n\t\t\t\t\t\t\t\t\t\t\tmarginBottom: \"16px\"\n\t\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t\t<h3 style={{ fontSize: \"16px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"4px\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{result.datasetName}\n\t\t\t\t\t\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", marginBottom: \"8px\" }}>\n                        Query: \"{result.searchCriteria.query}\"\n\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"12px\", color: \"#9ca3af\" }}>\n                        Completed on {result.runDate.toLocaleDateString()} •\n\t\t\t\t\t\t\t\t\t\t\t\t\t{formatTime((\"executionTime\" in result ? result.executionTime : 0) || 0)} • {\"apiCalls\" in result && typeof result.apiCalls === \"number\" ? result.apiCalls : \"N/A\"} API calls\n\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: result.status === \"completed\" ? \"#dcfce7\" : \"#fef3c7\",\n\t\t\t\t\t\t\t\t\t\t\t\tcolor: result.status === \"completed\" ? \"#065f46\" : \"#92400e\",\n\t\t\t\t\t\t\t\t\t\t\t\tpadding: \"4px 8px\",\n\t\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"4px\",\n\t\t\t\t\t\t\t\t\t\t\t\tfontSize: \"12px\",\n\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\t\t\ttextTransform: \"capitalize\"\n\t\t\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t\t\t{result.status}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\t\tdisplay: \"grid\",\n\t\t\t\t\t\t\t\t\t\t\tgridTemplateColumns: \"repeat(auto-fit, minmax(120px, 1fr))\",\n\t\t\t\t\t\t\t\t\t\t\tgap: \"16px\",\n\t\t\t\t\t\t\t\t\t\t\tmarginBottom: \"16px\"\n\t\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#3b82f6\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{formatPercent(metrics.precision)}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>Precision</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#10b981\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{formatPercent(metrics.recall)}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>Recall</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#8b5cf6\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{formatPercent(metrics.f1Score)}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>F1-Score</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#059669\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{metrics.truePositives}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>True Positives</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#dc2626\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{metrics.falsePositives}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>False Positives</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#b45309\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{metrics.falseNegatives}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>False Negatives</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t\t<div style={{ textAlign: \"center\" }}>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"#f59e0b\" }}>\n                        +{metrics.additionalPapersFound}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div style={{ fontSize: \"12px\", color: \"#6b7280\" }}>Additional Found</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\t\t\t\tgap: \"12px\",\n\t\t\t\t\t\t\t\t\t\t\tflexWrap: \"wrap\"\n\t\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f3f4f6\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: \"#374151\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: \"13px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => { logger.debug(\"ui\", \"View detailed breakdown clicked\", { resultId: result.id }, \"ComparisonResults\"); }}\n\t\t\t\t\t\t\t\t\t\t\t>\n                      View Breakdown\n\t\t\t\t\t\t\t\t\t\t\t</button>\n\n\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#3b82f6\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: \"13px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => { logger.debug(\"ui\", \"Export results clicked\", { resultId: result.id }, \"ComparisonResults\"); }}\n\t\t\t\t\t\t\t\t\t\t\t>\n                      Export Results\n\t\t\t\t\t\t\t\t\t\t\t</button>\n\n\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#10b981\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: \"white\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: \"13px\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\"\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => { logger.debug(\"ui\", \"View additional papers clicked\", { resultId: result.id }, \"ComparisonResults\"); }}\n\t\t\t\t\t\t\t\t\t\t\t>\n                      View Additional Papers ({metrics.additionalPapersFound})\n\t\t\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Meta-Analysis Visualizations */}\n\t\t\t\t\t{completedComparisonResults.length > 0 && (\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\tmarginTop: \"32px\",\n\t\t\t\t\t\t\toverflow: \"hidden\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\tborderBottom: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<h2 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"8px\" }}>\n                  Meta-Analysis Visualizations\n\t\t\t\t\t\t\t\t</h2>\n\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", margin: 0 }}>\n                  Advanced charts and statistical visualizations for thesis presentation\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t{/* Visualization Tabs */}\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tdisplay: \"flex\",\n\t\t\t\t\t\t\t\tborderBottom: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#fafbfc\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t{[\n\t\t\t\t\t\t\t\t\t{ key: \"performance\", label: \"Performance Comparison\" },\n\t\t\t\t\t\t\t\t\t{ key: \"scatter\", label: \"Precision-Recall Plot\" },\n\t\t\t\t\t\t\t\t\t{ key: \"heatmap\", label: \"Confusion Matrix\" },\n\t\t\t\t\t\t\t\t\t{ key: \"overview\", label: \"Statistical Overview\" }\n\t\t\t\t\t\t\t\t].map((tab) => (\n\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\tkey={tab.key}\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\tif (tab.key === \"performance\" || tab.key === \"scatter\" || tab.key === \"heatmap\" || tab.key === \"overview\") {\n\t\t\t\t\t\t\t\t\t\t\t\tsetActiveVisualizationTab(tab.key)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tpadding: \"12px 20px\",\n\t\t\t\t\t\t\t\t\t\t\tborder: \"none\",\n\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: activeVisualizationTab === tab.key ? \"white\" : \"transparent\",\n\t\t\t\t\t\t\t\t\t\t\tcolor: activeVisualizationTab === tab.key ? \"#3b82f6\" : \"#6b7280\",\n\t\t\t\t\t\t\t\t\t\t\tfontWeight: activeVisualizationTab === tab.key ? \"600\" : \"400\",\n\t\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\t\t\t\t\t\tborderBottom: activeVisualizationTab === tab.key ? \"2px solid #3b82f6\" : \"none\",\n\t\t\t\t\t\t\t\t\t\t\ttransition: \"all 0.2s\"\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tonMouseEnter={(e) => {\n\t\t\t\t\t\t\t\t\t\t\tif (activeVisualizationTab !== tab.key) {\n\t\t\t\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = \"#f3f4f6\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tonMouseLeave={(e) => {\n\t\t\t\t\t\t\t\t\t\t\tif (activeVisualizationTab !== tab.key) {\n\t\t\t\t\t\t\t\t\t\t\t\te.currentTarget.style.backgroundColor = \"transparent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{tab.label}\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t{/* Visualization Content */}\n\t\t\t\t\t\t\t<div style={{ padding: \"24px\" }}>\n\t\t\t\t\t\t\t\t{activeVisualizationTab === \"performance\" && (\n\t\t\t\t\t\t\t\t\t<PerformanceComparisonChart comparisonResults={completedComparisonResults} />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{activeVisualizationTab === \"scatter\" && (\n\t\t\t\t\t\t\t\t\t<PrecisionRecallScatterPlot comparisonResults={completedComparisonResults} />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{activeVisualizationTab === \"heatmap\" && (\n\t\t\t\t\t\t\t\t\t<ConfusionMatrixHeatmap comparisonResults={completedComparisonResults} />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{activeVisualizationTab === \"overview\" && (\n\t\t\t\t\t\t\t\t\t<DatasetStatisticsOverview comparisonResults={completedComparisonResults} />\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Missing Paper Detection */}\n\t\t\t\t\t{starDatasets.length > 0 && (\n\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\tborderRadius: \"12px\",\n\t\t\t\t\t\t\tborder: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\tmarginTop: \"32px\",\n\t\t\t\t\t\t\toverflow: \"hidden\"\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\tpadding: \"20px\",\n\t\t\t\t\t\t\t\tborderBottom: \"1px solid #e5e7eb\",\n\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\"\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t<h2 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#1f2937\", marginBottom: \"8px\" }}>\n                  Missing Paper Detection\n\t\t\t\t\t\t\t\t</h2>\n\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", margin: 0 }}>\n                  Identify potentially relevant papers that systematic reviews may have missed\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div style={{ padding: \"24px\" }}>\n\t\t\t\t\t\t\t\t{/* Dataset Selection */}\n\t\t\t\t\t\t\t\t<div style={{ marginBottom: \"24px\" }}>\n\t\t\t\t\t\t\t\t\t<label\n\t\t\t\t\t\t\t\t\t\thtmlFor=\"dataset-select\"\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\t\tfontWeight: \"500\",\n\t\t\t\t\t\t\t\t\t\t\tcolor: \"#374151\",\n\t\t\t\t\t\t\t\t\t\t\tdisplay: \"block\",\n\t\t\t\t\t\t\t\t\t\t\tmarginBottom: \"8px\"\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n                    Select Dataset for Missing Paper Analysis:\n\t\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\t\tid=\"dataset-select\"\n\t\t\t\t\t\t\t\t\t\tvalue={selectedDatasetForMissingPapers || \"\"}\n\t\t\t\t\t\t\t\t\t\tonChange={(e) => { setSelectedDatasetForMissingPapers(e.target.value || null); }}\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tpadding: \"8px 12px\",\n\t\t\t\t\t\t\t\t\t\t\tborderRadius: \"6px\",\n\t\t\t\t\t\t\t\t\t\t\tborder: \"1px solid #d1d5db\",\n\t\t\t\t\t\t\t\t\t\t\tfontSize: \"14px\",\n\t\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"white\",\n\t\t\t\t\t\t\t\t\t\t\tminWidth: \"300px\"\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<option value=\"\">Choose a dataset...</option>\n\t\t\t\t\t\t\t\t\t\t{starDatasets.map((dataset) => (\n\t\t\t\t\t\t\t\t\t\t\t<option key={dataset.id} value={dataset.id}>\n\t\t\t\t\t\t\t\t\t\t\t\t{dataset.name} ({dataset.originalPaperCount ?? 'Unknown'} papers)\n\t\t\t\t\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t{/* Missing Paper Detection Component */}\n\t\t\t\t\t\t\t\t{selectedDatasetForMissingPapers && starDatasets.find(d => d.id === selectedDatasetForMissingPapers) && (\n\t\t\t\t\t\t\t\t\t<MissingPaperDetection\n\t\t\t\t\t\t\t\t\t\tdataset={(() => {\n\t\t\t\t\t\t\t\t\t\t\tconst foundDataset = starDatasets.find(d => d.id === selectedDatasetForMissingPapers)\n\t\t\t\t\t\t\t\t\t\t\tif (!foundDataset) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\"Dataset not found\")\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn foundDataset\n\t\t\t\t\t\t\t\t\t\t})()}\n\t\t\t\t\t\t\t\t\t\tonDetectionComplete={(results) => {\n\t\t\t\t\t\t\t\t\t\t\tsetMissingPaperResults(prev => ({\n\t\t\t\t\t\t\t\t\t\t\t\t...prev,\n\t\t\t\t\t\t\t\t\t\t\t\t[selectedDatasetForMissingPapers]: results\n\t\t\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t\t\t{!selectedDatasetForMissingPapers && (\n\t\t\t\t\t\t\t\t\t<div style={{\n\t\t\t\t\t\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\t\t\t\t\t\tpadding: \"48px 24px\",\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: \"#f9fafb\",\n\t\t\t\t\t\t\t\t\t\tborderRadius: \"8px\"\n\t\t\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t\t\t\t<div style={{ marginBottom: \"16px\", opacity: 0.3 }}>\n\t\t\t\t\t\t\t\t\t\t\t<IconSearch size={48} />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<h3 style={{ fontSize: \"18px\", fontWeight: \"600\", color: \"#374151\", marginBottom: \"8px\" }}>\n                      Select a Dataset\n\t\t\t\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#6b7280\", margin: 0 }}>\n                      Choose a STAR dataset above to begin missing paper detection analysis\n\t\t\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{/* Thesis Integration Notes */}\n\t\t\t\t\t<div style={{\n\t\t\t\t\t\tbackgroundColor: \"#fef3c7\",\n\t\t\t\t\t\tborderRadius: \"8px\",\n\t\t\t\t\t\tborder: \"1px solid #fbbf24\",\n\t\t\t\t\t\tpadding: \"16px\",\n\t\t\t\t\t\tmarginTop: \"24px\"\n\t\t\t\t\t}}>\n\t\t\t\t\t\t<h3 style={{ fontSize: \"16px\", fontWeight: \"600\", color: \"#92400e\", marginBottom: \"8px\" }}>\n\t\t\t\t\t\t\t<span style={{ display: \"flex\", alignItems: \"center\", gap: \"4px\" }}>\n\t\t\t\t\t\t\t\t<IconBulb size={16} />\n                Thesis Integration Notes\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p style={{ fontSize: \"14px\", color: \"#78350f\", lineHeight: \"1.5\", margin: 0 }}>\n              These results demonstrate Academic Explorer's quantitative performance improvements over traditional\n              systematic review methodologies. The precision/recall metrics and additional papers discovered provide\n              statistical evidence for Chapter 6 evaluation. Export individual results for detailed statistical analysis\n              and inclusion in thesis appendices.\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t</>\n\t\t\t)}\n\t\t</div>\n\t)\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/explore.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/explore/graph.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/graph.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/https/$.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":71,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":71,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2081,2083],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createFileRoute, useNavigate } from \"@tanstack/react-router\"\nimport { useEffect, useMemo } from \"react\"\nimport { IconSearch } from \"@tabler/icons-react\"\nimport { EntityDetector } from \"@academic-explorer/graph\";\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\n\nexport const Route = createFileRoute(\"/https/$\")({\n\tcomponent: HttpsRoute,\n})\n\nfunction HttpsRoute() {\n\tconst { _splat } = Route.useParams()\n\tconst navigate = useNavigate()\n\tconst detector = useMemo(() => new EntityDetector(), [])\n\n\tuseEffect(() => {\n\t\tconst resolveHttpsUrl = () => {\n\t\t\ttry {\n\t\t\t\t// Check if splat parameter exists\n\t\t\t\tif (!_splat) {\n\t\t\t\t\tthrow new Error(\"No URL path provided\")\n\t\t\t\t}\n\n\t\t\t\t// Reconstruct the full URL from the splat parameter\n\t\t\t\tconst fullUrl = `https://${_splat}`\n\n\t\t\t\t// Detect entity type and ID from the URL\n\t\t\t\tconst detection = detector.detectEntityIdentifier(fullUrl)\n\n\t\t\t\tif (detection.entityType && detection.idType === \"openalex\") {\n\t\t\t\t\t// This is an OpenAlex URL, redirect to direct entity route\n\t\t\t\t\tconst entityRoute = `/${detection.entityType}/${detection.normalizedId}`\n\n\t\t\t\t\tvoid navigate({\n\t\t\t\t\t\tto: entityRoute,\n\t\t\t\t\t\treplace: true,\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\t// Fallback to external ID route for further processing\n\t\t\t\t\tvoid navigate({\n\t\t\t\t\t\tto: `/${encodeURIComponent(fullUrl)}`,\n\t\t\t\t\t\treplace: true,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogError(logger, \"Failed to resolve HTTPS URL:\", error, \"HttpsRoute\", \"routing\")\n\n\t\t\t\t// Fallback to search\n\t\t\t\tvoid navigate({\n\t\t\t\t\tto: \"/search\",\n\t\t\t\t\tsearch: { q: _splat },\n\t\t\t\t\treplace: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tresolveHttpsUrl()\n\t}, [_splat, navigate, detector])\n\n\treturn (\n\t\t<div style={{\n\t\t\tpadding: \"40px 20px\",\n\t\t\ttextAlign: \"center\",\n\t\t\tfontSize: \"16px\"\n\t\t}}>\n\t\t\t<div style={{ marginBottom: \"20px\", fontSize: \"18px\" }}>\n\t\t\t\t<IconSearch size={18} style={{ display: \"inline\", marginRight: \"8px\" }} />\n\t\t\t\tResolving HTTPS URL...\n\t\t\t</div>\n\t\t\t<div style={{ fontFamily: \"monospace\", backgroundColor: \"#f5f5f5\", padding: \"10px\", borderRadius: \"4px\" }}>\n\t\t\t\thttps://{decodeURIComponent(_splat || \"\")}\n\t\t\t</div>\n\t\t\t<div style={{ marginTop: \"20px\", fontSize: \"14px\", color: \"#666\" }}>\n\t\t\t\tDetecting entity type and redirecting\n\t\t\t</div>\n\t\t</div>\n\t)\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/institutions/$institutionId.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/institutions/ror.$ror.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/search.tsx","messages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":178,"column":60,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[4798,4812],"text":" results for &quot;"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[4798,4812],"text":" results for &ldquo;"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[4798,4812],"text":" results for &#34;"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[4798,4812],"text":" results for &rdquo;"},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":178,"column":82,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[4833,4844],"text":"&quot;\n\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[4833,4844],"text":"&ldquo;\n\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[4833,4844],"text":"&#34;\n\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[4833,4844],"text":"&rdquo;\n\t\t\t\t\t\t\t\t\t"},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":204,"column":47,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[5579,5627],"text":"\n                  No academic works found for &quot;"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[5579,5627],"text":"\n                  No academic works found for &ldquo;"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[5579,5627],"text":"\n                  No academic works found for &#34;"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[5579,5627],"text":"\n                  No academic works found for &rdquo;"},"desc":"Replace with `&rdquo;`."}]},{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.","line":204,"column":69,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&quot;"},"fix":{"range":[5648,5710],"text":"&quot;. Try different search terms or adjust your filters.\n\t\t\t\t\t\t\t\t"},"desc":"Replace with `&quot;`."},{"messageId":"replaceWithAlt","data":{"alt":"&ldquo;"},"fix":{"range":[5648,5710],"text":"&ldquo;. Try different search terms or adjust your filters.\n\t\t\t\t\t\t\t\t"},"desc":"Replace with `&ldquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#34;"},"fix":{"range":[5648,5710],"text":"&#34;. Try different search terms or adjust your filters.\n\t\t\t\t\t\t\t\t"},"desc":"Replace with `&#34;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rdquo;"},"fix":{"range":[5648,5710],"text":"&rdquo;. Try different search terms or adjust your filters.\n\t\t\t\t\t\t\t\t"},"desc":"Replace with `&rdquo;`."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createFileRoute } from \"@tanstack/react-router\"\nimport { useState } from \"react\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport { Title, Text, Stack, Alert, Container, Card } from \"@mantine/core\"\nimport { IconInfoCircle } from \"@tabler/icons-react\"\nimport { SearchInterface } from \"../components/search/SearchInterface\"\nimport { BaseTable } from \"../components/tables/BaseTable\"\nimport { formatPublicationYear, formatLargeNumber } from \"@academic-explorer/utils\"\nimport { pageTitle, pageDescription } from \"../styles/layout.css\"\nimport type { ColumnDef } from \"@tanstack/react-table\"\nimport { logger } from \"@academic-explorer/utils\";\n\ninterface SearchFilters {\n  query: string;\n  startDate: Date | null;\n  endDate: Date | null;\n}\n\n// Mock academic work data for demonstration\ninterface MockWork {\n  id: string;\n  title: string;\n  display_name: string;\n  authors: string[];\n  publication_year: number;\n  cited_by_count: number;\n  journal: string;\n  is_open_access: boolean;\n}\n\n// Mock data generator\nconst generateMockData = (query: string): MockWork[] => {\n\tif (!query.trim()) return [];\n\n\treturn [\n\t\t{\n\t\t\tid: \"1\",\n\t\t\ttitle: `Advanced Research on ${query}: A Computational Approach`,\n\t\t\tdisplay_name: `Advanced Research on ${query}: A Computational Approach`,\n\t\t\tauthors: [\"Dr. Sarah Johnson\", \"Prof. Michael Chen\"],\n\t\t\tpublication_year: 2023,\n\t\t\tcited_by_count: 47,\n\t\t\tjournal: \"Journal of Advanced Computing\",\n\t\t\tis_open_access: true,\n\t\t},\n\t\t{\n\t\t\tid: \"2\",\n\t\t\ttitle: `Machine Learning Applications in ${query} Studies`,\n\t\t\tdisplay_name: `Machine Learning Applications in ${query} Studies`,\n\t\t\tauthors: [\"Dr. Emily Rodriguez\", \"Prof. David Kim\", \"Dr. Lisa Wang\"],\n\t\t\tpublication_year: 2022,\n\t\t\tcited_by_count: 89,\n\t\t\tjournal: \"Nature Machine Intelligence\",\n\t\t\tis_open_access: false,\n\t\t},\n\t\t{\n\t\t\tid: \"3\",\n\t\t\ttitle: `The Future of ${query}: Trends and Predictions`,\n\t\t\tdisplay_name: `The Future of ${query}: Trends and Predictions`,\n\t\t\tauthors: [\"Prof. Robert Taylor\"],\n\t\t\tpublication_year: 2024,\n\t\t\tcited_by_count: 23,\n\t\t\tjournal: \"Science Advances\",\n\t\t\tis_open_access: true,\n\t\t},\n\t];\n};\n\nfunction SearchPage() {\n\tconst [searchFilters, setSearchFilters] = useState<SearchFilters>({\n\t\tquery: \"\",\n\t\tstartDate: null,\n\t\tendDate: null,\n\t});\n\n\tconst { data: searchResults, isLoading } = useQuery({\n\t\tqueryKey: [\"search\", searchFilters],\n\t\tqueryFn: () => {\n\t\t\t// Simulate API delay\n\t\t\treturn new Promise<MockWork[]>((resolve) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tresolve(generateMockData(searchFilters.query));\n\t\t\t\t}, 800);\n\t\t\t});\n\t\t},\n\t\tenabled: Boolean(searchFilters.query.trim()),\n\t});\n\n\tconst columns: ColumnDef<MockWork>[] = [\n\t\t{\n\t\t\taccessorKey: \"title\",\n\t\t\theader: \"Title\",\n\t\t\tcell: ({ row }) => (\n\t\t\t\t<div>\n\t\t\t\t\t<Text fw={500} size=\"sm\" lineClamp={2}>\n\t\t\t\t\t\t{row.original.title}\n\t\t\t\t\t</Text>\n\t\t\t\t\t<Text size=\"xs\" c=\"dimmed\">\n\t\t\t\t\t\t{row.original.authors.join(\", \")}\n\t\t\t\t\t</Text>\n\t\t\t\t</div>\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\taccessorKey: \"journal\",\n\t\t\theader: \"Journal\",\n\t\t\tcell: ({ row }) => (\n\t\t\t\t<Text size=\"sm\">{row.original.journal}</Text>\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\taccessorKey: \"publication_year\",\n\t\t\theader: \"Year\",\n\t\t\tcell: ({ row }) => (\n\t\t\t\t<Text size=\"sm\">{formatPublicationYear(row.original.publication_year)}</Text>\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\taccessorKey: \"cited_by_count\",\n\t\t\theader: \"Citations\",\n\t\t\tcell: ({ row }) => (\n\t\t\t\t<Text size=\"sm\" fw={500}>\n\t\t\t\t\t{formatLargeNumber(row.original.cited_by_count)}\n\t\t\t\t</Text>\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\taccessorKey: \"is_open_access\",\n\t\t\theader: \"Access\",\n\t\t\tcell: ({ row }) => (\n\t\t\t\t<Text\n\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\tc={row.original.is_open_access ? \"green\" : \"gray\"}\n\t\t\t\t\tfw={row.original.is_open_access ? 500 : 400}\n\t\t\t\t>\n\t\t\t\t\t{row.original.is_open_access ? \"Open Access\" : \"Closed\"}\n\t\t\t\t</Text>\n\t\t\t),\n\t\t},\n\t];\n\n\tconst handleSearch = (filters: SearchFilters) => {\n\t\tsetSearchFilters(filters);\n\t};\n\n\tconst hasResults = searchResults && searchResults.length > 0;\n\tconst hasQuery = Boolean(searchFilters.query.trim());\n\n\treturn (\n\t\t<Container size=\"xl\">\n\t\t\t<Stack gap=\"xl\">\n\t\t\t\t<div>\n\t\t\t\t\t<Title order={1} className={pageTitle}>\n            Academic Search Demo\n\t\t\t\t\t</Title>\n\t\t\t\t\t<Text className={pageDescription}>\n            Explore Phase 1 functionality: TanStack React Table, Mantine Dates, enhanced search utilities,\n            and debounced search with date filtering.\n\t\t\t\t\t</Text>\n\t\t\t\t</div>\n\n\t\t\t\t<SearchInterface\n\t\t\t\t\tonSearch={handleSearch}\n\t\t\t\t\tisLoading={isLoading}\n\t\t\t\t\tplaceholder=\"Try searching for 'machine learning', 'climate change', or 'artificial intelligence'\"\n\t\t\t\t\tshowDateFilter={true}\n\t\t\t\t/>\n\n\t\t\t\t{hasQuery && (\n\t\t\t\t\t<Card withBorder>\n\t\t\t\t\t\t{isLoading ? (\n\t\t\t\t\t\t\t<Text ta=\"center\" py=\"xl\">\n                Searching...\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t) : hasResults ? (\n\t\t\t\t\t\t\t<Stack>\n\t\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\">\n                  Found {searchResults.length} results for \"{searchFilters.query}\"\n\t\t\t\t\t\t\t\t\t{searchFilters.startDate || searchFilters.endDate ? (\n\t\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t\t{\" \"}with date filters applied\n\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t) : null}\n\t\t\t\t\t\t\t\t</Text>\n\n\t\t\t\t\t\t\t\t<BaseTable\n\t\t\t\t\t\t\t\t\tdata={searchResults}\n\t\t\t\t\t\t\t\t\tcolumns={columns}\n\t\t\t\t\t\t\t\t\tsearchable={false} // Search is handled by the SearchInterface\n\t\t\t\t\t\t\t\t\tonRowClick={(work) => {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"ui\", \"Work clicked in search results\", { workId: work.id, workTitle: work.display_name }, \"SearchPage\");\n\t\t\t\t\t\t\t\t\t\t// Could navigate to work detail page\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<Alert\n\t\t\t\t\t\t\t\ticon={<IconInfoCircle />}\n\t\t\t\t\t\t\t\ttitle=\"No results found\"\n\t\t\t\t\t\t\t\tcolor=\"blue\"\n\t\t\t\t\t\t\t\tvariant=\"light\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<Text size=\"sm\">\n                  No academic works found for \"{searchFilters.query}\". Try different search terms or adjust your filters.\n\t\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t</Alert>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</Card>\n\t\t\t\t)}\n\n\t\t\t\t{!hasQuery && (\n\t\t\t\t\t<Card withBorder>\n\t\t\t\t\t\t<Stack align=\"center\" py=\"xl\">\n\t\t\t\t\t\t\t<Text size=\"lg\" fw={500}>\n                Enter a search term to explore academic literature\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t\t<Text size=\"sm\" c=\"dimmed\" ta=\"center\">\n                This demo showcases the Phase 1 enhancements including debounced search,\n                date filtering, sortable tables, and enhanced data utilities.\n\t\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t</Stack>\n\t\t\t\t\t</Card>\n\t\t\t\t)}\n\t\t\t</Stack>\n\t\t</Container>\n\t);\n}\n\nexport const Route = createFileRoute(\"/search\")({\n\tcomponent: SearchPage,\n})","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/sources/$sourceId.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/sources/issn.$issn.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/topics/$topicId.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/works/$workId.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/routes/works/doi.$doi.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/services/expansion-query-builder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/services/graph-data-service.ts","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'queryClient' is defined but never used. Allowed unused args must match /^_/u.","line":28,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":47},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'queryClient' is defined but never used. Allowed unused args must match /^_/u.","line":31,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":41},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'nodes' is defined but never used. Allowed unused args must match /^_/u.","line":31,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":61},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'queryClient' is defined but never used. Allowed unused args must match /^_/u.","line":34,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":41},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'edges' is defined but never used. Allowed unused args must match /^_/u.","line":34,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":61},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'queryClient' is defined but never used. Allowed unused args must match /^_/u.","line":37,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":37},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'nodeId' is defined but never used. Allowed unused args must match /^_/u.","line":37,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":58},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'expanded' is defined but never used. Allowed unused args must match /^_/u.","line":37,"column":68,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":76},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'queryClient' is defined but never used. Allowed unused args must match /^_/u.","line":40,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":36},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'nodeId' is defined but never used. Allowed unused args must match /^_/u.","line":40,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":57},{"ruleId":"@typescript-eslint/no-extraneous-class","severity":2,"message":"Unexpected class with only static properties.","line":45,"column":7,"nodeType":"Identifier","messageId":"onlyStatic","endLine":45,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2020,2023],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2020,2023],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":52,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":52,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .client on an `any` value.","line":52,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":52,"endColumn":31},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'expand' has no 'await' expression.","line":54,"column":4,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":54,"endColumn":18,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2184,2338],"text":"(context: { entityId: string; entityType: EntityType; client: any }, options: ExpansionOptions): { nodes: GraphNode[]; edges: GraphEdge[] }"},"desc":"Remove 'async'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":54,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2252,2255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2252,2255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":54,"column":87,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":94},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":169,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":169,"endColumn":22},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":171,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":171,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[6008,6010],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":226,"column":11,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":226,"endColumn":24},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":229,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":229,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8173,8175],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":283,"column":11,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":283,"endColumn":24},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":286,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":286,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[10097,10099],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":318,"column":8,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":318,"endColumn":13},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":323,"column":11,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":323,"endColumn":24},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":325,"column":41,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":325,"endColumn":43,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[11641,11643],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":405,"column":8,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":405,"endColumn":23},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":656,"column":7,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":656,"endColumn":20},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":727,"column":7,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":727,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":770,"column":4,"nodeType":"MemberExpression","messageId":"unexpected","endLine":770,"endColumn":15,"suggestions":[{"fix":{"range":[27105,27172],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":797,"column":10,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":797,"endColumn":23},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":800,"column":40,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":800,"endColumn":42,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[28921,28923],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":933,"column":39,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":933,"endColumn":41,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[34271,34273],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":942,"column":10,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":942,"endColumn":23},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":946,"column":44,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":946,"endColumn":46,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[34785,34787],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":960,"column":41,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":960,"endColumn":54},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":970,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":970,"endColumn":18,"suggestions":[{"fix":{"range":[36078,36128],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":984,"column":139,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":984,"endColumn":141,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[37137,37139],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":984,"column":158,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":984,"endColumn":190},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":986,"column":11,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":986,"endColumn":29},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1026,"column":6,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1026,"endColumn":17,"suggestions":[{"fix":{"range":[38759,38827],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1032,"column":6,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1032,"endColumn":17,"suggestions":[{"fix":{"range":[38944,39067],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1035,"column":6,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1035,"endColumn":17,"suggestions":[{"fix":{"range":[39173,39238],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1049,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1049,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[39563,39565],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":1050,"column":24,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":1050,"endColumn":43},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1200,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1200,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[44970,44972],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1363,"column":69,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1363,"endColumn":71,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[50571,50573],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1518,"column":31,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1518,"endColumn":33,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[55884,55886],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":1599,"column":19,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1599,"endColumn":21,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[58390,58392],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":1634,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1634,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[59751,59753],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":1663,"column":22,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":1663,"endColumn":24,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[60737,60739],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":1763,"column":7,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":1763,"endColumn":14},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":1824,"column":37,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":1824,"endColumn":52}],"suppressedMessages":[],"errorCount":33,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Graph data service for integrating OpenAlex API with graph visualization\n * Handles data transformation, caching, and progressive loading\n * Now integrated with TanStack Query for persistent caching\n */\n\nimport { QueryClient } from \"@tanstack/react-query\";\nimport { cachedOpenAlex } from \"@academic-explorer/client\";\nimport { EntityDetector } from \"@academic-explorer/graph\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { useRepositoryStore } from \"@/stores/repository-store\";\nimport { useExpansionSettingsStore } from \"@/stores/expansion-settings-store\";\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\nimport { RequestDeduplicationService, createRequestDeduplicationService } from \"./request-deduplication-service\";\nimport { RelationshipDetectionService, createRelationshipDetectionService } from \"./relationship-detection-service\";\nimport { isWork, isAuthor, isSource, isInstitution } from \"@academic-explorer/client\";\n\ninterface ExpansionOptions {\n  depth?: number;\n  limit?: number;\n  force?: boolean;\n}\n\nfunction isEntityType(type: string): type is EntityType {\n  return [\"works\", \"authors\", \"sources\", \"institutions\"].includes(type as EntityType);\n}\n// Cache functions - implement as stubs for now\nfunction getCachedOpenAlexEntities(queryClient: QueryClient): OpenAlexEntity[] {\n\treturn [];\n}\nfunction setCachedGraphNodes(queryClient: QueryClient, nodes: GraphNode[]): void {\n\t// Stub implementation\n}\nfunction setCachedGraphEdges(queryClient: QueryClient, edges: GraphEdge[]): void {\n\t// Stub implementation\n}\nfunction setNodeExpanded(queryClient: QueryClient, nodeId: string, expanded: boolean): void {\n\t// Stub implementation\n}\nfunction isNodeExpanded(queryClient: QueryClient, nodeId: string): boolean {\n\treturn false;\n}\n\n// EntityFactory stub implementation\nclass EntityFactory {\n\tstatic isSupported(entityType: EntityType): boolean {\n\t\treturn [\"works\", \"authors\", \"sources\", \"institutions\"].includes(entityType);\n\t}\n\tstatic create(entityType: EntityType, client: any) {\n\t\treturn {\n\t\t\tfetchWithMetadata: async (entityId: string): Promise<OpenAlexEntity> => {\n\t\t\t\treturn await client.client.getEntity(entityId);\n\t\t\t},\n\t\t\texpand: async (context: { entityId: string; entityType: EntityType; client: any }, options: ExpansionOptions): Promise<{ nodes: GraphNode[]; edges: GraphEdge[] }> => {\n\t\t\t\treturn { nodes: [], edges: [] };\n\t\t\t}\n\t\t};\n\t}\n}\nimport type {\n\tGraphNode,\n\tGraphEdge,\n\tEntityType,\n\tExternalIdentifier,\n\tSearchOptions,\n\tGraphCache,\n} from \"@academic-explorer/graph\";\nimport { RelationType } from \"@academic-explorer/graph\";\nimport type {\n\tWork,\n\tAuthor,\n\tSource,\n\tInstitutionEntity,\n\tOpenAlexEntity,\n} from \"@academic-explorer/client\";\n\nexport class GraphDataService {\n\tprivate detector: EntityDetector;\n\tprivate cache: GraphCache;\n\tprivate queryClient: QueryClient;\n\tprivate deduplicationService: RequestDeduplicationService;\n\tprivate relationshipDetectionService: RelationshipDetectionService;\n\n\tconstructor(queryClient: QueryClient) {\n\t\tlogger.debug(\"graph\", \"GraphDataService constructor called\", {}, \"GraphDataService\");\n\t\tthis.detector = new EntityDetector();\n\t\tthis.queryClient = queryClient;\n\t\tthis.deduplicationService = createRequestDeduplicationService(queryClient);\n\t\tthis.relationshipDetectionService = createRelationshipDetectionService(queryClient);\n\t\tthis.cache = {\n\t\t\tnodes: new Map(),\n\t\t\tedges: new Map(),\n\t\t\texpandedNodes: new Set(),\n\t\t\tfetchedRelationships: new Map(),\n\t\t};\n\t}\n\n\t/**\n   * Load initial graph for an entity with related entities\n   */\n\tasync loadEntityGraph(entityId: string): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\t\tstore.setLoading(true);\n\t\tstore.setError(null);\n\n\t\ttry {\n\t\t\t// Detect entity type\n\t\t\tconst detection = this.detector.detectEntityIdentifier(entityId);\n\n\t\t\tif (!detection.entityType) {\n\t\t\t\tthrow new Error(`Unable to detect entity type for: ${entityId}`);\n\t\t\t}\n\n\t\t\t// Fetch entity with deduplication service and cache-first strategy\n\t\t\t// For OpenAlex IDs, construct the full URL\n\t\t\tconst apiEntityId = detection.idType === \"openalex\"\n\t\t\t\t? `https://openalex.org/${detection.normalizedId}`\n\t\t\t\t: detection.normalizedId;\n\n\t\t\tconst entity = await this.deduplicationService.getEntity(\n\t\t\t\tapiEntityId,\n\t\t\t\t() => cachedOpenAlex.client.getEntity(apiEntityId)\n\t\t\t);\n\n\t\t\t// Entity successfully fetched\n\n\t\t\t// Transform to graph data with incremental hydration\n\t\t\tconst { nodes, edges } = this.transformEntityToGraph(entity);\n\n\t\t\t// Clear existing graph and expansion cache\n\t\t\tstore.clear();\n\t\t\tthis.cache.expandedNodes = new Set();\n\t\t\tthis.cache.fetchedRelationships = new Map();\n\n\t\t\t// Add new data to store\n\t\t\tstore.addNodes(nodes);\n\t\t\tstore.addEdges(edges);\n\n\t\t\t// Cache the graph data in TanStack Query for persistence\n\t\t\tsetCachedGraphNodes(this.queryClient, nodes);\n\t\t\tsetCachedGraphEdges(this.queryClient, edges);\n\n\t\t\t// Get the primary node ID and calculate depths\n\t\t\tconst primaryNodeId = nodes[0]?.id;\n\t\t\tif (primaryNodeId) {\n\t\t\t\t// Calculate node depths from the primary node\n\t\t\t\tstore.calculateNodeDepths(primaryNodeId);\n\n\t\t\t\t// Pin the primary node as the origin for traversal depth calculation\n\t\t\t\tstore.pinNode(primaryNodeId);\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", \"Entity graph loaded with incremental hydration\", {\n\t\t\t\tnodeCount: nodes.length,\n\t\t\t\tedgeCount: edges.length,\n\t\t\t\tprimaryNodeId,\n\t\t\t\t// No artificial hydration level tracking\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Detect relationships between all initial nodes using batch processing\n\t\t\tlogger.debug(\"graph\", \"Starting relationship detection for initial graph nodes\", {\n\t\t\t\tnodeCount: nodes.length\n\t\t\t}, \"GraphDataService\");\n\n\t\t\tconst nodeIds = nodes.map(node => node.id);\n\t\t\ttry {\n\t\t\t\tconst detectedEdges = await this.relationshipDetectionService.detectRelationshipsForNodes(nodeIds);\n\t\t\t\t// Add detected relationship edges to the graph\n\t\t\t\tif (detectedEdges && detectedEdges.length > 0) {\n\t\t\t\t\tlogger.debug(\"graph\", \"Adding detected relationship edges to initial graph\", {\n\t\t\t\t\t\tdetectedEdgeCount: detectedEdges?.length || 0\n\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\tstore.addEdges(detectedEdges);\n\n\t\t\t\t\t// Update cached edges\n\t\t\t\t\tconst allEdges = Object.values(store.edges).filter((edge) => edge != null);\n\t\t\t\t\tsetCachedGraphEdges(this.queryClient, allEdges);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogError(logger, \"Failed to detect relationships for initial nodes\", error, \"GraphDataService\", \"graph\");\n\t\t\t}\n\n\t\t\t// Layout is now handled by the ReactFlow component's useLayout hook\n\t\t\t// No need for explicit layout application here\n\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tstore.setError(errorMessage);\n\t\t\tlogError(logger, \"Failed to load entity graph\", error, \"GraphDataService\", \"graph\");\n\t\t} finally {\n\t\t\tstore.setLoading(false);\n\t\t}\n\t}\n\n\t/**\n    * Load an entity and add it to the existing graph (without clearing)\n    * Used for progressive graph building when clicking on nodes\n    */\n\tasync loadEntityIntoGraph(entityId: string): Promise<void> {\n\t\tlogger.debug(\"graph\", \"loadEntityIntoGraph called\", { entityId, type: typeof entityId }, \"GraphDataService\");\n\n\t\tconst store = useGraphStore.getState();\n\n\t\ttry {\n\t\t\t// Check if the node already exists (regardless of hydration level)\n\t\t\tconst existingNode = Object.values(store.nodes).filter((node): node is NonNullable<typeof node> => node != null).find(\n\t\t\t\tnode => node.entityId === entityId\n\t\t\t);\n\n\t\t\tif (existingNode) {\n\t\t\t\t// Node already exists, select it and optionally hydrate if needed\n\t\t\t\tstore.selectNode(existingNode.id);\n\n\t\t\t\t// Node will be hydrated on-demand when specific fields are needed\n\n\t\t\t\tlogger.debug(\"graph\", \"Existing node selected\", {\n\t\t\t\t\tnodeId: existingNode.id,\n\t\t\t\t\tentityId\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t// Detect relationships for the existing node\n\t\t\t\tthis.relationshipDetectionService.detectRelationshipsForNode(existingNode.id)\n\t\t\t\t\t.then((detectedEdges) => {\n\t\t\t\t\t\t// Add detected relationship edges to the graph\n\t\t\t\t\t\tif (detectedEdges && detectedEdges.length > 0) {\n\t\t\t\t\t\t\tlogger.debug(\"graph\", \"Adding detected relationship edges for existing node\", {\n\t\t\t\t\t\t\t\tnodeId: existingNode.id,\n\t\t\t\t\t\t\t\tdetectedEdgeCount: detectedEdges?.length || 0\n\t\t\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t\t\tconst currentStore = useGraphStore.getState();\n\t\t\t\t\t\t\tcurrentStore.addEdges(detectedEdges);\n\n\t\t\t\t\t\t\t// Update cached edges\n\t\t\t\t\t\t\tconst allEdges = Object.values(currentStore.edges).filter((edge) => edge != null);\n\t\t\t\t\t\t\tsetCachedGraphEdges(this.queryClient, allEdges);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error: unknown) => {\n\t\t\t\t\t\tlogError(logger, \"Failed to detect relationships for existing node\", error, \"GraphDataService\", \"graph\");\n\t\t\t\t\t});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Detect entity type\n\t\t\tconst detection = this.detector.detectEntityIdentifier(entityId);\n\n\t\t\tif (!detection.entityType) {\n\t\t\t\tthrow new Error(`Unable to detect entity type for: ${entityId}`);\n\t\t\t}\n\n\t\t\t// Fetch entity with deduplication service and cache-first strategy\n\t\t\t// For OpenAlex IDs, construct the full URL\n\t\t\tconst apiEntityId = detection.idType === \"openalex\"\n\t\t\t\t? `https://openalex.org/${detection.normalizedId}`\n\t\t\t\t: detection.normalizedId;\n\n\t\t\tconst entity = await this.deduplicationService.getEntity(\n\t\t\t\tapiEntityId,\n\t\t\t\t() => cachedOpenAlex.client.getEntity(apiEntityId)\n\t\t\t);\n\n\t\t\t// Entity successfully fetched\n\n\t\t\t// Transform to graph data\n\t\t\tconst { nodes, edges } = this.transformEntityToGraph(entity);\n\n\t\t\t// Add new data to existing graph (do NOT clear)\n\t\t\tstore.addNodes(nodes);\n\t\t\tstore.addEdges(edges);\n\n\t\t\t// Select the newly added primary node\n\t\t\tconst primaryNodeId = nodes[0]?.id;\n\t\t\tif (primaryNodeId) {\n\t\t\t\tstore.selectNode(primaryNodeId);\n\n\t\t\t\t// Detect relationships for newly added node\n\t\t\t\tthis.relationshipDetectionService.detectRelationshipsForNode(primaryNodeId)\n\t\t\t\t\t.then((detectedEdges) => {\n\t\t\t\t\t\t// Add detected relationship edges to the graph\n\t\t\t\t\t\tif (detectedEdges && detectedEdges.length > 0) {\n\t\t\t\t\t\t\tlogger.debug(\"graph\", \"Adding detected relationship edges for newly added node\", {\n\t\t\t\t\t\t\t\tnodeId: primaryNodeId,\n\t\t\t\t\t\t\t\tdetectedEdgeCount: detectedEdges?.length || 0\n\t\t\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t\t\tconst currentStore = useGraphStore.getState();\n\t\t\t\t\t\t\tcurrentStore.addEdges(detectedEdges);\n\n\t\t\t\t\t\t\t// Update cached edges\n\t\t\t\t\t\t\tconst allEdges = Object.values(currentStore.edges).filter((edge) => edge != null);\n\t\t\t\t\t\t\tsetCachedGraphEdges(this.queryClient, allEdges);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error: unknown) => {\n\t\t\t\t\t\tlogError(logger, \"Failed to detect relationships for newly added node\", error, \"GraphDataService\", \"graph\");\n\t\t\t\t\t});\n\n\t\t\t\t// Note: No automatic expansion - user must manually expand nodes\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", \"Entity loaded into graph\", {\n\t\t\t\tentityId,\n\t\t\t\tentityType: detection.entityType,\n\t\t\t\tnodeCount: nodes.length,\n\t\t\t\tedgeCount: edges.length,\n\t\t\t\t// No artificial hydration level tracking\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// No automatic hydration - data will be fetched on-demand when needed\n\t\t\tlogger.debug(\"graph\", \"Nodes loaded without automatic hydration - will hydrate fields on-demand\", {\n\t\t\t\tcount: nodes.length\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Detect relationships between all initial nodes using batch processing\n\t\t\tif (nodes && nodes.length > 1) {\n\t\t\t\tconst nodeIds = nodes.map(n => n.id);\n\t\t\t\tthis.relationshipDetectionService.detectRelationshipsForNodes(nodeIds)\n\t\t\t\t\t.then((detectedEdges) => {\n\t\t\t\t\t\t// Add detected relationship edges to the graph\n\t\t\t\t\t\tif (detectedEdges && detectedEdges.length > 0) {\n\t\t\t\t\t\t\tlogger.debug(\"graph\", \"Adding detected relationship edges for initial graph nodes\", {\n\t\t\t\t\t\t\t\tdetectedEdgeCount: detectedEdges?.length || 0\n\t\t\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t\t\tconst currentStore = useGraphStore.getState();\n\t\t\t\t\t\t\tcurrentStore.addEdges(detectedEdges);\n\n\t\t\t\t\t\t\t// Update cached edges\n\t\t\t\t\t\t\tconst allEdges = Object.values(currentStore.edges).filter((edge) => edge != null);\n\t\t\t\t\t\t\tsetCachedGraphEdges(this.queryClient, allEdges);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error: unknown) => {\n\t\t\t\t\t\tlogError(logger, \"Failed to detect relationships for initial graph nodes\", error, \"GraphDataService\", \"graph\");\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n\t\t\tstore.setError(errorMessage);\n\t\t\tlogError(logger, \"Failed to load entity into graph\", error, \"GraphDataService\", \"graph\");\n\t\t}\n\t}\n\n\t/**\n\t * Load an entity and add it to the repository (without adding to main graph)\n\t * Used for repository mode when building a collection before adding to graph\n\t */\n\tasync loadEntityIntoRepository(entityId: string): Promise<void> {\n\t\tconst repositoryStore = useRepositoryStore.getState();\n\n\t\ttry {\n\t\t\t// Detect entity type\n\t\t\tconst detection = this.detector.detectEntityIdentifier(entityId);\n\n\t\t\tif (!detection.entityType) {\n\t\t\t\tthrow new Error(`Unable to detect entity type for: ${entityId}`);\n\t\t\t}\n\n\t\t\t// For OpenAlex IDs, construct the full URL\n\t\t\tconst apiEntityId = detection.idType === \"openalex\"\n\t\t\t\t? `https://openalex.org/${detection.normalizedId}`\n\t\t\t\t: detection.normalizedId;\n\n\t\t\tconst entity = await this.deduplicationService.getEntity(\n\t\t\t\tapiEntityId,\n\t\t\t\t() => cachedOpenAlex.client.getEntity(apiEntityId)\n\t\t\t);\n\n\t\t\t// Entity successfully fetched\n\n\t\t\t// Transform to graph data\n\t\t\tconst { nodes, edges } = this.transformEntityToGraph(entity);\n\n\t\t\t// Add to repository instead of main graph\n\t\t\trepositoryStore.addToRepository(nodes, edges);\n\n\t\t\tlogger.debug(\"repository\", \"Entity loaded into repository\", {\n\t\t\t\tentityId,\n\t\t\t\tentityType: detection.entityType,\n\t\t\t\tnodeCount: nodes.length,\n\t\t\t\tedgeCount: edges.length,\n\t\t\t}, \"GraphDataService\");\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to load entity into repository\", error, \"GraphDataService\", \"repository\");\n\t\t\tthrow error; // Re-throw to let the hook handle the error\n\t\t}\n\t}\n\n\t/**\n\t * Load all cached OpenAlex entities into the graph\n\t * Shows all available cached data up to the specified traversal depth\n\t */\n\tloadAllCachedNodes(): void {\n\t\tconst store = useGraphStore.getState();\n\n\t\ttry {\n\t\t\t// Get all cached OpenAlex entities from TanStack Query\n\t\t\tconst cachedEntities = getCachedOpenAlexEntities(this.queryClient);\n\n\t\t\tif (!cachedEntities || cachedEntities.length === 0) {\n\t\t\t\tlogger.debug(\"graph\", \"No cached entities found to load\", {}, \"GraphDataService\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", \"Loading all cached entities into graph\", {\n\t\t\t\tcount: cachedEntities.length\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Transform all cached entities to graph nodes and edges\n\t\t\tconst allNodes: GraphNode[] = [];\n\t\t\tconst allEdges: GraphEdge[] = [];\n\n\t\t\tfor (const entity of cachedEntities) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { nodes, edges } = this.transformEntityToGraph(entity);\n\t\t\t\t\tallNodes.push(...nodes);\n\t\t\t\t\tallEdges.push(...edges);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogError(logger, \"Failed to transform cached entity to graph\", error, \"GraphDataService\", \"graph\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove duplicates (entities might reference each other)\n\t\t\tconst uniqueNodes: Record<string, GraphNode> = {};\n\t\t\tallNodes.forEach(node => uniqueNodes[node.id] = node);\n\n\t\t\tconst uniqueEdges: Record<string, GraphEdge> = {};\n\t\t\tallEdges.forEach(edge => uniqueEdges[edge.id] = edge);\n\n\t\t\t// Add to graph store\n\t\t\tconst finalNodes = Object.values(uniqueNodes);\n\t\t\tconst finalEdges = Object.values(uniqueEdges);\n\n\t\t\tstore.addNodes(finalNodes);\n\t\t\tstore.addEdges(finalEdges);\n\n\t\t\t// Update cached graph data\n\t\t\tsetCachedGraphNodes(this.queryClient, finalNodes);\n\t\t\tsetCachedGraphEdges(this.queryClient, finalEdges);\n\n\t\t\t// If there are pinned nodes, recalculate depths from the first one\n\t\t\tconst pinnedNodes = Object.keys(store.pinnedNodes).filter(nodeId => store.pinnedNodes[nodeId]);\n\t\t\tconst firstPinnedNodeId = pinnedNodes[0];\n\t\t\tif (firstPinnedNodeId) {\n\t\t\t\tstore.calculateNodeDepths(firstPinnedNodeId);\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", \"Loaded all cached entities into graph\", {\n\t\t\t\tnodeCount: finalNodes.length,\n\t\t\t\tedgeCount: finalEdges.length,\n\t\t\t\tpinnedNodesCount: pinnedNodes.length,\n\t\t\t\tfirstPinnedNodeId\n\t\t\t}, \"GraphDataService\");\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to load cached nodes into graph\", error, \"GraphDataService\", \"graph\");\n\t\t}\n\t}\n\n\t/**\n   * Hydrate a minimal node to full hydration level with selective API field loading\n   * This method uses selective field loading to minimize API payload while providing rich metadata\n   */\n\tasync hydrateNodeToFull(nodeId: string): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\t\tconst node = store.getNode(nodeId);\n\n\t\tif (!node) {\n\t\t\tlogger.warn(\"graph\", \"Node not found, cannot hydrate to full\", { nodeId }, \"GraphDataService\");\n\t\t\treturn;\n\t\t}\n\n\t\t// No artificial checks - just proceed with hydration\n\t\t// Data will be fetched and updated regardless of current state\n\n\t\ttry {\n\t\t\t// Mark node as loading\n\t\t\tstore.markNodeAsLoading(nodeId);\n\n\t\t\tlogger.debug(\"graph\", \"Hydrating node to full with selective field loading\", {\n\t\t\t\tnodeId,\n\t\t\t\tentityType: node.type,\n\t\t\t\tlabel: node.label\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Check if we can use selective field loading for this entity type\n\t\t\tif (EntityFactory.isSupported(node.type)) {\n\t\t\t\t// Use entity-specific selective field loading for metadata\n\t\t\t\tconst entityInstance = EntityFactory.create(node.type, cachedOpenAlex);\n\n\t\t\t\tlogger.debug(\"graph\", \"Using selective field loading for metadata fields\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tentityId: node.entityId,\n\t\t\t\t\tentityType: node.type\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\tconst entity = await this.deduplicationService.getEntity(\n\t\t\t\t\tnode.entityId,\n\t\t\t\t\t() => entityInstance.fetchWithMetadata(node.entityId)\n\t\t\t\t);\n\n\t\t\t\t// Extract metadata-level data from the entity\n\t\t\t\tconst fullNodeData = this.createNodeFromEntity(entity, node.type);\n\n\t\t\t\t// Update the node with full metadata\n\t\t\t\tstore.markNodeAsLoaded(nodeId, {\n\t\t\t\t\tlabel: fullNodeData.label,\n\t\t\t\t\texternalIds: fullNodeData.externalIds,\n\t\t\t\t\t...(fullNodeData.entityData && { entityData: fullNodeData.entityData })\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"graph\", \"Node hydrated with selective field loading\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tnewLabel: fullNodeData.label,\n\t\t\t\t\tfieldsLoaded: \"metadata\"\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t} else {\n\t\t\t\t// Fallback to full entity fetch for unsupported types\n\t\t\t\tlogger.debug(\"graph\", \"Fallback to full entity fetch\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tentityType: node.type,\n\t\t\t\t\treason: \"entity type not supported for selective loading\"\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\tconst entity = await this.deduplicationService.getEntity(\n\t\t\t\t\tnode.entityId,\n\t\t\t\t\t() => cachedOpenAlex.client.getEntity(node.entityId)\n\t\t\t\t);\n\n\t\t\t\t// Extract full data from the entity\n\t\t\t\tconst fullNodeData = this.createNodeFromEntity(entity, node.type);\n\n\t\t\t\t// Update the node with full data\n\t\t\t\tstore.markNodeAsLoaded(nodeId, {\n\t\t\t\t\tlabel: fullNodeData.label,\n\t\t\t\t\texternalIds: fullNodeData.externalIds,\n\t\t\t\t\t...(fullNodeData.entityData && { entityData: fullNodeData.entityData })\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"graph\", \"Node hydrated with full entity fetch\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tnewLabel: fullNodeData.label,\n\t\t\t\t\tfieldsLoaded: \"all\"\n\t\t\t\t}, \"GraphDataService\");\n\t\t\t}\n\n\t\t} catch (error) {\n\t\t\tstore.markNodeAsError(nodeId);\n\t\t\tlogError(logger, \"Failed to hydrate node to full\", error, \"GraphDataService\", \"graph\");\n\t\t}\n\t}\n\n\t/**\n\t * Manually trigger relationship detection for a specific node\n\t * This can be used to detect relationships for nodes that were added before this feature was available\n\t */\n\tasync detectRelationshipsForNode(nodeId: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this.relationshipDetectionService.detectRelationshipsForNode(nodeId);\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to detect relationships for node\", error, \"GraphDataService\", \"graph\");\n\t\t}\n\t}\n\n\t/**\n\t * Detect relationships for all nodes in the current graph\n\t * This can be useful to retroactively detect relationships after loading cached data\n\t */\n\tasync detectRelationshipsForAllNodes(): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\t\tconst allNodes = Object.values(store.nodes).filter((node): node is NonNullable<typeof node> => node != null);\n\n\t\tlogger.debug(\"graph\", \"Starting relationship detection for all nodes\", {\n\t\t\tnodeCount: allNodes.length\n\t\t}, \"GraphDataService\");\n\n\t\tlet processedCount = 0;\n\t\tconst batchSize = 5;\n\t\tconst delayBetweenBatches = 1000; // 1 second delay to avoid overwhelming the API\n\n\t\tfor (let i = 0; i < allNodes.length; i += batchSize) {\n\t\t\tconst batch = allNodes.slice(i, i + batchSize);\n\n\t\t\t// Process batch in parallel and collect edges\n\t\t\tconst batchPromises = batch.map(node =>\n\t\t\t\tthis.relationshipDetectionService.detectRelationshipsForNode(node.id)\n\t\t\t\t\t.then((edges) => ({ nodeId: node.id, edges, success: true }))\n\t\t\t\t\t.catch((error: unknown) => {\n\t\t\t\t\t\tlogger.warn(\"graph\", \"Failed to detect relationships for node in batch\", {\n\t\t\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t\t\t}, \"GraphDataService\");\n\t\t\t\t\t\treturn { nodeId: node.id, edges: [], success: false };\n\t\t\t\t\t})\n\t\t\t);\n\n\t\t\tconst batchResults = await Promise.allSettled(batchPromises);\n\n\t\t\t// Collect all detected edges from successful batch operations\n\t\t\tconst allDetectedEdges: GraphEdge[] = [];\n\t\t\tbatchResults.forEach(result => {\n\t\t\t\tif (result.status === \"fulfilled\" && result.value.success && result.value.edges.length > 0) {\n\t\t\t\t\tallDetectedEdges.push(...result.value.edges);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Add detected edges to graph if any were found\n\t\t\tif (allDetectedEdges.length > 0) {\n\t\t\t\tlogger.debug(\"graph\", \"Adding detected edges from batch processing\", {\n\t\t\t\t\tbatchIndex: Math.floor(i / batchSize) + 1,\n\t\t\t\t\tdetectedEdgeCount: allDetectedEdges.length\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\tconst currentStore = useGraphStore.getState();\n\t\t\t\tcurrentStore.addEdges(allDetectedEdges);\n\n\t\t\t\t// Update cached edges\n\t\t\t\tconst updatedEdges = Object.values(currentStore.edges).filter((edge) => edge != null);\n\t\t\t\tsetCachedGraphEdges(this.queryClient, updatedEdges);\n\t\t\t}\n\t\t\tprocessedCount += batch.length;\n\n\t\t\tlogger.debug(\"graph\", \"Relationship detection batch completed\", {\n\t\t\t\tbatchIndex: Math.floor(i / batchSize) + 1,\n\t\t\t\tprocessedCount,\n\t\t\t\ttotalNodes: allNodes.length,\n\t\t\t\tprogress: Math.round((processedCount / allNodes.length) * 100)\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Add delay between batches (except for the last batch)\n\t\t\tif (i + batchSize < allNodes.length) {\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, delayBetweenBatches));\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Relationship detection completed for all nodes\", {\n\t\t\ttotalProcessed: processedCount,\n\t\t\ttotalNodes: allNodes.length\n\t\t}, \"GraphDataService\");\n\t}\n\n\t/**\n   * Hydrate all minimal nodes to full in batches\n   * This method processes minimal nodes in the background without blocking the UI\n   */\n\tasync hydrateAllMinimalNodes(): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\t\tconst minimalNodes = store.getMinimalNodes();\n\n\t\tif (!minimalNodes || minimalNodes.length === 0) {\n\t\t\tlogger.debug(\"graph\", \"No minimal nodes to hydrate\", {}, \"GraphDataService\");\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Starting batch hydration of minimal nodes\", {\n\t\t\tminimalNodeCount: minimalNodes.length\n\t\t}, \"GraphDataService\");\n\n\t\t// Process nodes individually with minimal delays for faster loading\n\t\t// Deduplication service will handle caching and prevent duplicate requests\n\t\tconst DELAY_BETWEEN_NODES = 100; // Reduced to 100ms for faster loading\n\t\tconst BATCH_SIZE = 10; // Process more nodes per batch\n\t\tconst BATCH_DELAY = 500; // Reduced delay between batches\n\n\t\tlet processedCount = 0;\n\n\t\tfor (let i = 0; i < minimalNodes.length; i++) {\n\t\t\tconst node = minimalNodes[i];\n\t\t\tif (!node) continue;\n\n\t\t\tlogger.debug(\"graph\", `Processing minimal node ${String(i + 1)}/${String(minimalNodes.length)}`, {\n\t\t\t\tnodeId: node.id,\n\t\t\t\tentityType: node.type,\n\t\t\t\tlabel: node.label\n\t\t\t}, \"GraphDataService\");\n\n\t\t\ttry {\n\t\t\t\tawait this.hydrateNodeToFull(node.id);\n\t\t\t\tprocessedCount++;\n\n\t\t\t\t// Add delay between individual nodes\n\t\t\t\tif (i < minimalNodes.length - 1) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_NODES));\n\t\t\t\t}\n\n\t\t\t\t// Add longer delay every BATCH_SIZE nodes\n\t\t\t\tif ((i + 1) % BATCH_SIZE === 0 && i < minimalNodes.length - 1) {\n\t\t\t\t\tlogger.debug(\"graph\", `Batch of ${String(BATCH_SIZE)} nodes completed, taking longer break`, {\n\t\t\t\t\t\tprocessedSoFar: i + 1,\n\t\t\t\t\t\tremaining: minimalNodes.length - (i + 1)\n\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve, BATCH_DELAY));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.warn(\"graph\", \"Failed to hydrate minimal node, continuing with next\", {\n\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t// Continue with next node even if this one fails\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Finished hydrating all minimal nodes\", {\n\t\t\ttotalRequested: minimalNodes.length,\n\t\t\ttotalProcessed: processedCount,\n\t\t\tsuccessRate: processedCount / minimalNodes.length\n\t\t}, \"GraphDataService\");\n\t}\n\n\t/**\n   * Hydrate all minimal nodes immediately in parallel\n   * This method hydrates all minimal nodes simultaneously without delays for maximum speed\n   * Recommended for use when the graph is first loaded to proactively hydrate all minimal node data\n   */\n\tasync hydrateAllMinimalNodesImmediate(): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\t\tconst minimalNodes = store.getMinimalNodes();\n\n\t\tif (!minimalNodes || minimalNodes.length === 0) {\n\t\t\tlogger.debug(\"graph\", \"No minimal nodes to hydrate immediately\", {}, \"GraphDataService\");\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(\"graph\", \"Starting immediate parallel hydration of all minimal nodes\", {\n\t\t\tminimalNodeCount: minimalNodes.length\n\t\t}, \"GraphDataService\");\n\n\t\t// Hydrate all minimal nodes in parallel using Promise.allSettled to prevent failures from blocking others\n\t\tconst hydratePromises = minimalNodes.map(node =>\n\t\t\tthis.hydrateNodeToFull(node.id).catch((error: unknown) => {\n\t\t\t\tlogger.warn(\"graph\", \"Failed to hydrate minimal node in parallel batch\", {\n\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\tentityType: node.type,\n\t\t\t\t\tlabel: node.label,\n\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t}, \"GraphDataService\");\n\t\t\t\treturn null; // Return null for failed hydrations to continue processing\n\t\t\t})\n\t\t);\n\n\t\tconst results = await Promise.allSettled(hydratePromises);\n\n\t\t// Count successful hydrations\n\t\tconst successfulHydrations = results.filter(result => result.status === \"fulfilled\").length;\n\t\tconst failedHydrations = results.length - successfulHydrations;\n\n\t\tlogger.debug(\"graph\", \"Completed immediate parallel hydration of all minimal nodes\", {\n\t\t\ttotalRequested: minimalNodes.length,\n\t\t\tsuccessful: successfulHydrations,\n\t\t\tfailed: failedHydrations,\n\t\t\tsuccessRate: successfulHydrations / minimalNodes.length\n\t\t}, \"GraphDataService\");\n\t}\n\n\t/**\n   * Expand a node to show related entities\n   * This method performs incremental expansion without setting global loading state\n   */\n \tasync expandNode(nodeId: string, options: ExpansionOptions = {}): Promise<void> {\n \t\tconst { force = false } = options;\n\n \t\tconsole.log(\"DEBUG: expandNode function START\", { nodeId, force });\n \t\tlogger.error(\"graph\", \"DEBUG: expandNode called with\", { nodeId, force }, \"GraphDataService\");\n \t\tlogger.error(\"graph\", \"DEBUG: expandNode START CONSOLE LOG\", { nodeId, force }, \"GraphDataService\");\n \t\tlogger.debug(\"graph\", \"GraphDataService.expandNode called\", { nodeId, force }, \"GraphDataService\");\n\n \t\t// Check if already expanded using TanStack Query cache (unless forced)\n\t\tconst alreadyExpanded = isNodeExpanded(this.queryClient, nodeId);\n\t\tlogger.warn(\"graph\", \"Checking if node already expanded\", { nodeId, alreadyExpanded, force }, \"GraphDataService\");\n\t\tlogger.error(\"graph\", \"DEBUG: alreadyExpanded check\", { alreadyExpanded, force, shouldSkip: !force && alreadyExpanded }, \"GraphDataService\");\n\t\tif (!force && alreadyExpanded) {\n\t\t\tlogger.debug(\"graph\", \"Node already expanded, running relationship detection only\", { nodeId }, \"GraphDataService\");\n\t\t\tlogger.error(\"graph\", \"DEBUG: Taking early return path for already expanded node - THIS SHOULD NOT HAPPEN WITH force=true\", { nodeId }, \"GraphDataService\");\n\n\t\t\t// Even if node is already expanded, run relationship detection\n\t\t\t// in case new nodes were added since last expansion\n\t\t\tconst store = useGraphStore.getState();\n\t\t\tconst allNodeIds = Object.keys(store.nodes);\n\n\t\t\tif (allNodeIds.length > 1) {\n\t\t\t\tlogger.debug(\"graph\", \"Running relationship detection for already-expanded node\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\ttotalNodes: allNodeIds.length\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\ttry {\n\t\t\t\t\tconst detectedEdges = await this.relationshipDetectionService.detectRelationshipsForNodes(allNodeIds);\n\n\t\t\t\t\tif (detectedEdges && detectedEdges.length > 0) {\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Found new relationships for already-expanded node\", {\n\t\t\t\t\t\t\tnodeId,\n\t\t\t\t\t\t\tdetectedEdgeCount: detectedEdges?.length || 0,\n\t\t\t\t\t\t\trelationships: detectedEdges.map(e => ({\n\t\t\t\t\t\t\t\tsource: e.source,\n\t\t\t\t\t\t\t\ttarget: e.target,\n\t\t\t\t\t\t\t\ttype: e.type\n\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t\tstore.addEdges(detectedEdges);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.debug(\"graph\", \"No new relationships found for already-expanded node\", { nodeId }, \"GraphDataService\");\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogError(logger, \"Failed to detect relationships for already-expanded node\", error, \"GraphDataService\", \"graph\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst store = useGraphStore.getState();\n\n\t\t// DON'T set loading state for incremental expansions to avoid showing \"Loading graph...\"\n\t\t// Individual expansions should be seamless and not disrupt the existing graph\n\n\t\ttry {\n\t\t\t// Get the node to expand - use \"in\" operator to avoid ESLint false positive\n\t\t\tlogger.error(\"graph\", \"DEBUG: Checking if node exists in store\", { nodeId, exists: nodeId in store.nodes, storeNodeCount: Object.keys(store.nodes).length }, \"GraphDataService\");\n\t\t\tif (!(nodeId in store.nodes)) {\n\t\t\t\tlogger.error(\"graph\", \"DEBUG: Node not in store, returning early\", { nodeId }, \"GraphDataService\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst node = store.nodes[nodeId];\n\t\t\tlogger.error(\"graph\", \"DEBUG: Retrieved node from store\", { nodeId, nodeExists: !!node, ...(node?.type !== undefined && { nodeType: node.type }) }, \"GraphDataService\");\n\t\t\tif (!node) {\n\t\t\t\tlogger.error(\"graph\", \"DEBUG: Node is null, returning early\", { nodeId }, \"GraphDataService\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if entity type is supported\n\t\t\tlogger.error(\"graph\", \"DEBUG: Checking if entity type is supported\", { nodeId, entityType: node.type, isSupported: EntityFactory.isSupported(node.type) }, \"GraphDataService\");\n\t\t\tif (!EntityFactory.isSupported(node.type)) {\n\t\t\t\tlogger.warn(\"graph\", `Expansion not implemented for entity type: ${node.type}`, {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tentityType: node.type\n\t\t\t\t}, \"GraphDataService\");\n\t\t\t\tlogger.error(\"graph\", \"DEBUG: Entity type not supported, returning early\", { nodeId, entityType: node.type }, \"GraphDataService\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mark the node as loading to provide visual feedback\n\t\t\tstore.markNodeAsLoading(nodeId);\n\n\t\t\t// Log expansion attempt\n\t\t\tlogger.debug(\"graph\", \"Expanding node\", {\n\t\t\t\tnodeId,\n\t\t\t\tentityType: node.type,\n\t\t\t\tforce,\n\t\t\t\tlimit: options.limit,\n\t\t\t\tdepth: options.depth,\n\t\t\t\twasAlreadyExpanded: this.cache.expandedNodes.has(nodeId)\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Create entity instance using the factory\n\t\t\tconst entity = EntityFactory.create(node.type, cachedOpenAlex);\n\n\t\t\t// Get expansion settings for this entity type\n\t\t\tconst expansionSettingsStore = useExpansionSettingsStore.getState();\n\t\t\t// Safely convert entity type to expansion target with type guard\n\t\t\tif (!isEntityType(node.type)) {\n\t\t\t\tlogger.error(\"graph\", \"Invalid entity type for expansion\", { nodeId, entityType: node.type }, \"GraphDataService\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst expansionTarget = node.type; // Already validated as EntityType, which extends ExpansionTarget\n\t\t\tconst expansionSettings = expansionSettingsStore.getSettings(expansionTarget);\n\n\t\t\t// Log expansion settings usage\n\t\t\tlogger.debug(\"graph\", \"Retrieved expansion settings for node expansion\", {\n\t\t\t\tnodeId,\n\t\t\t\tentityType: node.type,\n\t\t\t\texpansionTarget,\n\t\t\t\tsettingsEnabled: expansionSettings.enabled,\n\t\t\t\tsettingsLimit: expansionSettings.limit,\n\t\t\t\tsortsCount: (expansionSettings.sorts ?? []).length,\n\t\t\t\tfiltersCount: (expansionSettings.filters ?? []).length\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Expand the entity with expansion settings\n\t\t\tconst context = {\n\t\t\t\tentityId: node.entityId,\n\t\t\t\tentityType: node.type,\n\t\t\t\tclient: cachedOpenAlex\n\t\t\t};\n\t\t\tconst enhancedOptions = {\n\t\t\t\t...options,\n\t\t\t\texpansionSettings\n\t\t\t};\n\n\t\t\tconst relatedData = await entity.expand(context, enhancedOptions);\n\n\t\t\t// First: Add nodes and initial edges to the store\n\t\t\tconst currentNodes = Object.values(store.nodes).filter((node) => node != null);\n\t\t\tconst currentEdges = Object.values(store.edges).filter((edge): edge is NonNullable<typeof edge> => edge != null);\n\t\t\tconst finalNodes = [...currentNodes, ...relatedData.nodes];\n\t\t\tconst finalEdges = [...currentEdges, ...relatedData.edges];\n\n\t\t\tlogger.debug(\"graph\", \"Adding nodes to store before relationship detection\", {\n\t\t\t\texpandedNodeId: nodeId,\n\t\t\t\tnewNodeCount: relatedData.nodes.length,\n\t\t\t\tnewEdgeCount: relatedData.edges.length,\n\t\t\t\ttotalNodeCount: finalNodes.length,\n\t\t\t\ttotalEdgeCount: finalEdges.length\n\t\t\t}, \"GraphDataService\");\n\n\t\t\t// Single atomic update to add nodes and initial edges\n\t\t\tstore.setGraphData(finalNodes, finalEdges);\n\n\t\t\t// Second: Detect relationships for newly added nodes AFTER adding to graph\n\t\t\tlet detectedEdges: GraphEdge[] = [];\n\t\t\tif (relatedData.nodes.length > 0) {\n\t\t\t\tconst newNodeIds = relatedData.nodes.map((n: GraphNode) => n.id);\n\t\t\t\tlogger.debug(\"graph\", \"Starting relationship detection for expanded nodes\", {\n\t\t\t\t\texpandedNodeId: nodeId,\n\t\t\t\t\tnewNodeCount: newNodeIds.length,\n\t\t\t\t\tentityType: node.type\n\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\ttry {\n\t\t\t\t\t// Run relationship detection now that nodes are in the store\n\t\t\t\t\tdetectedEdges = await this.relationshipDetectionService.detectRelationshipsForNodes(newNodeIds);\n\n\t\t\t\t\tlogger.debug(\"graph\", \"Relationship detection completed\", {\n\t\t\t\t\t\texpandedNodeId: nodeId,\n\t\t\t\t\t\tdetectedEdgeCount: detectedEdges?.length || 0,\n\t\t\t\t\t\trelationships: detectedEdges.map(e => ({\n\t\t\t\t\t\t\tsource: e.source,\n\t\t\t\t\t\t\ttarget: e.target,\n\t\t\t\t\t\t\ttype: e.type\n\t\t\t\t\t\t}))\n\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t// Third: Add the detected relationship edges if any were found\n\t\t\t\t\tif (detectedEdges && detectedEdges.length > 0) {\n\t\t\t\t\t\tconst finalEdgesWithRelationships = [...finalEdges, ...detectedEdges];\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Adding detected relationship edges\", {\n\t\t\t\t\t\t\texpandedNodeId: nodeId,\n\t\t\t\t\t\t\trelationshipEdgeCount: detectedEdges?.length || 0,\n\t\t\t\t\t\t\ttotalEdgeCount: finalEdgesWithRelationships.length\n\t\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t\t// Update store with relationship edges\n\t\t\t\t\t\tstore.setGraphData(finalNodes, finalEdgesWithRelationships);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogError(logger, \"Failed to detect relationships for expanded nodes\", error, \"GraphDataService\", \"graph\");\n\t\t\t\t\t// Continue with expansion even if relationship detection fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update cached graph data with final state (including any detected relationship edges)\n\t\t\tconst finalEdgesWithRelationships = (detectedEdges && detectedEdges.length > 0) ? [...finalEdges, ...detectedEdges] : finalEdges;\n\t\t\tsetCachedGraphNodes(this.queryClient, finalNodes);\n\t\t\tsetCachedGraphEdges(this.queryClient, finalEdgesWithRelationships);\n\n\t\t\tlogger.error(\"graph\", \"DEBUG: About to check force condition\", { force, nodeId }, \"GraphDataService\");\n   \t\t\t// If force is true, run relationship detection on all nodes in the graph\n   \t\t\t// This ensures relationships are detected even when no new nodes are added\n   \t\t\tlogger.error(\"graph\", \"FORCE CHECK START\", { force, nodeId, typeofForce: typeof force }, \"GraphDataService\");\n   \t\t\tif (force) {\n   \t\t\t\tlogger.error(\"graph\", \"INSIDE FORCE IF BLOCK\", { force, nodeId }, \"GraphDataService\");\n  \t\t\t\tconsole.log(\"FORCE BRANCH EXECUTING\", { nodeId });\n   \t\t\t\tconst allNodeIds = Object.keys(store.nodes);\n   \t\t\t\tlogger.error(\"graph\", \"FORCE BRANCH NODES\", { count: allNodeIds.length, nodeIds: allNodeIds }, \"GraphDataService\");\n   \t\t\t\tif (allNodeIds.length > 1) { // Only run if there are multiple nodes\n   \t\t\t\t\tlogger.error(\"graph\", \"FORCE BRANCH CONDITION MET\", { count: allNodeIds.length }, \"GraphDataService\");\n  \t\t\t\t\tlogger.debug(\"graph\", \"Running relationship detection on all nodes due to force=true\", {\n  \t\t\t\t\t\texpandedNodeId: nodeId,\n  \t\t\t\t\t\ttotalNodeCount: allNodeIds.length,\n  \t\t\t\t\t\tallNodeIds\n  \t\t\t\t\t}, \"GraphDataService\");\n\n   \t\t\t\t\ttry {\n   \t\t\t\t\t\tlogger.error(\"graph\", \"DEBUG: FORCE BRANCH - Calling detectRelationshipsForNodes\", { allNodeIds, count: allNodeIds.length }, \"GraphDataService\");\n   \t\t\t\t\t\tconst forceDetectedEdges = await this.relationshipDetectionService.detectRelationshipsForNodes(allNodeIds);\n   \t\t\t\t\t\tlogger.error(\"graph\", \"DEBUG: FORCE BRANCH - detectRelationshipsForNodes returned\", { forceDetectedEdgesCount: forceDetectedEdges?.length || 0, ...(forceDetectedEdges !== undefined && { forceDetectedEdges }) }, \"GraphDataService\");\n\n\t\t\t\t\t\tif (forceDetectedEdges && forceDetectedEdges.length > 0) {\n\t\t\t\t\t\t\tlogger.debug(\"graph\", \"Adding force-detected relationship edges\", {\n\t\t\t\t\t\t\t\texpandedNodeId: nodeId,\n\t\t\t\t\t\t\t\tforceDetectedEdgeCount: forceDetectedEdges.length,\n\t\t\t\t\t\t\t\trelationships: forceDetectedEdges.map(e => ({\n\t\t\t\t\t\t\t\t\tsource: e.source,\n\t\t\t\t\t\t\t\t\ttarget: e.target,\n\t\t\t\t\t\t\t\t\ttype: e.type\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t\t\t// Get current graph state\n\t\t\t\t\t\t\tconst currentNodes = Object.values(store.nodes).filter((node) => node != null);\n\t\t\t\t\t\t\tconst currentEdges = Object.values(store.edges).filter((edge): edge is NonNullable<typeof edge> => edge != null);\n\n\t\t\t\t\t\t\t// Add the force-detected edges\n\t\t\t\t\t\t\tconst finalEdgesWithForceRelationships = [...currentEdges, ...forceDetectedEdges];\n\t\t\t\t\t\t\tstore.setGraphData(currentNodes, finalEdgesWithForceRelationships);\n\n\t\t\t\t\t\t\t// Update cached edges\n\t\t\t\t\t\t\tsetCachedGraphEdges(this.queryClient, finalEdgesWithForceRelationships);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogError(logger, \"Failed to detect relationships with force=true\", error, \"GraphDataService\", \"graph\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n  \t\t\t// Mark as expanded in TanStack Query cache\n  \t\t\tsetNodeExpanded(this.queryClient, nodeId, true);\n\n  \t\t\t// Mark the node as loaded (expansion completed successfully)\n  \t\t\tstore.markNodeAsLoaded(nodeId, {\n  \t\t\t\t// No artificial metadata - node is considered loaded when operation completes\n  \t\t\t});\n\n  \t\t\t// Layout is automatically handled by the provider when nodes/edges are added\n\n  \t\t\tconsole.log(\"DEBUG: About to reach force check\", { nodeId, force });\n\n  \t\t} catch (error) {\n  \t\t\t// Mark the node as error if expansion failed\n  \t\t\tstore.markNodeAsError(nodeId);\n\n  \t\t\tconsole.log(\"DEBUG: expandNode function ERROR\", { nodeId, error: error instanceof Error ? error.message : String(error) });\n  \t\t\tlogError(logger, \"Failed to expand node\", error, \"GraphDataService\", \"graph\");\n  \t\t} finally {\n  \t\t\tconsole.log(\"DEBUG: expandNode function END\", { nodeId, force });\n  \t\t}\n \t}\n\n\t/**\n   * Search and add results to graph\n   */\n\tasync searchAndVisualize(query: string, options: SearchOptions): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\t\tstore.setLoading(true);\n\t\tstore.setError(null);\n\n\t\ttry {\n\t\t\t// Search each entity type using the client API\n\t\t\tconst limit = options.limit || 20;\n\t\t\tconst entityTypes = options.entityTypes || [\"works\", \"authors\", \"sources\", \"institutions\", \"topics\"];\n\t\t\tconst allResults: OpenAlexEntity[] = [];\n\n\t\t\t// Search each entity type and collect results\n\t\t\tfor (const entityType of entityTypes) {\n\t\t\t\tlet entityResults: OpenAlexEntity[] = [];\n\t\t\t\ttry {\n\t\t\t\t\tswitch (entityType) {\n\t\t\t\t\t\tcase \"works\": {\n\t\t\t\t\t\t\tconst worksResponse = await cachedOpenAlex.client.works.getWorks({\n\t\t\t\t\t\t\t\tsearch: query,\n\t\t\t\t\t\t\t\tper_page: limit\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tentityResults = worksResponse.results;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"authors\": {\n\t\t\t\t\t\t\tconst authorsResponse = await cachedOpenAlex.client.authors.getAuthors({\n\t\t\t\t\t\t\t\tsearch: query,\n\t\t\t\t\t\t\t\tper_page: limit\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tentityResults = authorsResponse.results;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"sources\": {\n\t\t\t\t\t\t\tconst sourcesResponse = await cachedOpenAlex.client.sources.getSources({\n\t\t\t\t\t\t\t\tsearch: query,\n\t\t\t\t\t\t\t\tper_page: limit\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tentityResults = sourcesResponse.results;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"institutions\": {\n\t\t\t\t\t\t\tconst institutionsResponse = await cachedOpenAlex.client.institutions.searchInstitutions(query, {\n\t\t\t\t\t\t\t\tper_page: limit\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tentityResults = institutionsResponse.results;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"topics\": {\n\t\t\t\t\t\t\tconst topicsResponse = await cachedOpenAlex.client.topics.getMultiple({\n\t\t\t\t\t\t\t\tsearch: query,\n\t\t\t\t\t\t\t\tper_page: limit\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tentityResults = topicsResponse.results;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.warn(\"api\", `Failed to search ${entityType}`, { query, error });\n\t\t\t\t}\n\t\t\t\tallResults.push(...entityResults);\n\t\t\t}\n\n\t\t\t// Use the collected results\n\t\t\tconst flatResults: OpenAlexEntity[] = allResults;\n\n\t\t\t// Track search statistics by counting results by entity type\n\t\t\tconst searchStats: Record<EntityType, number> = {\n\t\t\t\tworks: 0,\n\t\t\t\tauthors: 0,\n\t\t\t\tsources: 0,\n\t\t\t\tinstitutions: 0,\n\t\t\t\ttopics: 0,\n\t\t\t\tconcepts: 0,\n\t\t\t\tpublishers: 0,\n\t\t\t\tfunders: 0,\n\t\t\t\tkeywords: 0,\n\t\t\t};\n\n\t\t\t// Count results by entity type\n\t\t\tfor (const result of flatResults) {\n\t\t\t\ttry {\n\t\t\t\t\tconst detection = this.detector.detectEntityIdentifier(result.id);\n\t\t\t\t\tif (detection.entityType && isEntityType(detection.entityType)) {\n\t\t\t\t\t\tsearchStats[detection.entityType]++;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Skip results that can't be detected\n\t\t\t\t\tlogger.warn(\"graph\", \"Could not detect entity type for search result\", { result, error });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst { nodes, edges } = this.transformSearchResults(flatResults);\n\n\t\t\t// Clear existing graph and add search results\n\t\t\tstore.clear();\n\t\t\tstore.addNodes(nodes);\n\t\t\tstore.addEdges(edges);\n\t\t\tstore.updateSearchStats(searchStats);\n\n\t\t\t// Layout is now handled by the ReactFlow component's useLayout hook\n\t\t\t// No need for explicit layout application here\n\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : \"Search failed\";\n\t\t\tstore.setError(errorMessage);\n\t\t\tlogError(logger, \"Failed to search and visualize\", error, \"GraphDataService\", \"graph\");\n\t\t} finally {\n\t\t\tstore.setLoading(false);\n\t\t}\n\t}\n\n\t/**\n   * Fetch entity with specific fields using the appropriate OpenAlex API method\n   */\n\tprivate async fetchEntityWithFields(entityId: string, entityType: EntityType, fields: string[]): Promise<OpenAlexEntity> {\n\t\tconst params = { select: fields };\n\n\t\tswitch (entityType) {\n\t\t\tcase \"works\":\n\t\t\t\treturn await cachedOpenAlex.client.works.getWork(entityId, params);\n\t\t\tcase \"authors\":\n\t\t\t\treturn await cachedOpenAlex.client.authors.getAuthor(entityId, params);\n\t\t\tcase \"sources\":\n\t\t\t\treturn await cachedOpenAlex.client.sources.getSource(entityId, params);\n\t\t\tcase \"institutions\":\n\t\t\t\treturn await cachedOpenAlex.client.institutions.getInstitution(entityId, params);\n\t\t\tcase \"topics\":\n\t\t\t\treturn await cachedOpenAlex.client.topics.get(entityId, params);\n\t\t\tcase \"publishers\":\n\t\t\t\treturn await cachedOpenAlex.client.publishers.get(entityId, params);\n\t\t\tcase \"funders\":\n\t\t\t\treturn await cachedOpenAlex.client.funders.get(entityId, params);\n\t\t\tcase \"keywords\":\n\t\t\t\treturn await cachedOpenAlex.client.keywords.getKeyword(entityId, params);\n\t\t\tdefault:\n\t\t\t\t// Fallback to generic method without field selection\n\t\t\t\treturn await cachedOpenAlex.client.getEntity(entityId);\n\t\t}\n\t}\n\n\t/**\n   * Create a minimal node with just essential data using selective API field loading\n   * Uses incremental hydration with minimal API field loading\n   */\n\tasync createMinimalNode(entityId: string, entityType: EntityType): Promise<GraphNode | null> {\n\t\ttry {\n\t\t\t// Define minimal fields needed for basic node display\n\t\t\tconst minimalFieldsMap: Partial<Record<EntityType, string[]>> = {\n\t\t\t\tworks: [\"id\", \"display_name\", \"publication_year\", \"cited_by_count\", \"open_access.is_oa\", \"referenced_works\", \"authorships\", \"primary_location.source.id\"],\n\t\t\t\tauthors: [\"id\", \"display_name\", \"works_count\", \"cited_by_count\", \"affiliations\"],\n\t\t\t\tsources: [\"id\", \"display_name\", \"works_count\", \"cited_by_count\", \"type\"],\n\t\t\t\tinstitutions: [\"id\", \"display_name\", \"works_count\", \"cited_by_count\", \"country_code\"],\n\t\t\t\ttopics: [\"id\", \"display_name\", \"works_count\", \"cited_by_count\"],\n\t\t\t\tpublishers: [\"id\", \"display_name\", \"works_count\", \"sources_count\"],\n\t\t\t\tfunders: [\"id\", \"display_name\", \"works_count\", \"grants_count\"],\n\t\t\t\tkeywords: [\"id\", \"display_name\", \"works_count\", \"cited_by_count\"]\n\t\t\t};\n\n\t\t\tconst fields = minimalFieldsMap[entityType] || [\"id\", \"display_name\"];\n\n\t\t\t// Use the specific entity method with field selection for minimal data\n\t\t\tconst entity = await this.deduplicationService.getEntity(\n\t\t\t\tentityId,\n\t\t\t\t() => this.fetchEntityWithFields(entityId, entityType, fields)\n\t\t\t);\n\n\t\t\t// Create node with minimal data using entityData\n\t\t\treturn {\n\t\t\t\tid: entity.id,\n\t\t\t\ttype: entityType,\n\t\t\t\tlabel: entity.display_name || `${entityType} ${entity.id}`,\n\t\t\t\tentityId: entity.id,\n\t\t\t\tposition: { x: 0, y: 0 }, // Will be positioned by layout\n\t\t\t\texternalIds: [], // Will be populated during full hydration\n\t\t\t\tentityData: this.getEntityData(entity)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogError(logger, `Failed to create minimal node for ${entityId}`, error, \"GraphDataService\", \"graph\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n   * Load minimal data in background for nodes to get basic display data (non-blocking)\n   * Uses selective API field loading for efficiency\n   */\n\tprivate async loadMinimalDataInBackground(entityId: string, entityType: EntityType): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\n\t\tif (!(entityId in store.nodes)) {\n\t\t\treturn;\n\t\t}\n\t\tconst node = store.nodes[entityId];\n\n\t\ttry {\n\t\t\t// Create minimal node with selective field loading\n\t\t\tconst minimalNode = await this.createMinimalNode(entityId, entityType);\n\t\t\tif (minimalNode) {\n\t\t\t\t// Update only the label and entityData, preserve position\n\t\t\t\tstore.updateNode(entityId, {\n\t\t\t\t\t...node,\n\t\t\t\t\tlabel: minimalNode.label,\n\t\t\t\t\t...(minimalNode.entityData && { entityData: minimalNode.entityData })\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"graph\", \"Background minimal data loading completed\", {\n\t\t\t\t\tentityId,\n\t\t\t\t\tnewLabel: minimalNode.label,\n\t\t\t\t\tentityType\n\t\t\t\t}, \"GraphDataService\");\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Silent failure for background loading - don't spam logs\n\t\t\tlogger.debug(\"graph\", \"Background minimal data loading failed silently\", {\n\t\t\t\tentityId,\n\t\t\t\tentityType,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t}, \"GraphDataService\");\n\t\t}\n\t}\n\n\n\t/**\n   * Hydrate a node with full data when needed (e.g., when user interacts with it)\n   */\n\tasync hydrateNode(nodeId: string): Promise<void> {\n\t\tconst store = useGraphStore.getState();\n\n\t\tif (!(nodeId in store.nodes)) {\n\t\t\tlogger.warn(\"graph\", \"Cannot hydrate non-existent node\", { nodeId });\n\t\t\treturn;\n\t\t}\n\t\tconst node = store.nodes[nodeId];\n\t\tif (!node) return;\n\n\t\t// No artificial hydration checks - proceed with field-level hydration as needed\n\n\t\ttry {\n\t\t\t// Mark node as loading during hydration\n\t\t\tstore.markNodeAsLoading(nodeId);\n\n\t\t\t// Fetch full entity data without field restrictions\n\t\t\tconst fullEntity = await this.deduplicationService.getEntity(\n\t\t\t\tnode.entityId,\n\t\t\t\t() => cachedOpenAlex.client.getEntity(node.entityId)\n\t\t\t);\n\n\t\t\t// Create updated node data WITHOUT creating related entities (hydration only)\n\t\t\t// This prevents automatic expansion of related entities during single-click hydration\n\t\t\tconst fullNodeData = this.createNodeFromEntity(fullEntity, node.type);\n\n\t\t\t// Update node with full data\n\t\t\tstore.updateNode(nodeId, {\n\t\t\t\t...fullNodeData,\n\t\t\t\tposition: node.position, // Preserve current position\n\t\t\t});\n\n\t\t\tlogger.debug(\"graph\", \"Node fully hydrated (without expansion)\", {\n\t\t\t\tnodeId,\n\t\t\t\tentityType: node.type,\n\t\t\t\texternalIdCount: fullNodeData.externalIds.length\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogError(logger, `Failed to hydrate node ${nodeId}`, error, \"GraphDataService\", \"graph\");\n\t\t\tstore.markNodeAsLoading(nodeId, false); // Clear loading state on error\n\t\t}\n\t}\n\n\t/**\n\t * Expand all visible nodes to find only entities of the specified type\n\t * This efficiently fetches only the target entity type, avoiding unnecessary API calls\n\t */\n\tasync expandAllNodesOfType(entityType: EntityType, options: ExpansionOptions = {}): Promise<void> {\n\t\tlogger.debug(\"graph\", \"expandAllNodesOfType called\", { entityType, options }, \"GraphDataService\");\n\t\tconst store = useGraphStore.getState();\n\t\t// Use direct selectors instead of unstable getter function to avoid infinite loops\n\t\tconst { nodes, visibleEntityTypes } = store;\n\t\tconst allVisibleNodes = Object.values(nodes).filter((node) => node != null).filter((node) => node.type in visibleEntityTypes);\n\n\t\tif (allVisibleNodes.length === 0) {\n\t\t\tlogger.debug(\"graph\", \"No visible nodes found to expand\", { entityType }, \"GraphDataService\");\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(\"graph\", `Expanding all visible nodes to find ${entityType} entities`, {\n\t\t\tentityType,\n\t\t\tvisibleNodeCount: allVisibleNodes.length,\n\t\t\toptions\n\t\t}, \"GraphDataService\");\n\n\t\t// Set loading state for the bulk operation\n\t\tstore.setLoading(true);\n\n\t\ttry {\n\t\t\tconst newNodes: GraphNode[] = [];\n\t\t\tconst newEdges: GraphEdge[] = [];\n\n\t\t\t// For each visible node, extract only entities of the target type from their data\n\t\t\tfor (const node of allVisibleNodes) {\n\t\t\t\ttry {\n\t\t\t\t\t// Get the node's entity data\n\t\t\t\t\tif (!node.entityData) {\n\t\t\t\t\t\t// If node doesn't have entity data, skip it\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extract entities of target type from the node's entity data\n\t\t\t\t\tconst relatedEntityIds = this.extractRelatedEntitiesOfType(node.entityData, entityType);\n\n\t\t\t\t\tif (relatedEntityIds.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.debug(\"graph\", `Found ${relatedEntityIds.length.toString()} ${entityType} entities related to ${node.id}`, {\n\t\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\t\tsourceType: node.type,\n\t\t\t\t\t\ttargetType: entityType,\n\t\t\t\t\t\trelatedCount: relatedEntityIds.length\n\t\t\t\t\t}, \"GraphDataService\");\n\n\t\t\t\t\t// Fetch only the entities of target type (efficiently)\n\t\t\t\t\tfor (const entityId of relatedEntityIds.slice(0, options.limit || relatedEntityIds.length)) {\n\t\t\t\t\t\t// Skip if we already have this node\n\t\t\t\t\t\tif (entityId in store.nodes) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Create minimal node for the target entity type\n\t\t\t\t\t\t\tconst minimalNode = await this.createMinimalNode(entityId, entityType);\n\t\t\t\t\t\t\tif (minimalNode) {\n\t\t\t\t\t\t\t\tnewNodes.push(minimalNode);\n\n\t\t\t\t\t\t\t\t// Create edge from source node to new node\n\t\t\t\t\t\t\t\tconst relationshipType = this.determineRelationshipType(node.type, entityType);\n\t\t\t\t\t\t\t\tconst edge: GraphEdge = {\n\t\t\t\t\t\t\t\t\tid: `${node.id}-${relationshipType}-${entityId}`,\n\t\t\t\t\t\t\t\t\tsource: node.id,\n\t\t\t\t\t\t\t\t\ttarget: entityId,\n\t\t\t\t\t\t\t\t\ttype: relationshipType,\n\t\t\t\t\t\t\t\t\tlabel: relationshipType.replace(/_/g, \" \")\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tnewEdges.push(edge);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tlogger.warn(\"graph\", `Failed to fetch ${entityType} entity`, {\n\t\t\t\t\t\t\t\tentityId,\n\t\t\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t\t\t\t}, \"GraphDataService\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.warn(\"graph\", `Failed to process node ${node.id}`, {\n\t\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t\t\t}, \"GraphDataService\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add new nodes and edges to the graph\n\t\t\tif (newNodes.length > 0) {\n\t\t\t\tstore.addNodes(newNodes);\n\t\t\t\tlogger.debug(\"graph\", `Added ${newNodes.length.toString()} new ${entityType} nodes to graph`, {\n\t\t\t\t\tentityType,\n\t\t\t\t\taddedCount: newNodes.length\n\t\t\t\t}, \"GraphDataService\");\n\t\t\t}\n\n\t\t\tif (newEdges.length > 0) {\n\t\t\t\tstore.addEdges(newEdges);\n\t\t\t\tlogger.debug(\"graph\", `Added ${newEdges.length.toString()} new edges to graph`, {\n\t\t\t\t\tentityType,\n\t\t\t\t\tedgeCount: newEdges.length\n\t\t\t\t}, \"GraphDataService\");\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", `Completed expanding all visible nodes for ${entityType} entities`, {\n\t\t\t\tentityType,\n\t\t\t\texpandedNodeCount: allVisibleNodes.length,\n\t\t\t\tnewNodesAdded: newNodes.length,\n\t\t\t\tnewEdgesAdded: newEdges.length\n\t\t\t}, \"GraphDataService\");\n\n\t\t} catch (error) {\n\t\t\tconst errorMessage = `Failed to expand all visible nodes for ${entityType}`;\n\t\t\tlogger.error(\"graph\", errorMessage, {\n\t\t\t\tentityType,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t}, \"GraphDataService\");\n\t\t\tstore.setError(errorMessage);\n\t\t\tlogError(logger, errorMessage, error, \"GraphDataService\", \"graph\");\n\t\t} finally {\n\t\t\tstore.setLoading(false);\n\t\t}\n\t}\n\n\t/**\n\t * Extract related entity IDs of a specific type from entity data\n\t */\n\tprivate extractRelatedEntitiesOfType(entityData: unknown, targetType: EntityType): string[] {\n\t\tif (!entityData || typeof entityData !== \"object\") {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Type guard for entityData as record\n\t\tfunction isRecord(value: unknown): value is Record<string, unknown> {\n\t\t\treturn value !== null && typeof value === \"object\" && !Array.isArray(value);\n\t\t}\n\n\t\tif (!isRecord(entityData)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst data = entityData;\n\t\tconst entityIds: string[] = [];\n\n\t\t// Map of entity types to their common field names in OpenAlex data\n\t\tconst fieldMappings: Record<EntityType, string[]> = {\n\t\t\tworks: [\"referenced_works\", \"related_works\", \"cites\"],\n\t\t\tauthors: [\"authorships\", \"authors\"],\n\t\t\tsources: [\"primary_location\", \"locations\", \"host_venue\"],\n\t\t\tinstitutions: [\"institutions\", \"affiliations\"],\n\t\t\ttopics: [\"topics\", \"concepts\"],\n\t\t\tconcepts: [\"concepts\"],\n\t\t\tpublishers: [\"publishers\"],\n\t\t\tfunders: [\"grants\", \"funders\"],\n\t\t\tkeywords: [\"keywords\"]\n\t\t};\n\n\t\tconst fieldsToCheck = fieldMappings[targetType];\n\n\t\tfor (const field of fieldsToCheck) {\n\t\t\tconst fieldValue = data[field];\n\n\t\t\tif (Array.isArray(fieldValue)) {\n\t\t\t\tfor (const item of fieldValue) {\n\t\t\t\t\tif (typeof item === \"string\" && item.startsWith(\"https://openalex.org/\")) {\n\t\t\t\t\t\tentityIds.push(item);\n\t\t\t\t\t} else if (item && typeof item === \"object\" && !Array.isArray(item)) {\n\t\t\t\t\t\tif (isRecord(item) && typeof item['id'] === \"string\" && item['id'].startsWith(\"https://openalex.org/\")) {\n\t\t\t\t\t\t\tentityIds.push(item['id']);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (fieldValue && typeof fieldValue === \"object\" && !Array.isArray(fieldValue)) {\n\t\t\t\tif (isRecord(fieldValue) && typeof fieldValue['id'] === \"string\" && fieldValue['id'].startsWith(\"https://openalex.org/\")) {\n\t\t\t\t\tentityIds.push(fieldValue['id']);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove duplicates using Record pattern\n\t\tconst unique: Record<string, boolean> = {};\n\t\tentityIds.forEach(id => unique[id] = true);\n\t\treturn Object.keys(unique);\n\t}\n\n\t/**\n\t * Determine the relationship type between two entity types\n\t */\n\tprivate determineRelationshipType(sourceType: EntityType, targetType: EntityType): RelationType {\n\t\t// Map common relationships between entity types\n\t\tconst relationshipMap: Partial<Record<string, RelationType>> = {\n\t\t\t\"works-works\": RelationType.REFERENCES,\n\t\t\t\"works-authors\": RelationType.AUTHORED,\n\t\t\t\"works-sources\": RelationType.PUBLISHED_IN,\n\t\t\t\"works-institutions\": RelationType.AFFILIATED,\n\t\t\t\"works-topics\": RelationType.WORK_HAS_TOPIC,\n\t\t\t\"works-funders\": RelationType.FUNDED_BY,\n\t\t\t\"authors-works\": RelationType.AUTHORED,\n\t\t\t\"authors-institutions\": RelationType.AFFILIATED,\n\t\t\t\"sources-publishers\": RelationType.SOURCE_PUBLISHED_BY,\n\t\t\t\"institutions-institutions\": RelationType.INSTITUTION_CHILD_OF,\n\t\t};\n\n\t\tconst key = `${sourceType}-${targetType}`;\n\t\treturn relationshipMap[key] || RelationType.RELATED_TO;\n\t}\n\n\t/**\n   * Transform OpenAlex entity to graph nodes and edges\n   */\n\tprivate transformEntityToGraph(entity: OpenAlexEntity): { nodes: GraphNode[]; edges: GraphEdge[] } {\n\t\tconst nodes: GraphNode[] = [];\n\t\tconst edges: GraphEdge[] = [];\n\n\t\t// Determine entity type\n\t\tconst detection = this.detector.detectEntityIdentifier(entity.id);\n\t\tif (!detection.entityType || !isEntityType(detection.entityType)) {\n\t\t\tthrow new Error(`Unable to determine valid entity type for: ${entity.id}`);\n\t\t}\n\t\tconst {entityType} = detection;\n\n\t\t// Create main entity node\n\t\tconst mainNode = this.createNodeFromEntity(entity, entityType);\n\t\tnodes.push(mainNode);\n\n\t\t// Transform based on entity type\n\t\tswitch (entityType) {\n\t\t\tcase \"works\": {\n\t\t\t\tif (!isWork(entity)) {\n\t\t\t\t\tlogger.error(\"graph\", \"Entity is not a valid Work\", { entityId: entity.id }, \"GraphDataService\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst workData = this.transformWork(entity);\n\t\t\t\tnodes.push(...workData.nodes);\n\t\t\t\tedges.push(...workData.edges);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"authors\": {\n\t\t\t\tif (!isAuthor(entity)) {\n\t\t\t\t\tlogger.error(\"graph\", \"Entity is not a valid Author\", { entityId: entity.id }, \"GraphDataService\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst authorData = this.transformAuthor(entity);\n\t\t\t\tnodes.push(...authorData.nodes);\n\t\t\t\tedges.push(...authorData.edges);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"sources\": {\n\t\t\t\tif (!isSource(entity)) {\n\t\t\t\t\tlogger.error(\"graph\", \"Entity is not a valid Source\", { entityId: entity.id }, \"GraphDataService\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst sourceData = this.transformSource(entity);\n\t\t\t\tnodes.push(...sourceData.nodes);\n\t\t\t\tedges.push(...sourceData.edges);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"institutions\": {\n\t\t\t\tif (!isInstitution(entity)) {\n\t\t\t\t\tlogger.error(\"graph\", \"Entity is not a valid Institution\", { entityId: entity.id }, \"GraphDataService\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst institutionData = this.transformInstitution(entity);\n\t\t\t\tnodes.push(...institutionData.nodes);\n\t\t\t\tedges.push(...institutionData.edges);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn { nodes, edges };\n\t}\n\n\t/**\n   * Transform Work entity with incremental hydration approach\n   */\n\tprivate transformWork(work: Work): { nodes: GraphNode[]; edges: GraphEdge[] } {\n\t\tconst nodes: GraphNode[] = [];\n\t\tconst edges: GraphEdge[] = [];\n\t\tconst store = useGraphStore.getState();\n\n\t\t// Only create edges to authors that already exist in the graph\n\t\t// Do NOT automatically create author nodes - they should only be created during explicit expansion\n\t\twork.authorships?.forEach((authorship) => {\n\t\t\tconst existingAuthorNode = store.getNode(authorship.author.id);\n\n\t\t\t// Only create edge if the author node already exists in the graph\n\t\t\tif (existingAuthorNode) {\n\t\t\t\tedges.push({\n\t\t\t\t\tid: `${authorship.author.id}-authored-${work.id}`,\n\t\t\t\t\tsource: authorship.author.id,\n\t\t\t\t\ttarget: work.id,\n\t\t\t\t\ttype: RelationType.AUTHORED,\n\t\t\t\t\tlabel: authorship.author_position === \"first\" ? \"first author\" : \"co-author\",\n\t\t\t\t\tweight: authorship.author_position === \"first\" ? 1.0 : 0.5,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// Only create edges to sources that already exist in the graph\n\t\t// Do NOT automatically create source nodes - they should only be created during explicit expansion\n\t\tif (work.primary_location?.source) {\n\t\t\tconst existingSourceNode = store.getNode(work.primary_location.source.id);\n\n\t\t\t// Only create edge if the source node already exists in the graph\n\t\t\tif (existingSourceNode) {\n\t\t\t\tedges.push({\n\t\t\t\t\tid: `${work.id}-published-in-${work.primary_location.source.id}`,\n\t\t\t\t\tsource: work.id,\n\t\t\t\t\ttarget: work.primary_location.source.id,\n\t\t\t\t\ttype: RelationType.PUBLISHED_IN,\n\t\t\t\t\tlabel: \"published in\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Only create edges to referenced works that already exist in the graph\n\t\t// Do NOT automatically create referenced work nodes - they should only be created during explicit expansion\n\t\twork.referenced_works?.forEach((citedWorkId) => {\n\t\t\tconst existingCitedNode = store.getNode(citedWorkId);\n\n\t\t\t// Only create edge if the referenced work node already exists in the graph\n\t\t\tif (existingCitedNode) {\n\t\t\t\tedges.push({\n\t\t\t\t\tid: `${work.id}-cites-${citedWorkId}`,\n\t\t\t\t\tsource: work.id,\n\t\t\t\t\ttarget: citedWorkId,\n\t\t\t\t\ttype: RelationType.REFERENCES,\n\t\t\t\t\tlabel: \"references\",\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn { nodes, edges };\n\t}\n\n\t/**\n   * Transform Author entity with incremental hydration approach\n   * Note: Institution nodes are now only created during explicit expansion, not automatic loading\n   */\n\tprivate transformAuthor(author: Author): { nodes: GraphNode[]; edges: GraphEdge[] } {\n\t\tconst nodes: GraphNode[] = [];\n\t\tconst edges: GraphEdge[] = [];\n\t\tconst store = useGraphStore.getState();\n\n\t\t// Only create edges to institutions that already exist in the graph\n\t\t// Do NOT automatically create institution nodes - they should only be created during explicit expansion\n\t\tauthor.affiliations?.forEach((affiliation) => {\n\t\t\tconst existingInstitutionNode = store.getNode(affiliation.institution.id);\n\n\t\t\t// Only create edge if the institution node already exists in the graph\n\t\t\tif (existingInstitutionNode) {\n\t\t\t\tedges.push({\n\t\t\t\t\tid: `${author.id}-affiliated-${affiliation.institution.id}`,\n\t\t\t\t\tsource: author.id,\n\t\t\t\t\ttarget: affiliation.institution.id,\n\t\t\t\t\ttype: RelationType.AFFILIATED,\n\t\t\t\t\tlabel: \"affiliated with\",\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn { nodes, edges };\n\t}\n\n\t/**\n   * Transform Source entity (basic implementation)\n   */\n\tprivate transformSource(source: Source): { nodes: GraphNode[]; edges: GraphEdge[] } {\n\t\tconst nodes: GraphNode[] = [];\n\t\tconst edges: GraphEdge[] = [];\n\t\tconst store = useGraphStore.getState();\n\n\t\t// Only create edges to publishers that already exist in the graph\n\t\t// Do NOT automatically create publisher nodes - they should only be created during explicit expansion\n\t\tif (source.publisher) {\n\t\t\tconst existingPublisherNode = store.getNode(source.publisher);\n\n\t\t\t// Only create edge if the publisher node already exists in the graph\n\t\t\tif (existingPublisherNode) {\n\t\t\t\tedges.push({\n\t\t\t\t\tid: `${source.id}-published-by-${source.publisher}`,\n\t\t\t\t\tsource: source.id,\n\t\t\t\t\ttarget: source.publisher,\n\t\t\t\t\ttype: RelationType.SOURCE_PUBLISHED_BY,\n\t\t\t\t\tlabel: \"published by\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn { nodes, edges };\n\t}\n\n\t/**\n   * Transform Institution entity (basic implementation)\n   */\n\tprivate transformInstitution(institution: InstitutionEntity): { nodes: GraphNode[]; edges: GraphEdge[] } {\n\t\tconst nodes: GraphNode[] = [];\n\t\tconst edges: GraphEdge[] = [];\n\t\tconst store = useGraphStore.getState();\n\n\t\t// Only create edges to parent institutions that already exist in the graph\n\t\t// Do NOT automatically create parent institution nodes - they should only be created during explicit expansion\n\t\tinstitution.lineage?.forEach((parentId) => {\n\t\t\tif (parentId !== institution.id) {\n\t\t\t\tconst existingParentNode = store.getNode(parentId);\n\n\t\t\t\t// Only create edge if the parent institution node already exists in the graph\n\t\t\t\tif (existingParentNode) {\n\t\t\t\t\tedges.push({\n\t\t\t\t\t\tid: `${institution.id}-child-of-${parentId}`,\n\t\t\t\t\t\tsource: institution.id,\n\t\t\t\t\t\ttarget: parentId,\n\t\t\t\t\t\ttype: RelationType.INSTITUTION_CHILD_OF,\n\t\t\t\t\t\tlabel: \"child of\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn { nodes, edges };\n\t}\n\n\t/**\n   * Create a graph node from an OpenAlex entity\n   */\n\tprivate createNodeFromEntity(entity: OpenAlexEntity, entityType: EntityType): GraphNode {\n\t\tconst externalIds = this.extractExternalIds(entity, entityType);\n\n\t\treturn {\n\t\t\tid: entity.id,\n\t\t\ttype: entityType,\n\t\t\tlabel: entity.display_name || \"Unknown Entity\",\n\t\t\tentityId: entity.id,\n\t\t\tposition: { x: 0, y: 0 }, // Will be updated by layout\n\t\t\texternalIds,\n\t\t\tentityData: this.getEntityData(entity),\n\t\t};\n\t}\n\n\t/**\n   * Extract external identifiers from entity\n   */\n\tprivate extractExternalIds(entity: OpenAlexEntity, entityType: EntityType): ExternalIdentifier[] {\n\t\tconst externalIds: ExternalIdentifier[] = [];\n\n\t\t// Type guard for basic entity validation\n\t\tif (!entity || typeof entity !== \"object\") {\n\t\t\treturn externalIds;\n\t\t}\n\n\t\tswitch (entityType) {\n\t\t\tcase \"works\": {\n\t\t\t\tif (\"doi\" in entity && typeof entity.doi === \"string\" && entity.doi) {\n\t\t\t\t\texternalIds.push({\n\t\t\t\t\t\ttype: \"doi\",\n\t\t\t\t\t\tvalue: entity.doi,\n\t\t\t\t\t\turl: `https://doi.org/${entity.doi}`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"authors\": {\n\t\t\t\tif (\"orcid\" in entity && typeof entity.orcid === \"string\" && entity.orcid) {\n\t\t\t\t\texternalIds.push({\n\t\t\t\t\t\ttype: \"orcid\",\n\t\t\t\t\t\tvalue: entity.orcid,\n\t\t\t\t\t\turl: entity.orcid.startsWith(\"http\") ? entity.orcid : `https://orcid.org/${entity.orcid}`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"sources\": {\n\t\t\t\tif (\"issn_l\" in entity && typeof entity.issn_l === \"string\" && entity.issn_l) {\n\t\t\t\t\texternalIds.push({\n\t\t\t\t\t\ttype: \"issn_l\",\n\t\t\t\t\t\tvalue: entity.issn_l,\n\t\t\t\t\t\turl: `https://portal.issn.org/resource/ISSN/${entity.issn_l}`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"institutions\": {\n\t\t\t\tif (\"ror\" in entity && typeof entity.ror === \"string\" && entity.ror) {\n\t\t\t\t\texternalIds.push({\n\t\t\t\t\t\ttype: \"ror\",\n\t\t\t\t\t\tvalue: entity.ror,\n\t\t\t\t\t\turl: entity.ror.startsWith(\"http\") ? entity.ror : `https://ror.org/${entity.ror}`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn externalIds;\n\t}\n\n\t/**\n   * Get entity data for storage in GraphNode - no artificial metadata extraction\n   */\n\t/**\n\t * Type guard to safely convert OpenAlexEntity to Record<string, unknown>\n\t */\n\tprivate convertEntityToRecord(entity: OpenAlexEntity): Record<string, unknown> {\n\t\t// All OpenAlex entities are guaranteed to be objects with string keys\n\t\tif (typeof entity !== \"object\" || entity === null) {\n\t\t\tthrow new Error(\"Invalid entity data: entity must be a non-null object\");\n\t\t}\n\n\t\t// Type guard to ensure we have a valid record-like object\n\t\tfunction isRecord(value: unknown): value is Record<string, unknown> {\n\t\t\treturn typeof value === \"object\" && value !== null && !Array.isArray(value);\n\t\t}\n\n\t\tif (!isRecord(entity)) {\n\t\t\tthrow new Error(\"Entity is not a valid record object\");\n\t\t}\n\n\t\t// Use Object.assign to safely copy all enumerable properties\n\t\t// Safe since we've validated entity as a record-like object\n\t\treturn Object.assign({}, entity);\n\t}\n\n\tprivate getEntityData(entity: OpenAlexEntity): Record<string, unknown> {\n\t\t// Store the complete entity data - helper functions will extract what's needed on-demand\n\t\treturn this.convertEntityToRecord(entity);\n\t}\n\n\t/**\n   * Transform search results to graph nodes and edges\n   */\n\tprivate transformSearchResults(results: OpenAlexEntity[]): { nodes: GraphNode[]; edges: GraphEdge[] } {\n\t\tconst nodes: GraphNode[] = [];\n\t\tconst edges: GraphEdge[] = [];\n\n\t\tresults.forEach((entity, index) => {\n\t\t\tconst detection = this.detector.detectEntityIdentifier(entity.id);\n\n\t\t\tif (detection.entityType) {\n\t\t\t\tconst node = this.createNodeFromEntity(entity, detection.entityType);\n\t\t\t\t// Position nodes in a grid layout for search results\n\t\t\t\tconst cols = Math.ceil(Math.sqrt(results.length));\n\t\t\t\tconst row = Math.floor(index / cols);\n\t\t\t\tconst col = index % cols;\n\t\t\t\tnode.position = {\n\t\t\t\t\tx: col * 200 - (cols * 100),\n\t\t\t\t\ty: row * 150 - 75\n\t\t\t\t};\n\t\t\t\tnodes.push(node);\n\t\t\t}\n\t\t});\n\n\t\treturn { nodes, edges };\n\t}\n}\n\n/**\n * Factory function to create a GraphDataService instance\n */\nexport function createGraphDataService(queryClient: QueryClient): GraphDataService {\n\treturn new GraphDataService(queryClient);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/services/network-interceptor.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":59,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":61,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[2161,2259],"text":"NetworkInterceptor.instance ??= new NetworkInterceptor();"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":107,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":107,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3634,3636],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":246,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":246,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[7858,7860],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":259,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":259,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[8262,8264],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":316,"column":8,"nodeType":null,"messageId":"preferOptionalChain","endLine":316,"endColumn":63,"suggestions":[{"fix":{"range":[9707,9762],"text":"userAgent?.includes(\"data-fetching-worker\")"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":340,"column":38,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":340,"endColumn":54},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":342,"column":23,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":342,"endColumn":25,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[10524,10526],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Network request interceptor service\n * Globally monitors all HTTP requests and updates network activity store\n */\n\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { useNetworkActivityStore } from \"@/stores/network-activity-store\";\nimport type { NetworkRequest } from \"@/stores/network-activity-store\";\n\ninterface RequestContext {\n  id: string;\n  startTime: number;\n  url: string;\n  method: string;\n  type: NetworkRequest[\"type\"];\n  category: NetworkRequest[\"category\"];\n}\n\n/**\n * Global network interceptor for monitoring all HTTP requests\n */\nexport class NetworkInterceptor {\n\tprivate static instance: NetworkInterceptor | null = null;\n\tprivate originalFetch: typeof fetch;\n\tprivate originalXhrOpen: typeof XMLHttpRequest.prototype.open;\n\tprivate originalXhrSend: typeof XMLHttpRequest.prototype.send;\n\tprivate isInitialized = false;\n\tprivate activeRequests = new Map<string, RequestContext>();\n\tprivate xhrDataMap = new WeakMap<XMLHttpRequest, {\n\t\turl: string;\n\t\tmethod: string;\n\t\ttype: NetworkRequest[\"type\"];\n\t\tcategory: NetworkRequest[\"category\"];\n\t\trequestId?: string;\n\t}>();\n\n\tconstructor() {\n\t\t// Only initialize in browser environment\n\t\tif (typeof window !== \"undefined\" && typeof window.fetch === \"function\") {\n\t\t\tthis.originalFetch = window.fetch.bind(window);\n\t\t\tthis.originalXhrOpen = XMLHttpRequest.prototype.open.bind(XMLHttpRequest.prototype);\n\t\t\tthis.originalXhrSend = XMLHttpRequest.prototype.send.bind(XMLHttpRequest.prototype);\n\t\t} else {\n\t\t\t// Fallback for Node.js environment (tests)\n\t\t\tthis.originalFetch = (() => Promise.reject(new Error(\"fetch not available in Node.js\"))) satisfies typeof fetch;\n\t\t\tthis.originalXhrOpen = function(_method: string, _url: string | URL, _async?: boolean, _user?: string | null, _password?: string | null): void {\n\t\t\t\t// No-op for Node.js environment\n\t\t\t} satisfies typeof XMLHttpRequest.prototype.open;\n\t\t\tthis.originalXhrSend = function(_body?: Document | XMLHttpRequestBodyInit | null): void {\n\t\t\t\t// No-op for Node.js environment\n\t\t\t} satisfies typeof XMLHttpRequest.prototype.send;\n\t\t}\n\t}\n\n\t/**\n   * Get singleton instance\n   */\n\tstatic getInstance(): NetworkInterceptor {\n\t\tif (!NetworkInterceptor.instance) {\n\t\t\tNetworkInterceptor.instance = new NetworkInterceptor();\n\t\t}\n\t\treturn NetworkInterceptor.instance;\n\t}\n\n\t/**\n   * Initialize global request interception\n   */\n\tinitialize(): void {\n\t\tif (this.isInitialized) {\n\t\t\tlogger.warn(\"api\", \"Network interceptor already initialized\", {}, \"NetworkInterceptor\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Only initialize in browser environment\n\t\tif (typeof window !== \"undefined\" && typeof window.fetch === \"function\") {\n\t\t\tthis.interceptFetch();\n\t\t\tthis.interceptXHR();\n\t\t\tthis.isInitialized = true;\n\t\t\tlogger.debug(\"api\", \"Network interceptor initialized\", {}, \"NetworkInterceptor\");\n\t\t} else {\n\t\t\tlogger.warn(\"api\", \"Network interceptor skipped - not in browser environment\", {}, \"NetworkInterceptor\");\n\t\t}\n\t}\n\n\t/**\n   * Cleanup and restore original methods\n   */\n\tcleanup(): void {\n\t\tif (!this.isInitialized) return;\n\n\t\twindow.fetch = this.originalFetch;\n\t\tXMLHttpRequest.prototype.open = this.originalXhrOpen;\n\t\tXMLHttpRequest.prototype.send = this.originalXhrSend;\n\n\t\tthis.activeRequests.clear();\n\t\tthis.isInitialized = false;\n\n\t\tlogger.debug(\"api\", \"Network interceptor cleaned up\", {}, \"NetworkInterceptor\");\n\t}\n\n\t/**\n   * Intercept fetch requests\n   */\n\tprivate interceptFetch(): void {\n\t\twindow.fetch = (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n\t\t\tconst url = typeof input === \"string\" ? input : input instanceof URL ? input.toString() : input.url;\n\t\t\tconst method = init?.method || \"GET\";\n\n\t\t\tconst requestInfo = this.createRequestInfo(url, method, init?.headers);\n\t\t\tconst store = useNetworkActivityStore.getState();\n\n\t\t\tconst requestId = store.addRequest({\n\t\t\t\ttype: this.detectRequestType(url),\n\t\t\t\tcategory: this.detectRequestCategory(url, init?.headers),\n\t\t\t\turl,\n\t\t\t\tmethod,\n\t\t\t\tstatus: \"pending\",\n\t\t\t});\n\n\t\t\tthis.activeRequests.set(requestId, {\n\t\t\t\tid: requestId,\n\t\t\t\tstartTime: Date.now(),\n\t\t\t\turl,\n\t\t\t\tmethod,\n\t\t\t\ttype: requestInfo.type,\n\t\t\t\tcategory: requestInfo.category,\n\t\t\t});\n\n\t\t\treturn this.originalFetch(input, init)\n\t\t\t\t.then((response) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Calculate response size if possible\n\t\t\t\t\t\tconst contentLength = response.headers.get(\"content-length\");\n\t\t\t\t\t\tconst size = contentLength ? parseInt(contentLength, 10) : undefined;\n\n\t\t\t\t\t\tstore.completeRequest(requestId, response.status, size);\n\n\t\t\t\t\t\tlogger.debug(\"api\", \"Fetch request completed\", {\n\t\t\t\t\t\t\trequestId,\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\tstatus: response.status,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t}, \"NetworkInterceptor\");\n\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.warn(\"api\", \"Error processing fetch response\", {\n\t\t\t\t\t\t\trequestId,\n\t\t\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t\t\t}, \"NetworkInterceptor\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.activeRequests.delete(requestId);\n\t\t\t\t\treturn response;\n\t\t\t\t})\n\t\t\t\t.catch((error: unknown) => {\n\t\t\t\t\tstore.failRequest(\n\t\t\t\t\t\trequestId,\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t\t\t);\n\n\t\t\t\t\tlogger.error(\"api\", \"Fetch request failed\", {\n\t\t\t\t\t\trequestId,\n\t\t\t\t\t\turl,\n\t\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t\t}, \"NetworkInterceptor\");\n\n\t\t\t\t\tthis.activeRequests.delete(requestId);\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t};\n\t}\n\n\t/**\n   * Intercept XMLHttpRequest\n   */\n\tprivate interceptXHR(): void {\n\t\tconst originalOpen = this.originalXhrOpen;\n\t\tconst originalSend = this.originalXhrSend;\n\t\tconst createRequestInfo = this.createRequestInfo.bind(this);\n\t\tconst { activeRequests, xhrDataMap } = this;\n\n\t\tXMLHttpRequest.prototype.open = function(\n\t\t\tmethod: string,\n\t\t\turl: string | URL,\n\t\t\tasync?: boolean,\n\t\t\tuser?: string | null,\n\t\t\tpassword?: string | null\n\t\t) {\n\t\t\tconst urlString = typeof url === \"string\" ? url : url.toString();\n\t\t\tconst requestInfo = createRequestInfo(urlString, method);\n\n\t\t\t// Store request info using WeakMap for type safety\n\t\t\txhrDataMap.set(this, {\n\t\t\t\turl: urlString,\n\t\t\t\tmethod,\n\t\t\t\ttype: requestInfo.type,\n\t\t\t\tcategory: requestInfo.category,\n\t\t\t});\n\n\t\t\toriginalOpen.call(this, method, url, async ?? true, user, password);\n\t\t};\n\n\t\tXMLHttpRequest.prototype.send = function(body?: Document | XMLHttpRequestBodyInit | null) {\n\t\t\t// Access request data from WeakMap for type safety\n\t\t\tconst requestData = xhrDataMap.get(this);\n\n      if (requestData) {\n      \tconst store = useNetworkActivityStore.getState();\n      \tconst requestId = store.addRequest({\n      \t\ttype: requestData.type,\n      \t\tcategory: requestData.category,\n      \t\turl: requestData.url,\n      \t\tmethod: requestData.method,\n      \t\tstatus: \"pending\",\n      \t});\n\n      \tactiveRequests.set(requestId, {\n      \t\tid: requestId,\n      \t\tstartTime: Date.now(),\n      \t\turl: requestData.url,\n      \t\tmethod: requestData.method,\n      \t\ttype: requestData.type,\n      \t\tcategory: requestData.category,\n      \t});\n\n      \t// Store request ID in WeakMap for completion tracking\n      \tconst updatedData = { ...requestData, requestId };\n      \txhrDataMap.set(this, updatedData);\n\n      \t// Override readystatechange handler\n      \tconst originalReadyStateChange = this.onreadystatechange;\n      \tthis.onreadystatechange = function(event) {\n      \t\tif (this.readyState === 4) {\n      \t\t\t// Request completed\n      \t\t\t// Access request data from WeakMap for type safety\n      \t\t\tconst xhrData = xhrDataMap.get(this);\n      \t\t\tconst finalRequestId = xhrData?.requestId;\n      \t\t\tif (finalRequestId) {\n      \t\t\t\tif (this.status >= 200 && this.status < 300) {\n      \t\t\t\t\t// Calculate response size\n      \t\t\t\t\tconst responseSize = this.responseText ? this.responseText.length : 0;\n      \t\t\t\t\tstore.completeRequest(finalRequestId, this.status, responseSize);\n\n      \t\t\t\t\tlogger.debug(\"api\", \"XHR request completed\", {\n      \t\t\t\t\t\trequestId: finalRequestId,\n      \t\t\t\t\t\turl: xhrData?.url || \"unknown\",\n      \t\t\t\t\t\tstatus: this.status,\n      \t\t\t\t\t\tsize: responseSize\n      \t\t\t\t\t}, \"NetworkInterceptor\");\n      \t\t\t\t} else {\n      \t\t\t\t\tstore.failRequest(\n      \t\t\t\t\t\tfinalRequestId,\n      \t\t\t\t\t\tthis.statusText || \"Request failed\",\n      \t\t\t\t\t\tthis.status\n      \t\t\t\t\t);\n\n      \t\t\t\t\tlogger.error(\"api\", \"XHR request failed\", {\n      \t\t\t\t\t\trequestId: finalRequestId,\n      \t\t\t\t\t\turl: xhrData?.url || \"unknown\",\n      \t\t\t\t\t\tstatus: this.status,\n      \t\t\t\t\t\tstatusText: this.statusText\n      \t\t\t\t\t}, \"NetworkInterceptor\");\n      \t\t\t\t}\n\n      \t\t\t\tactiveRequests.delete(finalRequestId);\n      \t\t\t}\n      \t\t}\n\n      \t\t// Call original handler\n      \t\tif (originalReadyStateChange) {\n      \t\t\toriginalReadyStateChange.call(this, event);\n      \t\t}\n      \t};\n      }\n\n      originalSend.call(this, body);\n\t\t};\n\t}\n\n\t/**\n   * Create request info with type and category detection\n   */\n\tprivate createRequestInfo(url: string, _method: string, headers?: HeadersInit): {\n    type: NetworkRequest[\"type\"];\n    category: NetworkRequest[\"category\"];\n  } {\n\t\treturn {\n\t\t\ttype: this.detectRequestType(url),\n\t\t\tcategory: this.detectRequestCategory(url, headers),\n\t\t};\n\t}\n\n\t/**\n   * Detect request type based on URL\n   */\n\tprivate detectRequestType(url: string): NetworkRequest[\"type\"] {\n\t\tif (url.includes(\"openalex.org\") || url.includes(\"/api/\")) {\n\t\t\treturn \"api\";\n\t\t}\n\t\tif (url.includes(\"cache\") || url.includes(\"IndexedDB\")) {\n\t\t\treturn \"cache\";\n\t\t}\n\t\tif (url.includes(\"worker\") || url.includes(\".worker.\")) {\n\t\t\treturn \"worker\";\n\t\t}\n\t\treturn \"resource\";\n\t}\n\n\t/**\n   * Detect request category (foreground vs background)\n   */\n\tprivate detectRequestCategory(url: string, headers?: HeadersInit): NetworkRequest[\"category\"] {\n\t\t// Check for worker User-Agent first\n\t\tif (headers) {\n\t\t\tconst userAgent = this.getHeaderValue(headers, \"User-Agent\");\n\t\t\tif (userAgent && userAgent.includes(\"data-fetching-worker\")) {\n\t\t\t\treturn \"background\";\n\t\t\t}\n\t\t}\n\n\t\t// Consider API requests as foreground by default\n\t\t// Background requests are typically cache operations or worker communications\n\t\tif (url.includes(\"cache\") || url.includes(\"worker\")) {\n\t\t\treturn \"background\";\n\t\t}\n\t\treturn \"foreground\";\n\t}\n\n\t/**\n   * Get header value from HeadersInit (Headers, Record, or array)\n   */\n\tprivate getHeaderValue(headers: HeadersInit, key: string): string | null {\n\t\tif (headers instanceof Headers) {\n\t\t\treturn headers.get(key);\n\t\t}\n\t\tif (Array.isArray(headers)) {\n\t\t\tconst found = headers.find(([k]) => k.toLowerCase() === key.toLowerCase());\n\t\t\treturn found ? found[1] : null;\n\t\t}\n\t\tif (typeof headers === \"object\" && headers !== null) {\n\t\t\tconst record = headers;\n\t\t\treturn record[key] || null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n   * Track cache operation (called externally by cache services)\n   */\n\ttrackCacheOperation(\n\t\toperation: \"read\" | \"write\" | \"delete\",\n\t\tkey: string,\n\t\thit: boolean,\n\t\tsize?: number\n\t): void {\n\t\tconst store = useNetworkActivityStore.getState();\n\n\t\tconst requestId = store.addRequest({\n\t\t\ttype: \"cache\",\n\t\t\tcategory: \"background\",\n\t\t\turl: `cache://${operation}/${key}`,\n\t\t\tmethod: operation.toUpperCase(),\n\t\t\tstatus: hit ? \"cached\" : \"success\",\n\t\t\tmetadata: {\n\t\t\t\tfromCache: hit,\n\t\t\t},\n\t\t});\n\n\t\t// Complete immediately for cache operations\n\t\tstore.completeRequest(requestId, 200, size);\n\n\t\tlogger.debug(\"cache\", \"Cache operation tracked\", {\n\t\t\trequestId,\n\t\t\toperation,\n\t\t\tkey,\n\t\t\thit,\n\t\t\tsize\n\t\t}, \"NetworkInterceptor\");\n\t}\n\n\t/**\n   * Track worker operation (called externally by worker services)\n   */\n\ttrackWorkerOperation(\n\t\toperation: string,\n\t\tdata?: unknown,\n\t\tentityType?: string,\n\t\tentityId?: string\n\t): string {\n\t\tconst store = useNetworkActivityStore.getState();\n\n\t\tconst requestId = store.addRequest({\n\t\t\ttype: \"worker\",\n\t\t\tcategory: \"background\",\n\t\t\turl: `worker://${operation}`,\n\t\t\tmethod: \"POST\",\n\t\t\tstatus: \"pending\",\n\t\t\t...(entityType && { metadata: {\n\t\t\t\tentityType,\n\t\t\t\t...(entityId && { entityId }),\n\t\t\t}}),\n\t\t});\n\n\t\tlogger.debug(\"api\", \"Worker operation started\", {\n\t\t\trequestId,\n\t\t\toperation,\n\t\t\tentityType,\n\t\t\tentityId\n\t\t}, \"NetworkInterceptor\");\n\n\t\treturn requestId;\n\t}\n\n\t/**\n   * Track request deduplication\n   */\n\ttrackDeduplication(url: string, entityId?: string): void {\n\t\tconst store = useNetworkActivityStore.getState();\n\n\t\tstore.addRequest({\n\t\t\ttype: \"api\",\n\t\t\tcategory: \"foreground\",\n\t\t\turl,\n\t\t\tmethod: \"GET\",\n\t\t\tstatus: \"deduplicated\",\n\t\t\tmetadata: {\n\t\t\t\tdeduplicated: true,\n\t\t\t\t...(entityId && { entityId }),\n\t\t\t},\n\t\t});\n\n\t\tlogger.debug(\"cache\", \"Request deduplication tracked\", {\n\t\t\turl,\n\t\t\tentityId\n\t\t}, \"NetworkInterceptor\");\n\t}\n\n\t/**\n   * Get current statistics\n   */\n\tgetStats(): {\n    activeRequests: number;\n    totalTracked: number;\n    isInitialized: boolean;\n    } {\n\t\treturn {\n\t\t\tactiveRequests: this.activeRequests.size,\n\t\t\ttotalTracked: this.activeRequests.size,\n\t\t\tisInitialized: this.isInitialized,\n\t\t};\n\t}\n}\n\n/**\n * Global instance for easy access\n */\nexport const networkInterceptor = NetworkInterceptor.getInstance();\n\n/**\n * Helper functions for external services\n */\nexport const trackCacheOperation = (\n\toperation: \"read\" | \"write\" | \"delete\",\n\tkey: string,\n\thit: boolean,\n\tsize?: number\n) => { networkInterceptor.trackCacheOperation(operation, key, hit, size); };\n\nexport const trackWorkerOperation = (\n\toperation: string,\n\tdata?: unknown,\n\tentityType?: string,\n\tentityId?: string\n) => networkInterceptor.trackWorkerOperation(operation, data, entityType, entityId);\n\nexport const trackDeduplication = (url: string, entityId?: string) =>\n{ networkInterceptor.trackDeduplication(url, entityId); };\n\n/**\n * Initialize network monitoring (call this in app initialization)\n */\nexport const initializeNetworkMonitoring = () => {\n\tnetworkInterceptor.initialize();\n};\n\n/**\n * Cleanup network monitoring (call this in app cleanup)\n */\nexport const cleanupNetworkMonitoring = () => {\n\tnetworkInterceptor.cleanup();\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/services/relationship-detection-service.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":71,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":71,"endColumn":16,"suggestions":[{"fix":{"range":[2443,2543],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":73,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":73,"endColumn":17},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":201,"column":8,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":201,"endColumn":16},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":253,"column":8,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":253,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":272,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":272,"endColumn":97},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":272,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9539,9542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9539,9542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .referenced_works on an `any` value.","line":272,"column":69,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":272,"endColumn":85},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":281,"column":12,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":281,"endColumn":30},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":283,"column":12,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":283,"endColumn":35},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":291,"column":12,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":291,"endColumn":31},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":320,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":320,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[10974,10976],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":358,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":358,"endColumn":16,"suggestions":[{"fix":{"range":[12512,12589],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":404,"column":11,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":404,"endColumn":36},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":420,"column":60,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":420,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[14748,14750],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":428,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15169,15172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15169,15172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .referenced_works on an `any` value.","line":428,"column":63,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":428,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":429,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":429,"endColumn":79},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":429,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":429,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15251,15254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15251,15254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .referenced_works on an `any` value.","line":429,"column":63,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":429,"endColumn":79},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":472,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":472,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[16525,16527],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Detection Service\n * Automatically detects and creates relationships between newly added nodes and existing graph nodes\n */\n\nimport { QueryClient } from \"@tanstack/react-query\";\nimport { cachedOpenAlex } from \"@academic-explorer/client\";\nimport { EntityDetector } from \"@academic-explorer/graph\";\nimport { useGraphStore } from \"@/stores/graph-store\";\nimport { logError, logger } from \"@academic-explorer/utils/logger\";\nimport { isWork, isAuthor, isSource, isInstitution, isNonNull } from \"@academic-explorer/client\";\nimport { RequestDeduplicationService, createRequestDeduplicationService } from \"./request-deduplication-service\";\nimport type {\n\tGraphNode,\n\tGraphEdge,\n\tEntityType,\n} from \"@academic-explorer/graph\";\nimport { RelationType } from \"@academic-explorer/graph\";\nimport type {\n\tOpenAlexEntity,\n} from \"@academic-explorer/client\";\nimport { ADVANCED_FIELD_SELECTIONS, type AdvancedEntityFieldSelections } from \"@academic-explorer/client\";\n\n/**\n * Minimal entity data needed for relationship detection\n * Contains only the essential fields to determine relationships\n */\ninterface MinimalEntityData {\n\tid: string;\n\tentityType: EntityType;\n\tdisplay_name: string;\n\tauthorships?: Array<{ author: { id: string; display_name: string } }>;\n\tprimary_location?: { source?: { id: string; display_name: string } };\n\treferenced_works?: string[];\n\taffiliations?: Array<{ institution: { id: string; display_name: string } }>;\n\tlineage?: string[];\n\tpublisher?: string;\n}\n\n/**\n * Detected relationship between nodes\n */\ninterface DetectedRelationship {\n\tsourceNodeId: string;\n\ttargetNodeId: string;\n\trelationType: RelationType;\n\tlabel: string;\n\tweight?: number;\n\tmetadata?: Record<string, unknown>;\n}\n\n/**\n * Service for automatically detecting relationships between newly added nodes and existing graph nodes\n */\nexport class RelationshipDetectionService {\n\tprivate detector: EntityDetector;\n\tprivate queryClient: QueryClient;\n\tprivate deduplicationService: RequestDeduplicationService;\n\n\tconstructor(queryClient: QueryClient) {\n\t\tthis.detector = new EntityDetector();\n\t\tthis.queryClient = queryClient;\n\t\tthis.deduplicationService = createRequestDeduplicationService(queryClient);\n\t}\n\n\t/**\n\t * Detect and create relationships for multiple nodes in batch\n\t * Uses two-pass approach to find relationships between nodes added in the same batch\n\t */\n  async detectRelationshipsForNodes(nodeIds: string[]): Promise<GraphEdge[]> {\n    console.log(\"DEBUG: detectRelationshipsForNodes called with\", nodeIds.length, \"node IDs:\", nodeIds);\n\n    if (!nodeIds || nodeIds.length === 0) return [];\n\n    logger.debug(\"graph\", \"STARTING batch relationship detection with two-pass approach\", {\n      nodeCount: nodeIds.length,\n      nodeIds\n    }, \"RelationshipDetectionService\");\n\n\t\t// Log the node types being processed\n\t\tconst store = useGraphStore.getState();\n\t\tconst nodeTypes = nodeIds.map(id => {\n\t\t\tconst node = store.getNode(id);\n\t\t\treturn node ? `${id}(${node.type})` : `${id}(not found)`;\n\t\t});\n\t\tlogger.debug(\"graph\", \"Processing nodes by type\", {\n\t\t\tnodeTypes\n\t\t}, \"RelationshipDetectionService\");\n\n\t\tconst allNewEdges: GraphEdge[] = [];\n\n\t\t// Two-pass approach:\n\t\t// Pass 1: Process each node individually (finds relationships with pre-existing nodes)\n\t\tfor (const nodeId of nodeIds) {\n\t\t\ttry {\n\t\t\t\tconst edges = await this.detectRelationshipsForNode(nodeId);\n\t\t\t\tallNewEdges.push(...edges);\n\t\t\t} catch (error) {\n\t\t\t\tlogError(logger, \"Failed to detect relationships for node in batch pass 1\", error, \"RelationshipDetectionService\", \"graph\");\n\t\t\t}\n\t\t}\n\n\t\t// Pass 2: Re-check all nodes for relationships with each other (cross-batch relationships)\n\t\tlogger.debug(\"graph\", \"Starting pass 2: cross-batch relationship detection\", {\n\t\t\tnodeCount: nodeIds.length\n\t\t}, \"RelationshipDetectionService\");\n\n\t\tfor (const nodeId of nodeIds) {\n\t\t\ttry {\n\t\t\t\tconst crossBatchEdges = await this.detectCrossBatchRelationships(nodeId, nodeIds);\n\t\t\t\tallNewEdges.push(...crossBatchEdges);\n\t\t\t} catch (error) {\n\t\t\t\tlogError(logger, \"Failed to detect cross-batch relationships for node\", error, \"RelationshipDetectionService\", \"graph\");\n\t\t\t}\n\t\t}\n\n\t\t// Remove duplicate edges (same source-target-type combinations)\n\t\tconst uniqueEdges = this.deduplicateEdges(allNewEdges);\n\n\t\tlogger.debug(\"graph\", \"Batch relationship detection completed\", {\n\t\t\tprocessedNodeCount: nodeIds.length,\n\t\t\ttotalEdgesCreated: uniqueEdges.length,\n\t\t\tduplicatesRemoved: allNewEdges.length - uniqueEdges.length\n\t\t}, \"RelationshipDetectionService\");\n\n\t\treturn uniqueEdges;\n\t}\n\n\t/**\n\t * Detect and create relationships for a newly added node\n\t * Fetches minimal data and analyzes relationships with existing nodes\n\t */\n\tasync detectRelationshipsForNode(nodeId: string): Promise<GraphEdge[]> {\n\t\tconst store = useGraphStore.getState();\n\n\t\t// Try to find the node using the provided nodeId, and also try normalizing it\n\t\tlet newNode = store.getNode(nodeId);\n\n\t\t// If not found and nodeId is a full URL, try extracting just the ID part\n\t\tif (!newNode && nodeId.includes(\"openalex.org/\")) {\n\t\t\tconst shortId = nodeId.split(\"/\").pop();\n\t\t\tif (shortId) {\n\t\t\t\tnewNode = store.getNode(shortId);\n\t\t\t}\n\t\t}\n\n\t\t// If still not found, try checking entityId field\n\t\tif (!newNode) {\n\t\t\tconst allNodes = Object.values(store.nodes).filter(node => node != null);\n\t\t\tnewNode = allNodes.find(node => node.entityId === nodeId || node.id === nodeId);\n\t\t}\n\n\t\tif (!newNode) {\n\t\t\tlogger.warn(\"graph\", \"Node not found for relationship detection\", {\n\t\t\t\tnodeId,\n\t\t\t\tavailableNodeCount: Object.keys(store.nodes).length\n\t\t\t}, \"RelationshipDetectionService\");\n\t\t\treturn [];\n\t\t}\n\n\t\t// Note: We fetch relationship data on-demand, so hydration level doesn't matter\n\t\t// The relationship detection service will fetch the minimal data needed regardless\n\n\t\ttry {\n\t\t\tlogger.debug(\"graph\", \"Starting relationship detection for node\", {\n\t\t\t\tnodeId,\n\t\t\t\tentityType: newNode.type,\n\t\t\t\tlabel: newNode.label\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\t// Fetch minimal entity data\n\t\t\tconst minimalData = await this.fetchMinimalEntityData(newNode.entityId, newNode.type);\n\n\t\t\tif (!minimalData) {\n\t\t\t\tlogger.warn(\"graph\", \"Could not fetch minimal data for relationship detection\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tentityId: newNode.entityId\n\t\t\t\t}, \"RelationshipDetectionService\");\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get all existing nodes in the graph\n\t\t\tconst existingNodes = Object.values(store.nodes).filter(isNonNull).filter(node => node.id !== nodeId);\n\n\t\t\t// Detect relationships with existing nodes\n\t\t\tconst detectedRelationships = await this.analyzeRelationships(minimalData, existingNodes);\n\n\t\t\tlogger.debug(\"graph\", \"Relationship detection completed\", {\n\t\t\t\tnodeId,\n\t\t\t\tdetectedCount: detectedRelationships.length,\n\t\t\t\trelationships: detectedRelationships.map(r => ({\n\t\t\t\t\ttarget: r.targetNodeId,\n\t\t\t\t\ttype: r.relationType\n\t\t\t\t}))\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\t// Convert detected relationships to graph edges\n\t\t\tconst newEdges = this.createEdgesFromRelationships(detectedRelationships);\n\n\t\t\t// Add edges to the graph store\n\t\t\tif (newEdges && newEdges.length > 0) {\n\t\t\t\tstore.addEdges(newEdges);\n\t\t\t\tlogger.debug(\"graph\", \"Added relationship edges to graph\", {\n\t\t\t\t\tnodeId,\n\t\t\t\t\tedgeCount: newEdges.length,\n\t\t\t\t\tedgeIds: newEdges.map(e => e.id)\n\t\t\t\t}, \"RelationshipDetectionService\");\n\t\t\t}\n\n\t\t\treturn newEdges;\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to detect relationships for node\", error, \"RelationshipDetectionService\", \"graph\");\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Fetch minimal entity data required for relationship detection\n\t * Uses field selection to minimize API response size and improve performance\n\t */\n\tprivate async fetchMinimalEntityData(entityId: string, entityType: EntityType): Promise<MinimalEntityData | null> {\n\t\ttry {\n\t\t\t// Use advanced type-safe field selections with full path inference\n\t\t\tconst fieldsMap: AdvancedEntityFieldSelections = {\n\t\t\t\tworks: ADVANCED_FIELD_SELECTIONS.works.minimal,\n\t\t\t\tauthors: ADVANCED_FIELD_SELECTIONS.authors.minimal,\n\t\t\t\tsources: ADVANCED_FIELD_SELECTIONS.sources.minimal,\n\t\t\t\tinstitutions: ADVANCED_FIELD_SELECTIONS.institutions.minimal,\n\t\t\t\tconcepts: ADVANCED_FIELD_SELECTIONS.concepts.minimal,\n\t\t\t\ttopics: ADVANCED_FIELD_SELECTIONS.topics.minimal,\n\t\t\t\tpublishers: ADVANCED_FIELD_SELECTIONS.publishers.minimal,\n\t\t\t\tfunders: ADVANCED_FIELD_SELECTIONS.funders.minimal,\n\t\t\t\tkeywords: [\"id\", \"display_name\"] // Keywords don't have strict typing yet\n\t\t\t};\n\n\t\t\tconst selectFields = fieldsMap[entityType];\n\n\t\t\t// Deduplication service is always initialized in constructor\n\n\t\t\t// Fetch entity with minimal fields using deduplication service\n\t\t\tconst entity = await this.deduplicationService.getEntity(\n\t\t\t\tentityId,\n\t\t\t\t() => this.fetchEntityWithSelect(entityId, entityType, selectFields)\n\t\t\t);\n\n\t\t\tlogger.debug(\"graph\", \"Entity fetch result\", {\n\t\t\t\tentityId,\n\t\t\t\tentityFetched: !!entity\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\t// Check if entity exists before accessing its properties\n\t\t\tif (!entity) {\n\t\t\t\tlogger.debug(\"graph\", \"Entity not found or could not be fetched\", {\n\t\t\t\t\tentityId,\n\t\t\t\t\tentityType\n\t\t\t\t}, \"RelationshipDetectionService\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Transform to minimal data format with null checks\n\t\t\tconst minimalData: MinimalEntityData = {\n\t\t\t\tid: entity.id || \"\",\n\t\t\t\tentityType,\n\t\t\t\tdisplay_name: entity.display_name || \"\"\n\t\t\t};\n\n\t\t\tlogger.debug(\"graph\", \"Entity fetched with fields\", {\n\t\t\t\tentityId,\n\t\t\t\tentityType,\n\t\t\t\thasReferencedWorks: \"referenced_works\" in entity,\n\t\t\t\treferencedWorks: \"referenced_works\" in entity ? (entity as any).referenced_works : undefined,\n\t\t\t\tentityKeys: Object.keys(entity)\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\t// Add type-specific fields\n\t\t\tswitch (entityType) {\n\t\t\t\tcase \"works\": {\n\t\t\t\t\tif (isWork(entity)) {\n\t\t\t\t\t\tObject.assign(minimalData, {\n\t\t\t\t\t\t\t...(entity.authorships && { authorships: entity.authorships }),\n\t\t\t\t\t\t\t...(entity.primary_location && { primary_location: entity.primary_location }),\n\t\t\t\t\t\t\t...(entity.referenced_works && { referenced_works: entity.referenced_works })\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"authors\": {\n\t\t\t\t\tif (isAuthor(entity)) {\n\t\t\t\t\t\tObject.assign(minimalData, {\n\t\t\t\t\t\t\t...(entity.affiliations && { affiliations: entity.affiliations })\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"sources\": {\n\t\t\t\t\tif (isSource(entity)) {\n\t\t\t\t\t\tObject.assign(minimalData, {\n\t\t\t\t\t\t\t...(entity.publisher && { publisher: entity.publisher })\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"institutions\": {\n\t\t\t\t\tif (isInstitution(entity)) {\n\t\t\t\t\t\tObject.assign(minimalData, {\n\t\t\t\t\t\t\t...(entity.lineage && { lineage: entity.lineage })\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.debug(\"graph\", \"Minimal entity data fetched successfully\", {\n\t\t\t\tentityId,\n\t\t\t\tentityType,\n\t\t\t\thasAuthorships: !!minimalData.authorships?.length,\n\t\t\t\thasAffiliations: !!minimalData.affiliations?.length,\n\t\t\t\thasReferences: !!minimalData.referenced_works?.length,\n\t\t\t\treferencedWorksCount: minimalData.referenced_works?.length || 0\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\treturn minimalData;\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to fetch minimal entity data\", error, \"RelationshipDetectionService\", \"graph\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Analyze relationships between the new entity and existing graph nodes\n\t */\n\tprivate async analyzeRelationships(newEntityData: MinimalEntityData, existingNodes: GraphNode[]): Promise<DetectedRelationship[]> {\n\t\tconst relationships: DetectedRelationship[] = [];\n\n\t\tlogger.debug(\"graph\", \"Analyzing relationships\", {\n\t\t\tnewEntityId: newEntityData.id,\n\t\t\tnewEntityType: newEntityData.entityType,\n\t\t\texistingNodeCount: existingNodes.length\n\t\t}, \"RelationshipDetectionService\");\n\n\t\tlogger.debug(\"graph\", \"Processing entity for relationships\", {\n\t\t\tentityId: newEntityData.id,\n\t\t\tentityType: newEntityData.entityType,\n\t\t\thasReferencedWorks: \"referenced_works\" in newEntityData && !!newEntityData.referenced_works,\n\t\t\treferencedWorksCount: (\"referenced_works\" in newEntityData && Array.isArray(newEntityData.referenced_works)) ? newEntityData.referenced_works.length : 0,\n\t\t\texistingNodeIds: existingNodes.map(n => n.entityId || n.id)\n\t\t}, \"RelationshipDetectionService\");\n\n\t\t// Analyze relationships based on entity type\n\t\tswitch (newEntityData.entityType) {\n\t\t\tcase \"works\":\n\t\t\t\tlogger.debug(\"graph\", \"About to analyze work relationships\", {\n\t\t\t\t\tworkId: newEntityData.id,\n\t\t\t\t\thasReferencedWorks: \"referenced_works\" in newEntityData && !!newEntityData.referenced_works\n\t\t\t\t}, \"RelationshipDetectionService\");\n\t\t\t\tconsole.log(\"DEBUG: Calling analyzeWorkRelationships for\", newEntityData.id);\n\t\t\t\trelationships.push(...await this.analyzeWorkRelationships(newEntityData, existingNodes));\n\t\t\t\tbreak;\n\t\t\tcase \"authors\":\n\t\t\t\trelationships.push(...this.analyzeAuthorRelationships(newEntityData, existingNodes));\n\t\t\t\tbreak;\n\t\t\tcase \"sources\":\n\t\t\t\trelationships.push(...this.analyzeSourceRelationships(newEntityData, existingNodes));\n\t\t\t\tbreak;\n\t\t\tcase \"institutions\":\n\t\t\t\trelationships.push(...this.analyzeInstitutionRelationships(newEntityData, existingNodes));\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Deduplicate relationship types using Record pattern\n\t\tconst relationshipTypesRecord: Record<string, boolean> = {};\n\t\tfor (const relationship of relationships) {\n\t\t\trelationshipTypesRecord[relationship.relationType] = true;\n\t\t}\n\t\tconst uniqueRelationshipTypes = Object.keys(relationshipTypesRecord);\n\n\t\tlogger.debug(\"graph\", \"Relationship analysis completed\", {\n\t\t\tnewEntityId: newEntityData.id,\n\t\t\tdetectedCount: relationships.length,\n\t\t\trelationshipTypes: uniqueRelationshipTypes\n\t\t}, \"RelationshipDetectionService\");\n\n\t\treturn relationships;\n\t}\n\n\t/**\n\t * Analyze relationships for a Work entity\n\t */\n\t/**\n\t * Fetch referenced_works for a work entity if not already present\n\t */\n\tprivate async fetchReferencedWorksForWork(workId: string): Promise<string[] | null> {\n\t\ttry {\n\t\t\tlogger.debug(\"graph\", \"Fetching referenced_works for work entity\", {\n\t\t\t\tworkId\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\tconst workData = await cachedOpenAlex.client.works.getWork(workId, {\n\t\t\t\tselect: [\"id\", \"referenced_works\"]\n\t\t\t});\n\n\t\t\treturn workData.referenced_works || [];\n\t\t} catch (error) {\n\t\t\tlogger.error(\"graph\", \"Failed to fetch referenced_works for work\", {\n\t\t\t\tworkId,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\"\n\t\t\t}, \"RelationshipDetectionService\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate async analyzeWorkRelationships(workData: MinimalEntityData, existingNodes: GraphNode[]): Promise<DetectedRelationship[]> {\n\t\tconst relationships: DetectedRelationship[] = [];\n\n\t\tlogger.debug(\"graph\", \"Analyzing work relationships\", {\n\t\t\tworkId: workData.id,\n\t\t\thasReferencedWorks: !!workData.referenced_works,\n\t\t\treferencedWorksCount: workData.referenced_works?.length || 0,\n\t\t\texistingNodesCount: existingNodes.length\n\t\t}, \"RelationshipDetectionService\");\n\n\t\t// If referenced_works is not available in the fetched data, try to get it from the graph node data\n\t\tif (!workData.referenced_works) {\n\t\t\tconst store = useGraphStore.getState();\n\t\t\tconst graphNode = Object.values(store.nodes).find(node => node?.entityId === workData.id);\n\t\t\tif (graphNode?.entityData && (graphNode.entityData as any).referenced_works) {\n\t\t\t\tworkData.referenced_works = (graphNode.entityData as any).referenced_works;\n\t\t\t}\n\t\t}\n\n\t\t// Check for author relationships\n\t\tif (workData.authorships) {\n\t\t\tfor (const authorship of workData.authorships) {\n\t\t\t\tconst authorNode = existingNodes.find(node =>\n\t\t\t\t\tnode.entityId === authorship.author.id || node.id === authorship.author.id\n\t\t\t\t);\n\t\t\t\tif (authorNode) {\n\t\t\t\t\trelationships.push({\n\t\t\t\t\t\tsourceNodeId: authorship.author.id,\n\t\t\t\t\t\ttargetNodeId: workData.id,\n\t\t\t\t\t\trelationType: RelationType.AUTHORED,\n\t\t\t\t\t\tlabel: \"authored\",\n\t\t\t\t\t\tweight: 1.0\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check for source/journal relationships\n\t\tif (workData.primary_location?.source) {\n\t\t\tconst sourceId = workData.primary_location.source.id;\n\t\t\tconst sourceNode = existingNodes.find(node =>\n\t\t\t\tnode.entityId === sourceId || node.id === sourceId\n\t\t\t);\n\t\t\tif (sourceNode) {\n\t\t\t\trelationships.push({\n\t\t\t\t\tsourceNodeId: workData.id,\n\t\t\t\t\ttargetNodeId: sourceId,\n\t\t\t\t\trelationType: RelationType.PUBLISHED_IN,\n\t\t\t\t\tlabel: \"published in\"\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Check for citation relationships - fetch referenced_works if not present\n\t\tlet referencedWorks = workData.referenced_works;\n\t\tlogger.debug(\"graph\", \"Checking referenced_works\", {\n\t\t\tworkId: workData.id,\n\t\t\thasReferencedWorks: !!referencedWorks,\n\t\t\treferencedWorksLength: referencedWorks?.length || 0\n\t\t}, \"RelationshipDetectionService\");\n\n\t\tif (!referencedWorks) {\n\t\t\tlogger.debug(\"graph\", \"Work entity missing referenced_works, fetching from API\", {\n\t\t\t\tworkId: workData.id\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\tconst fetchedReferencedWorks = await this.fetchReferencedWorksForWork(workData.id);\n\t\t\tif (fetchedReferencedWorks) {\n\t\t\t\treferencedWorks = fetchedReferencedWorks;\n\t\t\t\tlogger.debug(\"graph\", \"Successfully fetched referenced_works for work\", {\n\t\t\t\t\tworkId: workData.id,\n\t\t\t\t\treferencedWorksCount: referencedWorks.length\n\t\t\t\t}, \"RelationshipDetectionService\");\n\t\t\t} else {\n\t\t\t\tlogger.debug(\"graph\", \"Failed to fetch referenced_works\", {\n\t\t\t\t\tworkId: workData.id\n\t\t\t\t}, \"RelationshipDetectionService\");\n\t\t\t}\n\t\t}\n\n\t\tif (referencedWorks && referencedWorks.length > 0) {\n\t\t\tlogger.debug(\"graph\", \"Analyzing citation relationships\", {\n\t\t\t\tworkId: workData.id,\n\t\t\t\treferencedWorksCount: referencedWorks.length\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\tfor (const referencedWorkId of referencedWorks) {\n\t\t\t\t// Both referenced_works and node IDs use full URL format, so direct comparison should work\n\t\t\t\tconst referencedNode = existingNodes.find(node =>\n\t\t\t\t\tnode.entityId === referencedWorkId || node.id === referencedWorkId\n\t\t\t\t);\n\n\t\t\t\tif (referencedNode) {\n\t\t\t\t\tlogger.debug(\"graph\", \"Found citation relationship\", {\n\t\t\t\t\t\tsourceWork: workData.id,\n\t\t\t\t\t\ttargetWork: referencedWorkId,\n\t\t\t\t\t\trelationshipType: RelationType.REFERENCES\n\t\t\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\t\t\trelationships.push({\n\t\t\t\t\t\tsourceNodeId: workData.id,\n\t\t\t\t\t\ttargetNodeId: referencedWorkId, // Use the entity ID to match the expected pattern\n\t\t\t\t\t\trelationType: RelationType.REFERENCES,\n\t\t\t\t\t\tlabel: \"references\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn relationships;\n\t}\n\n\t/**\n\t * Analyze relationships for an Author entity\n\t */\n\tprivate analyzeAuthorRelationships(authorData: MinimalEntityData, existingNodes: GraphNode[]): DetectedRelationship[] {\n\t\tconst relationships: DetectedRelationship[] = [];\n\n\t\t// Check for institutional affiliations\n\t\tif (authorData.affiliations) {\n\t\t\tfor (const affiliation of authorData.affiliations) {\n\t\t\t\tconst institutionNode = existingNodes.find(node =>\n\t\t\t\t\tnode.entityId === affiliation.institution.id || node.id === affiliation.institution.id\n\t\t\t\t);\n\t\t\t\tif (institutionNode) {\n\t\t\t\t\trelationships.push({\n\t\t\t\t\t\tsourceNodeId: authorData.id,\n\t\t\t\t\t\ttargetNodeId: affiliation.institution.id,\n\t\t\t\t\t\trelationType: RelationType.AFFILIATED,\n\t\t\t\t\t\tlabel: \"affiliated with\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check existing works for authorship relationships\n\t\t// Note: We would need to fetch work data to check authorships, but that would be expensive\n\t\t// This is better handled when the work is added and analyzes its authors\n\n\t\treturn relationships;\n\t}\n\n\t/**\n\t * Analyze relationships for a Source entity\n\t */\n\tprivate analyzeSourceRelationships(sourceData: MinimalEntityData, existingNodes: GraphNode[]): DetectedRelationship[] {\n\t\tconst relationships: DetectedRelationship[] = [];\n\n\t\t// Check for publisher relationships\n\t\tif (sourceData.publisher) {\n\t\t\tconst publisherNode = existingNodes.find(node =>\n\t\t\t\tnode.entityId === sourceData.publisher || node.id === sourceData.publisher\n\t\t\t);\n\t\t\tif (publisherNode) {\n\t\t\t\trelationships.push({\n\t\t\t\t\tsourceNodeId: sourceData.id,\n\t\t\t\t\ttargetNodeId: sourceData.publisher,\n\t\t\t\t\trelationType: RelationType.SOURCE_PUBLISHED_BY,\n\t\t\t\t\tlabel: \"published by\"\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Check existing works for publication relationships\n\t\t// Note: We would need to fetch work data to check primary_location.source\n\t\t// This is better handled when the work is added and analyzes its source\n\n\t\treturn relationships;\n\t}\n\n\t/**\n\t * Analyze relationships for an Institution entity\n\t */\n\tprivate analyzeInstitutionRelationships(institutionData: MinimalEntityData, existingNodes: GraphNode[]): DetectedRelationship[] {\n\t\tconst relationships: DetectedRelationship[] = [];\n\n\t\t// Check for parent institution relationships\n\t\tif (institutionData.lineage) {\n\t\t\tfor (const parentId of institutionData.lineage) {\n\t\t\t\tif (parentId !== institutionData.id) {\n\t\t\t\t\tconst parentNode = existingNodes.find(node =>\n\t\t\t\t\t\tnode.entityId === parentId || node.id === parentId\n\t\t\t\t\t);\n\t\t\t\t\tif (parentNode) {\n\t\t\t\t\t\trelationships.push({\n\t\t\t\t\t\t\tsourceNodeId: institutionData.id,\n\t\t\t\t\t\t\ttargetNodeId: parentId,\n\t\t\t\t\t\t\trelationType: RelationType.INSTITUTION_CHILD_OF,\n\t\t\t\t\t\t\tlabel: \"child of\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn relationships;\n\t}\n\n\t/**\n\t * Fetch entity without field selection (for debugging)\n\t */\n\tprivate async fetchEntityWithoutSelect(entityId: string, entityType: EntityType): Promise<OpenAlexEntity> {\n\t\tswitch (entityType) {\n\t\t\tcase \"works\":\n\t\t\t\treturn cachedOpenAlex.client.works.getWork(entityId);\n\t\t\tcase \"authors\":\n\t\t\t\treturn cachedOpenAlex.client.authors.getAuthor(entityId);\n\t\t\tcase \"sources\":\n\t\t\t\treturn cachedOpenAlex.client.sources.getSource(entityId);\n\t\t\tcase \"institutions\":\n\t\t\t\treturn cachedOpenAlex.client.institutions.getInstitution(entityId);\n\t\t\tcase \"topics\":\n\t\t\t\treturn cachedOpenAlex.client.topics.get(entityId);\n\t\t\tcase \"publishers\":\n\t\t\t\treturn cachedOpenAlex.client.publishers.get(entityId);\n\t\t\tcase \"funders\":\n\t\t\t\treturn cachedOpenAlex.client.funders.get(entityId);\n\t\t\tcase \"keywords\":\n\t\t\t\treturn cachedOpenAlex.client.keywords.getKeyword(entityId);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported entity type: ${entityType}`);\n\t\t}\n\t}\n\n\t/**\n\t * Fetch entity with field selection based on entity type\n\t */\n\tprivate async fetchEntityWithSelect(entityId: string, entityType: EntityType, selectFields: string[]): Promise<OpenAlexEntity> {\n\t\tconst params = { select: selectFields };\n\n\t\tswitch (entityType) {\n\t\t\tcase \"works\":\n\t\t\t\treturn cachedOpenAlex.client.works.getWork(entityId, params);\n\t\t\tcase \"authors\":\n\t\t\t\treturn cachedOpenAlex.client.authors.getAuthor(entityId, params);\n\t\t\tcase \"sources\":\n\t\t\t\treturn cachedOpenAlex.client.sources.getSource(entityId, params);\n\t\t\tcase \"institutions\":\n\t\t\t\treturn cachedOpenAlex.client.institutions.getInstitution(entityId, params);\n\t\t\tcase \"topics\":\n\t\t\t\treturn cachedOpenAlex.client.topics.get(entityId, params);\n\t\t\tcase \"publishers\":\n\t\t\t\treturn cachedOpenAlex.client.publishers.get(entityId, params);\n\t\t\tcase \"funders\":\n\t\t\t\treturn cachedOpenAlex.client.funders.get(entityId, params);\n\t\t\tcase \"keywords\":\n\t\t\t\treturn cachedOpenAlex.client.keywords.getKeyword(entityId, params);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported entity type for field selection: ${entityType}`);\n\t\t}\n\t}\n\n\t/**\n\t * Detect relationships between a node and other nodes in the same batch\n\t * This finds relationships that wouldn't be caught in the first pass\n\t */\n\tprivate async detectCrossBatchRelationships(nodeId: string, batchNodeIds: string[]): Promise<GraphEdge[]> {\n\t\tconst store = useGraphStore.getState();\n\t\tconst sourceNode = store.getNode(nodeId);\n\n\t\tif (!sourceNode) {\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\t// Fetch minimal entity data for the source node\n\t\t\tconst sourceData = await this.fetchMinimalEntityData(sourceNode.entityId, sourceNode.type);\n\t\t\tif (!sourceData) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get only the other nodes in this batch (exclude the source node itself)\n\t\t\tconst otherBatchNodes = batchNodeIds\n\t\t\t\t.filter(id => id !== nodeId)\n\t\t\t\t.map(id => store.getNode(id))\n\t\t\t\t.filter(isNonNull);\n\n\t\t\t// Analyze relationships specifically with the batch nodes\n\t\t\tconst detectedRelationships = this.analyzeCrossBatchRelationships(sourceData, otherBatchNodes);\n\n\t\t\tlogger.debug(\"graph\", \"Cross-batch relationship detection\", {\n\t\t\t\tsourceNodeId: nodeId,\n\t\t\t\tbatchNodeCount: otherBatchNodes.length,\n\t\t\t\tdetectedCount: detectedRelationships.length\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\treturn this.createEdgesFromRelationships(detectedRelationships);\n\n\t\t} catch (error) {\n\t\t\tlogError(logger, \"Failed to detect cross-batch relationships\", error, \"RelationshipDetectionService\", \"graph\");\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Analyze relationships between source entity and batch nodes specifically\n\t * Similar to analyzeRelationships but focused on batch nodes only\n\t */\n\tprivate analyzeCrossBatchRelationships(sourceData: MinimalEntityData, batchNodes: GraphNode[]): DetectedRelationship[] {\n\t\tconst relationships: DetectedRelationship[] = [];\n\n\t\t// For works, check if any batch nodes are referenced works\n\t\tif (sourceData.entityType === \"works\" && sourceData.referenced_works) {\n\t\t\tlogger.debug(\"graph\", \"Checking cross-batch citations for work\", {\n\t\t\t\tworkId: sourceData.id,\n\t\t\t\tworkTitle: sourceData.display_name,\n\t\t\t\treferencedWorksCount: sourceData.referenced_works.length,\n\t\t\t\tbatchNodeCount: batchNodes.length,\n\t\t\t\treferencedWorkIds: sourceData.referenced_works,\n\t\t\t\tbatchNodeIds: batchNodes.map(n => n.entityId)\n\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\tfor (const referencedWorkId of sourceData.referenced_works) {\n\t\t\t\tconst referencedNode = batchNodes.find(node =>\n\t\t\t\t\tnode.entityId === referencedWorkId || node.id === referencedWorkId\n\t\t\t\t);\n\t\t\t\tif (referencedNode) {\n\t\t\t\t\tlogger.debug(\"graph\", \"FOUND cross-batch citation relationship!\", {\n\t\t\t\t\t\tsourceWork: sourceData.display_name,\n\t\t\t\t\t\tsourceId: sourceData.id,\n\t\t\t\t\t\ttargetWork: referencedNode.label,\n\t\t\t\t\t\ttargetId: referencedWorkId\n\t\t\t\t\t}, \"RelationshipDetectionService\");\n\n\t\t\t\t\trelationships.push({\n\t\t\t\t\t\tsourceNodeId: sourceData.id,\n\t\t\t\t\t\ttargetNodeId: referencedWorkId, // Use the entity ID to match the expected pattern\n\t\t\t\t\t\trelationType: RelationType.REFERENCES,\n\t\t\t\t\t\tlabel: \"references\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Additional cross-batch relationship patterns can be added here\n\t\t// Only for actual relationships present in OpenAlex data, not synthetic ones\n\n\t\treturn relationships;\n\t}\n\n\t/**\n\t * Remove duplicate edges based on source-target-type combination\n\t */\n\tprivate deduplicateEdges(edges: GraphEdge[]): GraphEdge[] {\n\t\tconst seen: Record<string, boolean> = {};\n\t\tconst uniqueEdges: GraphEdge[] = [];\n\n\t\tfor (const edge of edges) {\n\t\t\tconst key = `${edge.source}-${edge.type}-${edge.target}`;\n\t\t\tif (!seen[key]) {\n\t\t\t\tseen[key] = true;\n\t\t\t\tuniqueEdges.push(edge);\n\t\t\t}\n\t\t}\n\n\t\treturn uniqueEdges;\n\t}\n\n\t/**\n\t * Convert detected relationships to graph edges\n\t */\n\tprivate createEdgesFromRelationships(relationships: DetectedRelationship[]): GraphEdge[] {\n\t\treturn relationships.map(rel => ({\n\t\t\tid: `${rel.sourceNodeId}-${rel.relationType}-${rel.targetNodeId}`,\n\t\t\tsource: rel.sourceNodeId,\n\t\t\ttarget: rel.targetNodeId,\n\t\t\ttype: rel.relationType,\n\t\t\tlabel: rel.label,\n\t\t\t...(rel.weight !== undefined && { weight: rel.weight }),\n\t\t\t...(rel.metadata && { metadata: rel.metadata })\n\t\t}));\n\t}\n}\n\n/**\n * Create a new RelationshipDetectionService instance\n */\nexport function createRelationshipDetectionService(queryClient: QueryClient): RelationshipDetectionService {\n\treturn new RelationshipDetectionService(queryClient);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/services/request-deduplication-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/animated-graph-store.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":182,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":182,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4798,4800],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":202,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":202,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[5341,5343],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":218,"column":13,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":218,"endColumn":48},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":226,"column":13,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":226,"endColumn":48},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":228,"column":12,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":228,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":373,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":373,"endColumn":26}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Animated Graph Store\n * Extends the base graph store with animated position tracking and Web Worker integration\n */\n\nimport { create } from \"zustand\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\nimport { useGraphStore } from \"./graph-store\";\nimport type { GraphNode } from \"@academic-explorer/graph\";\nimport { createHybridStorage } from \"@academic-explorer/utils/storage\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface NodePosition {\n  id: string;\n  x: number;\n  y: number;\n}\n\ninterface AnimationStats {\n  totalIterations: number;\n  finalAlpha: number;\n  reason: string;\n  duration: number;\n}\n\ninterface AnimatedGraphState {\n  // Animation state\n  isAnimating: boolean;\n  isPaused: boolean;\n  progress: number;\n  alpha: number;\n  iteration: number;\n  fps: number;\n\n  // Position tracking\n  animatedPositions: Record<string, NodePosition | undefined>;\n  staticPositions: Record<string, NodePosition | undefined>;\n  // Cached arrays for React 19 compatibility (stable references)\n  _cachedAnimatedPositionsArray: NodePosition[];\n  _cachedStaticPositionsArray: NodePosition[];\n\n  // Animation history and stats\n  animationHistory: AnimationStats[];\n  currentAnimationStart: number;\n\n  // Configuration\n  useAnimatedLayout: boolean;\n  animationConfig: {\n    targetFPS: number;\n    alphaDecay: number;\n    maxIterations: number;\n    autoStart: boolean;\n  };\n\n  // Communication for restart requests from components outside AnimatedLayoutProvider\n  restartRequested: boolean;\n\n  // Actions\n  setAnimating: (animating: boolean) => void;\n  setPaused: (paused: boolean) => void;\n  setProgress: (progress: number) => void;\n  setAlpha: (alpha: number) => void;\n  setIteration: (iteration: number) => void;\n  setFPS: (fps: number) => void;\n\n  // Position management\n  updateAnimatedPositions: (positions: NodePosition[]) => void;\n  updateStaticPositions: (positions: NodePosition[]) => void;\n  getNodePosition: (nodeId: string) => NodePosition | undefined;\n  getAllPositions: () => NodePosition[];\n  getAnimatedPositions: () => NodePosition[];\n  clearPositions: () => void;\n\n  // Animation lifecycle\n  startAnimation: () => void;\n  completeAnimation: (stats: AnimationStats) => void;\n  resetAnimation: () => void;\n\n  // Communication for restart requests\n  requestRestart: () => void;\n  clearRestartRequest: () => void;\n\n  // Configuration\n  setUseAnimatedLayout: (use: boolean) => void;\n  updateAnimationConfig: (config: Partial<AnimatedGraphState[\"animationConfig\"]>) => void;\n\n  // Integration with base graph store\n  syncWithGraphStore: () => void;\n  applyPositionsToGraphStore: () => void;\n}\n\nexport const useAnimatedGraphStore = create<AnimatedGraphState>()(\n\tpersist(\n\t\timmer((set, get) => ({\n\t\t\t// Initial state\n\t\t\tisAnimating: false,\n\t\t\tisPaused: false,\n\t\t\tprogress: 0,\n\t\t\talpha: 1,\n\t\t\titeration: 0,\n\t\t\tfps: 0,\n\n\t\t\tanimatedPositions: {},\n\t\t\tstaticPositions: {},\n\t\t\t_cachedAnimatedPositionsArray: [],\n\t\t\t_cachedStaticPositionsArray: [],\n\t\t\tanimationHistory: [],\n\t\t\tcurrentAnimationStart: 0,\n\n\t\t\tuseAnimatedLayout: true, // Default to using animated layout\n\t\t\trestartRequested: false, // Communication flag for restart requests\n\t\t\tanimationConfig: {\n\t\t\t\ttargetFPS: 60,\n\t\t\t\talphaDecay: 0.02,\n\t\t\t\tmaxIterations: 1000,\n\t\t\t\tautoStart: false,\n\t\t\t},\n\n\t\t\t// Actions\n\t\t\tsetAnimating: (animating) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.isAnimating = animating;\n\t\t\t\t\tif (animating) {\n\t\t\t\t\t\tstate.currentAnimationStart = Date.now();\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Animation started\", {\n\t\t\t\t\t\t\ttimestamp: state.currentAnimationStart,\n\t\t\t\t\t\t\tconfig: state.animationConfig\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Animation stopped\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetPaused: (paused) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.isPaused = paused;\n\t\t\t\t\tlogger.debug(\"graph\", paused ? \"Animation paused\" : \"Animation resumed\");\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetProgress: (progress) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.progress = progress;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetAlpha: (alpha) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.alpha = alpha;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetIteration: (iteration) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.iteration = iteration;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetFPS: (fps) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.fps = fps;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Position management\n\t\t\tupdateAnimatedPositions: (positions) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\t// Clear existing animated positions\n\t\t\t\t\tstate.animatedPositions = {};\n\n\t\t\t\t\t// Add new positions\n\t\t\t\t\tpositions.forEach(pos => {\n\t\t\t\t\t\tstate.animatedPositions[pos.id] = { ...pos };\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update cached array for React 19 compatibility\n\t\t\t\t\tstate._cachedAnimatedPositionsArray = positions.map(pos => ({ ...pos }));\n\n\t\t\t\t\tlogger.debug(\"graph\", \"Updated animated positions\", {\n\t\t\t\t\t\tcount: positions?.length || 0,\n\t\t\t\t\t\tsample: positions.slice(0, 3)\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tupdateStaticPositions: (positions) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\t// Clear existing static positions\n\t\t\t\t\tstate.staticPositions = {};\n\n\t\t\t\t\t// Add new positions\n\t\t\t\t\tpositions.forEach(pos => {\n\t\t\t\t\t\tstate.staticPositions[pos.id] = { ...pos };\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update cached array for React 19 compatibility\n\t\t\t\t\tstate._cachedStaticPositionsArray = positions.map(pos => ({ ...pos }));\n\n\t\t\t\t\tlogger.debug(\"graph\", \"Updated static positions\", {\n\t\t\t\t\t\tcount: positions?.length || 0\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tgetNodePosition: (nodeId) => {\n\t\t\t\tconst state = get();\n\t\t\t\t// Prefer animated positions when animating, otherwise use static\n\t\t\t\tif (state.isAnimating && state.animatedPositions[nodeId]) {\n\t\t\t\t\treturn state.animatedPositions[nodeId];\n\t\t\t\t}\n\t\t\t\treturn state.staticPositions[nodeId];\n\t\t\t},\n\n\t\t\tgetAnimatedPositions: () => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn (state._cachedAnimatedPositionsArray || []).map(pos => ({ ...pos }));\n\t\t\t},\n\n\t\t\tgetAllPositions: () => {\n\t\t\t\tconst state = get();\n\t\t\t\t// Return appropriate position set based on animation state\n\t\t\t\t// Use cached arrays to prevent new object creation on each call (React 19 compatibility)\n\t\t\t\tif (state.isAnimating) {\n\t\t\t\t\treturn state._cachedAnimatedPositionsArray || [];\n\t\t\t\t}\n\t\t\t\treturn state._cachedStaticPositionsArray || [];\n\t\t\t},\n\n\t\t\tclearPositions: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.animatedPositions = {};\n\t\t\t\t\tstate.staticPositions = {};\n\t\t\t\t\t// Clear cached arrays for React 19 compatibility\n\t\t\t\t\tstate._cachedAnimatedPositionsArray = [];\n\t\t\t\t\tstate._cachedStaticPositionsArray = [];\n\t\t\t\t\tlogger.debug(\"graph\", \"Cleared all positions\");\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Animation lifecycle\n\t\t\tstartAnimation: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.isAnimating = true;\n\t\t\t\t\tstate.isPaused = false;\n\t\t\t\t\tstate.progress = 0;\n\t\t\t\t\tstate.alpha = 1;\n\t\t\t\t\tstate.iteration = 0;\n\t\t\t\t\tstate.currentAnimationStart = Date.now();\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tcompleteAnimation: (stats) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst duration = Date.now() - state.currentAnimationStart;\n\t\t\t\t\tconst completedStats = { ...stats, duration };\n\n\t\t\t\t\tstate.isAnimating = false;\n\t\t\t\t\tstate.isPaused = false;\n\t\t\t\t\tstate.progress = 1;\n\t\t\t\t\tstate.animationHistory.push(completedStats);\n\n\t\t\t\t\t// Keep only last 10 animation records\n\t\t\t\t\tif (state.animationHistory.length > 10) {\n\t\t\t\t\t\tstate.animationHistory.splice(0, state.animationHistory.length - 10);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move animated positions to static positions\n\t\t\t\t\tstate.staticPositions = {};\n\t\t\t\t\tconst newStaticPositions: NodePosition[] = [];\n\t\t\t\t\tObject.entries(state.animatedPositions).forEach(([id, pos]) => {\n\t\t\t\t\t\tif (pos) {\n\t\t\t\t\t\t\tconst newPos = { ...pos };\n\t\t\t\t\t\t\tstate.staticPositions[id] = newPos;\n\t\t\t\t\t\t\tnewStaticPositions.push(newPos);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tstate.animatedPositions = {};\n\t\t\t\t\t// Update cached arrays for React 19 compatibility\n\t\t\t\t\tstate._cachedStaticPositionsArray = newStaticPositions;\n\t\t\t\t\tstate._cachedAnimatedPositionsArray = [];\n\n\t\t\t\t\tlogger.debug(\"graph\", \"Animation completed\", {\n\t\t\t\t\t\t...completedStats,\n\t\t\t\t\t\tduration: `${duration.toString()}ms`,\n\t\t\t\t\t\thistoryCount: state.animationHistory.length\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tresetAnimation: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.isAnimating = false;\n\t\t\t\t\tstate.isPaused = false;\n\t\t\t\t\tstate.progress = 0;\n\t\t\t\t\tstate.alpha = 1;\n\t\t\t\t\tstate.iteration = 0;\n\t\t\t\t\tstate.fps = 0;\n\t\t\t\t\tstate.animatedPositions = {};\n\t\t\t\t\t// Clear cached array for React 19 compatibility\n\t\t\t\t\tstate._cachedAnimatedPositionsArray = [];\n\t\t\t\t\tlogger.debug(\"graph\", \"Animation reset\");\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Communication for restart requests from components outside AnimatedLayoutProvider\n\t\t\trequestRestart: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.restartRequested = true;\n\t\t\t\t\tlogger.debug(\"graph\", \"Animation restart requested from external component\");\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tclearRestartRequest: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.restartRequested = false;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Configuration\n\t\t\tsetUseAnimatedLayout: (use) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.useAnimatedLayout = use;\n\t\t\t\t\tlogger.debug(\"graph\", `Animated layout ${use ? \"enabled\" : \"disabled\"}`);\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tupdateAnimationConfig: (config) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tObject.assign(state.animationConfig, config);\n\t\t\t\t\tlogger.debug(\"graph\", \"Animation config updated\", {\n\t\t\t\t\t\tnewConfig: state.animationConfig\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Integration with base graph store\n\t\t\tsyncWithGraphStore: () => {\n\t\t\t\tconst graphStore = useGraphStore.getState();\n\t\t\t\tconst nodes = Object.values(graphStore.nodes).filter((node): node is NonNullable<typeof node> => node != null);\n\n\t\t\t\tset((state) => {\n\t\t\t\t\t// Extract current positions from graph store nodes\n\t\t\t\t\tconst positions: NodePosition[] = nodes.map((node: GraphNode) => ({\n\t\t\t\t\t\tid: node.id,\n\t\t\t\t\t\tx: node.position.x,\n\t\t\t\t\t\ty: node.position.y,\n\t\t\t\t\t}));\n\n\t\t\t\t\t// Update static positions\n\t\t\t\t\tstate.staticPositions = {};\n\t\t\t\t\tpositions.forEach(pos => {\n\t\t\t\t\t\tstate.staticPositions[pos.id] = { ...pos };\n\t\t\t\t\t});\n\t\t\t\t\t// Update cached array for React 19 compatibility\n\t\t\t\t\tstate._cachedStaticPositionsArray = positions.map(pos => ({ ...pos }));\n\n\t\t\t\t\tlogger.debug(\"graph\", \"Synced animated store with graph store\", {\n\t\t\t\t\t\tnodeCount: nodes.length,\n\t\t\t\t\t\tpositionCount: positions.length,\n\t\t\t\t\t\tlayoutType: graphStore.currentLayout.type,\n\t\t\t\t\t\tpinnedNodeCount: Object.keys(graphStore.pinnedNodes).length,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tapplyPositionsToGraphStore: () => {\n\t\t\t\tconst state = get();\n\t\t\t\tconst graphStore = useGraphStore.getState();\n\t\t\t\tconst currentPositions = state.getAllPositions();\n\n\t\t\t\tif (!currentPositions || currentPositions.length === 0) {\n\t\t\t\t\tlogger.warn(\"graph\", \"No positions to apply to graph store\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Update graph store nodes with current positions\n\t\t\t\tcurrentPositions.forEach(pos => {\n\t\t\t\t\tconst node = graphStore.nodes[pos.id];\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tgraphStore.updateNode(pos.id, {\n\t\t\t\t\t\t\tposition: { x: pos.x, y: pos.y }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"graph\", \"Applied positions to graph store\", {\n\t\t\t\t\tappliedCount: currentPositions.length\n\t\t\t\t});\n\t\t\t},\n\t\t})),\n\t\t{\n\t\t\tname: \"animated-graph-store\",\n\t\t\tstorage: createJSONStorage(() => createHybridStorage({\n\t\t\t\tdbName: \"academic-explorer\",\n\t\t\t\tstoreName: \"animated-graph-store\",\n\t\t\t\tversion: 1\n\t\t\t})),\n\t\t\t// Only persist configuration, not runtime state\n\t\t\tpartialize: (state) => ({\n\t\t\t\tuseAnimatedLayout: state.useAnimatedLayout,\n\t\t\t\tanimationConfig: state.animationConfig,\n\t\t\t\tanimationHistory: state.animationHistory.slice(-5), // Keep last 5\n\t\t\t}),\n\t\t}\n\t)\n);\n\n// Individual stable selectors to avoid object recreation (React 19 + Zustand compatibility)\nexport const useIsAnimating = () => useAnimatedGraphStore((state) => state.isAnimating);\nexport const useIsPaused = () => useAnimatedGraphStore((state) => state.isPaused);\nexport const useAnimationProgress = () => useAnimatedGraphStore((state) => state.progress);\nexport const useAnimationAlpha = () => useAnimatedGraphStore((state) => state.alpha);\nexport const useAnimationIteration = () => useAnimatedGraphStore((state) => state.iteration);\nexport const useAnimationFPS = () => useAnimatedGraphStore((state) => state.fps);\n\nexport const useAnimationConfig = () => useAnimatedGraphStore((state) => state.animationConfig);\nexport const useUseAnimatedLayout = () => useAnimatedGraphStore((state) => state.useAnimatedLayout);\nexport const useUpdateAnimationConfig = () => useAnimatedGraphStore((state) => state.updateAnimationConfig);\nexport const useSetUseAnimatedLayout = () => useAnimatedGraphStore((state) => state.setUseAnimatedLayout);\n\n// Position tracking selectors\nexport const useGetNodePosition = () => useAnimatedGraphStore((state) => state.getNodePosition);\nexport const useGetAllPositions = () => useAnimatedGraphStore((state) => state.getAllPositions);\nexport const useGetAnimatedPositions = () => useAnimatedGraphStore((state) => state.getAnimatedPositions);\nexport const useUpdateAnimatedPositions = () => useAnimatedGraphStore((state) => state.updateAnimatedPositions);\nexport const useUpdateStaticPositions = () => useAnimatedGraphStore((state) => state.updateStaticPositions);\nexport const useClearPositions = () => useAnimatedGraphStore((state) => state.clearPositions);\nexport const useApplyPositionsToGraphStore = () => useAnimatedGraphStore((state) => state.applyPositionsToGraphStore);\nexport const useSyncWithGraphStore = () => useAnimatedGraphStore((state) => state.syncWithGraphStore);\n\n// Communication for restart requests from components outside AnimatedLayoutProvider\nexport const useRestartRequested = () => useAnimatedGraphStore((state) => state.restartRequested);\nexport const useRequestRestart = () => useAnimatedGraphStore((state) => state.requestRestart);\nexport const useClearRestartRequest = () => useAnimatedGraphStore((state) => state.clearRestartRequest);\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/app-activity-store.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":148,"column":82,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":148,"endColumn":84,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5596,5598],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":259,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":259,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Store for tracking general application activity and system events\n * Monitors user interactions, component lifecycle, performance metrics, and system state\n */\n\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\nexport interface AppActivityEvent {\n  id: string;\n  type: \"user\" | \"system\" | \"navigation\" | \"component\" | \"performance\" | \"error\";\n  category: \"interaction\" | \"lifecycle\" | \"data\" | \"ui\" | \"background\";\n  event: string;\n  description: string;\n  timestamp: number;\n  duration?: number;\n  severity: \"info\" | \"warning\" | \"error\" | \"debug\";\n  metadata?: {\n    component?: string;\n    route?: string;\n    previousRoute?: string;\n    entityType?: string;\n    entityId?: string;\n    userId?: string;\n    performance?: {\n      memory?: number;\n      timing?: number;\n      fps?: number;\n    };\n    data?: Record<string, unknown>;\n  };\n}\n\nexport interface AppActivityStats {\n  totalEvents: number;\n  eventsLast5Min: number;\n  eventsPerMinute: number;\n  errorCount: number;\n  warningCount: number;\n  userInteractions: number;\n  componentLifecycleEvents: number;\n  navigationEvents: number;\n  averageEventFrequency: number;\n  memoryUsage?: number;\n  performanceScore?: number;\n}\n\ninterface AppActivityState {\n  // State - using plain objects for Immer compatibility\n  events: Record<string, AppActivityEvent>;\n  maxHistorySize: number;\n\n  // Cached computed state for stable references\n  recentEvents: AppActivityEvent[];\n  activityStats: AppActivityStats;\n  filteredEvents: AppActivityEvent[];\n\n  // Filters\n  filters: {\n    type: string[];\n    category: string[];\n    severity: string[];\n    searchTerm: string;\n    timeRange: number; // minutes\n  };\n\n  // Actions\n  addEvent: (event: Omit<AppActivityEvent, \"id\" | \"timestamp\">) => string;\n  updateEvent: (id: string, updates: Partial<AppActivityEvent>) => void;\n  removeEvent: (id: string) => void;\n  clearOldEvents: () => void;\n  clearAllEvents: () => void;\n\n  // Convenience methods for common event types\n  logUserInteraction: (action: string, component?: string, metadata?: Record<string, unknown>) => void;\n  logNavigation: (from: string, to: string, metadata?: Record<string, unknown>) => void;\n  logComponentMount: (component: string, metadata?: Record<string, unknown>) => void;\n  logComponentUnmount: (component: string, metadata?: Record<string, unknown>) => void;\n  logPerformanceMetric: (metric: string, value: number, metadata?: Record<string, unknown>) => void;\n  logError: (error: string, component?: string, metadata?: Record<string, unknown>) => void;\n  logWarning: (warning: string, component?: string, metadata?: Record<string, unknown>) => void;\n\n  // Filter actions\n  setTypeFilter: (types: string[]) => void;\n  setCategoryFilter: (categories: string[]) => void;\n  setSeverityFilter: (severities: string[]) => void;\n  setSearchTerm: (term: string) => void;\n  setTimeRange: (minutes: number) => void;\n  clearFilters: () => void;\n\n  // Recomputation functions (called after mutations)\n  recomputeRecentEvents: () => void;\n  recomputeActivityStats: () => void;\n  recomputeFilteredEvents: () => void;\n  recomputeAll: () => void;\n}\n\nconst generateEventId = () => `evt_${Date.now().toString()}_${Math.random().toString(36).substring(2, 11)}`;\n\nconst computeRecentEvents = (events: Record<string, AppActivityEvent>): AppActivityEvent[] => {\n  return Object.values(events)\n    .sort((a, b) => b.timestamp - a.timestamp)\n    .slice(0, 100); // Show last 100 events\n};\n\nconst computeActivityStats = (events: Record<string, AppActivityEvent>): AppActivityStats => {\n  const eventList = Object.values(events);\n  const now = Date.now();\n  const fiveMinutesAgo = now - (5 * 60 * 1000);\n  const oneMinuteAgo = now - (60 * 1000);\n\n  const recentEvents = eventList.filter(event => event.timestamp > fiveMinutesAgo);\n  const lastMinuteEvents = eventList.filter(event => event.timestamp > oneMinuteAgo);\n\n  // Calculate average event frequency (events per minute over last 5 minutes)\n  const timespanMinutes = Math.max(1, (now - Math.min(...eventList.map(e => e.timestamp))) / (60 * 1000));\n  const averageFrequency = eventList.length > 0 ? eventList.length / timespanMinutes : 0;\n\n  const memoryUsage = getMemoryUsage();\n  const performanceScore = calculatePerformanceScore(eventList);\n\n  return {\n    totalEvents: eventList.length,\n    eventsLast5Min: recentEvents.length,\n    eventsPerMinute: lastMinuteEvents.length,\n    errorCount: eventList.filter(event => event.severity === \"error\").length,\n    warningCount: eventList.filter(event => event.severity === \"warning\").length,\n    userInteractions: eventList.filter(event => event.type === \"user\").length,\n    componentLifecycleEvents: eventList.filter(event => event.type === \"component\").length,\n    navigationEvents: eventList.filter(event => event.type === \"navigation\").length,\n    averageEventFrequency: averageFrequency,\n    ...(memoryUsage !== undefined && { memoryUsage }),\n    ...(performanceScore !== undefined && { performanceScore }),\n  };\n};\n\nconst getMemoryUsage = (): number | undefined => {\n  // Memory usage monitoring disabled to avoid type assertions\n  // Performance.memory is not standardized and requires unsafe type casting\n  return undefined;\n};\n\nconst calculatePerformanceScore = (events: AppActivityEvent[]): number | undefined => {\n  const performanceEvents = events.filter(e => e.type === \"performance\" && e.duration);\n  if (performanceEvents.length === 0) return undefined;\n\n  const averageDuration = performanceEvents.reduce((sum, e) => sum + (e.duration || 0), 0) / performanceEvents.length;\n  // Score from 0-100 where lower duration = higher score\n  return Math.max(0, Math.min(100, 100 - (averageDuration / 10)));\n};\n\nconst computeFilteredEvents = (\n  events: Record<string, AppActivityEvent>,\n  filters: AppActivityState[\"filters\"]\n): AppActivityEvent[] => {\n  const eventList = Object.values(events);\n  const cutoffTime = Date.now() - (filters.timeRange * 60 * 1000);\n\n  return eventList.filter(event => {\n    // Time range filter\n    if (event.timestamp < cutoffTime) return false;\n\n    // Type filter\n    if (filters.type.length > 0 && !filters.type.includes(event.type)) return false;\n\n    // Category filter\n    if (filters.category.length > 0 && !filters.category.includes(event.category)) return false;\n\n    // Severity filter\n    if (filters.severity.length > 0 && !filters.severity.includes(event.severity)) return false;\n\n    // Search term filter\n    if (filters.searchTerm) {\n      const term = filters.searchTerm.toLowerCase();\n      const searchableText = [\n        event.event,\n        event.description,\n        event.metadata?.component,\n        event.metadata?.route,\n        event.metadata?.entityType,\n        event.metadata?.entityId\n      ].filter(Boolean).join(\" \").toLowerCase();\n\n      if (!searchableText.includes(term)) return false;\n    }\n\n    return true;\n  }).sort((a, b) => b.timestamp - a.timestamp);\n};\n\nexport const useAppActivityStore = create<AppActivityState>()(\n  immer((set, get) => ({\n    // State\n    events: {},\n    maxHistorySize: 1000,\n\n    // Cached computed state (stable references)\n    recentEvents: [],\n    activityStats: {\n      totalEvents: 0,\n      eventsLast5Min: 0,\n      eventsPerMinute: 0,\n      errorCount: 0,\n      warningCount: 0,\n      userInteractions: 0,\n      componentLifecycleEvents: 0,\n      navigationEvents: 0,\n      averageEventFrequency: 0,\n    },\n    filteredEvents: [],\n\n    // Filters\n    filters: {\n      type: [],\n      category: [],\n      severity: [],\n      searchTerm: \"\",\n      timeRange: 30, // 30 minutes default\n    },\n\n    // Actions\n    addEvent: (event) => {\n      const id = generateEventId();\n\n      set(state => {\n        state.events[id] = {\n          ...event,\n          id,\n          timestamp: Date.now(),\n        };\n      });\n\n      get().recomputeAll();\n\n      logger.debug(\"ui\", \"App activity event added\", {\n        id,\n        type: event.type,\n        event: event.event,\n        severity: event.severity,\n      }, \"AppActivityStore\");\n\n      return id;\n    },\n\n    updateEvent: (id, updates) => {\n      set(state => {\n        const existingEvent = state.events[id];\n        if (existingEvent) {\n          Object.assign(existingEvent, updates);\n        }\n      });\n\n      get().recomputeAll();\n    },\n\n    removeEvent: (id) => {\n      set(state => {\n        const { [id]: removed, ...rest } = state.events;\n        state.events = rest;\n      });\n\n      get().recomputeAll();\n    },\n\n    clearOldEvents: () => {\n      const { maxHistorySize } = get();\n      const events = Object.values(get().events);\n\n      if (events.length <= maxHistorySize) return;\n\n      // Keep most recent events\n      const sorted = events.sort((a, b) => b.timestamp - a.timestamp);\n      const toKeep = sorted.slice(0, maxHistorySize);\n\n      set(state => {\n        state.events = {};\n        toKeep.forEach(event => {\n          state.events[event.id] = event;\n        });\n      });\n\n      get().recomputeAll();\n\n      logger.debug(\"ui\", \"Cleared old app activity events\", {\n        removed: events.length - toKeep.length,\n        kept: toKeep.length\n      }, \"AppActivityStore\");\n    },\n\n    clearAllEvents: () => {\n      set(state => {\n        state.events = {};\n      });\n\n      get().recomputeAll();\n\n      logger.debug(\"ui\", \"Cleared all app activity events\", {}, \"AppActivityStore\");\n    },\n\n    // Convenience methods for common event types\n    logUserInteraction: (action, component, metadata) => {\n      get().addEvent({\n        type: \"user\",\n        category: \"interaction\",\n        event: action,\n        description: `User ${action}${component ? ` in ${component}` : \"\"}`,\n        severity: \"debug\",\n        metadata: {\n          ...(component && { component }),\n          ...metadata,\n        },\n      });\n    },\n\n    logNavigation: (from, to, metadata) => {\n      get().addEvent({\n        type: \"navigation\",\n        category: \"ui\",\n        event: \"route_change\",\n        description: `Navigated from ${from} to ${to}`,\n        severity: \"info\",\n        metadata: {\n          route: to,\n          previousRoute: from,\n          ...metadata,\n        },\n      });\n    },\n\n    logComponentMount: (component, metadata) => {\n      get().addEvent({\n        type: \"component\",\n        category: \"lifecycle\",\n        event: \"mount\",\n        description: `Component ${component} mounted`,\n        severity: \"debug\",\n        metadata: {\n          component,\n          ...metadata,\n        },\n      });\n    },\n\n    logComponentUnmount: (component, metadata) => {\n      get().addEvent({\n        type: \"component\",\n        category: \"lifecycle\",\n        event: \"unmount\",\n        description: `Component ${component} unmounted`,\n        severity: \"debug\",\n        metadata: {\n          component,\n          ...metadata,\n        },\n      });\n    },\n\n    logPerformanceMetric: (metric, value, metadata) => {\n      get().addEvent({\n        type: \"performance\",\n        category: \"background\",\n        event: metric,\n        description: `Performance metric: ${metric} = ${value.toString()}`,\n        severity: value > 1000 ? \"warning\" : \"info\", // Warn if metric is high\n        duration: value,\n        metadata: {\n          performance: {\n            timing: value,\n          },\n          ...metadata,\n        },\n      });\n    },\n\n    logError: (error, component, metadata) => {\n      get().addEvent({\n        type: \"error\",\n        category: \"ui\",\n        event: \"error\",\n        description: error,\n        severity: \"error\",\n        metadata: {\n          ...(component && { component }),\n          ...metadata,\n        },\n      });\n    },\n\n    logWarning: (warning, component, metadata) => {\n      get().addEvent({\n        type: \"system\",\n        category: \"ui\",\n        event: \"warning\",\n        description: warning,\n        severity: \"warning\",\n        metadata: {\n          ...(component && { component }),\n          ...metadata,\n        },\n      });\n    },\n\n    // Filter actions\n    setTypeFilter: (types) => {\n      set(state => {\n        state.filters.type = types;\n      });\n      get().recomputeFilteredEvents();\n    },\n\n    setCategoryFilter: (categories) => {\n      set(state => {\n        state.filters.category = categories;\n      });\n      get().recomputeFilteredEvents();\n    },\n\n    setSeverityFilter: (severities) => {\n      set(state => {\n        state.filters.severity = severities;\n      });\n      get().recomputeFilteredEvents();\n    },\n\n    setSearchTerm: (term) => {\n      set(state => {\n        state.filters.searchTerm = term;\n      });\n      get().recomputeFilteredEvents();\n    },\n\n    setTimeRange: (minutes) => {\n      set(state => {\n        state.filters.timeRange = minutes;\n      });\n      get().recomputeFilteredEvents();\n    },\n\n    clearFilters: () => {\n      set(state => {\n        state.filters = {\n          type: [],\n          category: [],\n          severity: [],\n          searchTerm: \"\",\n          timeRange: 30,\n        };\n      });\n      get().recomputeFilteredEvents();\n    },\n\n    // Recomputation functions (called after mutations)\n    recomputeRecentEvents: () => {\n      set(state => {\n        state.recentEvents = computeRecentEvents(state.events);\n      });\n    },\n\n    recomputeActivityStats: () => {\n      set(state => {\n        state.activityStats = computeActivityStats(state.events);\n      });\n    },\n\n    recomputeFilteredEvents: () => {\n      set(state => {\n        state.filteredEvents = computeFilteredEvents(state.events, state.filters);\n      });\n    },\n\n    recomputeAll: () => {\n      const state = get();\n      state.recomputeRecentEvents();\n      state.recomputeActivityStats();\n      state.recomputeFilteredEvents();\n\n      // Auto-cleanup old events\n      if (Object.keys(state.events).length > state.maxHistorySize) {\n        state.clearOldEvents();\n      }\n    },\n  }))\n);","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/data-fetching-progress-store.ts","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":113,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Store for tracking data fetching progress\n * Manages progress state for background data fetching operations\n */\n\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface DataFetchingProgressItem {\n  nodeId: string;\n  entityName?: string;\n  entityType?: string;\n  progress: {\n    completed: number;\n    total: number;\n    stage: string;\n  };\n  status: \"active\" | \"completed\" | \"error\";\n  error?: string;\n  startTime: number;\n}\n\ninterface DataFetchingProgressState {\n  // State - using plain object instead of Map for Immer compatibility\n  requests: Record<string, DataFetchingProgressItem | undefined>;\n  workerReady: boolean;\n\n  // Actions\n  addRequest: (nodeId: string, entityName?: string, entityType?: string) => void;\n  updateProgress: (nodeId: string, progress: { completed: number; total: number; stage: string }) => void;\n  completeRequest: (nodeId: string) => void;\n  failRequest: (nodeId: string, error: string) => void;\n  removeRequest: (nodeId: string) => void;\n  setWorkerReady: (ready: boolean) => void;\n  clearCompleted: () => void;\n  clearAll: () => void;\n\n  // Selectors\n  getActiveRequests: () => DataFetchingProgressItem[];\n  getRequestByNodeId: (nodeId: string) => DataFetchingProgressItem | undefined;\n}\n\nexport const useDataFetchingProgressStore = create<DataFetchingProgressState>()(\n\timmer((set, get) => ({\n\t\t// State - using plain object for Immer compatibility\n\t\trequests: {},\n\t\tworkerReady: false,\n\n\t\t// Actions\n\t\taddRequest: (nodeId: string, entityName?: string, entityType?: string) =>\n\t\t{ set((state) => {\n\t\t\tstate.requests[nodeId] = {\n\t\t\t\tnodeId,\n\t\t\t\t...(entityName && { entityName }),\n\t\t\t\t...(entityType && { entityType }),\n\t\t\t\tprogress: {\n\t\t\t\t\tcompleted: 0,\n\t\t\t\t\ttotal: 1,\n\t\t\t\t\tstage: \"Starting...\"\n\t\t\t\t},\n\t\t\t\tstatus: \"active\",\n\t\t\t\tstartTime: Date.now()\n\t\t\t};\n\t\t}); },\n\n\t\tupdateProgress: (nodeId: string, progress: { completed: number; total: number; stage: string }) =>\n\t\t{ set((state) => {\n\t\t\tconst request = state.requests[nodeId];\n\t\t\tif (request && request.status === \"active\") {\n\t\t\t\trequest.progress = progress;\n\t\t\t}\n\t\t}); },\n\n\t\tcompleteRequest: (nodeId: string) =>\n\t\t{ set((state) => {\n\t\t\tconst request = state.requests[nodeId];\n\t\t\tif (request) {\n\t\t\t\trequest.status = \"completed\";\n\t\t\t\trequest.progress = {\n\t\t\t\t\tcompleted: request.progress.total,\n\t\t\t\t\ttotal: request.progress.total,\n\t\t\t\t\tstage: \"Completed\"\n\t\t\t\t};\n\n\t\t\t\t// Auto-remove completed requests after 3 seconds\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tget().removeRequest(nodeId);\n\t\t\t\t}, 3000);\n\t\t\t}\n\t\t}); },\n\n\t\tfailRequest: (nodeId: string, error: string) =>\n\t\t{ set((state) => {\n\t\t\tconst request = state.requests[nodeId];\n\t\t\tif (request) {\n\t\t\t\trequest.status = \"error\";\n\t\t\t\trequest.error = error;\n\t\t\t\trequest.progress = {\n\t\t\t\t\tcompleted: 0,\n\t\t\t\t\ttotal: request.progress.total,\n\t\t\t\t\tstage: \"Failed\"\n\t\t\t\t};\n\n\t\t\t\t// Auto-remove failed requests after 5 seconds\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tget().removeRequest(nodeId);\n\t\t\t\t}, 5000);\n\t\t\t}\n\t\t}); },\n\n\t\tremoveRequest: (nodeId: string) =>\n\t\t{ set((state) => {\n\t\t\tconst { [nodeId]: removed, ...rest } = state.requests;\n\t\t\tstate.requests = rest;\n\t\t}); },\n\n\t\tsetWorkerReady: (ready: boolean) =>\n\t\t{ set((state) => {\n\t\t\tstate.workerReady = ready;\n\t\t}); },\n\n\t\tclearCompleted: () =>\n\t\t{ set((state) => {\n\t\t\tconst filteredRequests: Record<string, DataFetchingProgressItem> = {};\n\t\t\tObject.entries(state.requests).forEach(([nodeId, request]) => {\n\t\t\t\tif (request && request.status !== \"completed\") {\n\t\t\t\t\tfilteredRequests[nodeId] = request;\n\t\t\t\t}\n\t\t\t});\n\t\t\tstate.requests = filteredRequests;\n\t\t}); },\n\n\t\tclearAll: () =>\n\t\t{ set((state) => {\n\t\t\tstate.requests = {};\n\t\t}); },\n\n\t\t// Selectors\n\t\tgetActiveRequests: () => {\n\t\t\treturn Object.values(get().requests).filter((request): request is NonNullable<typeof request> => request != null);\n\t\t},\n\n\t\tgetRequestByNodeId: (nodeId: string) => {\n\t\t\treturn get().requests[nodeId];\n\t\t}\n\t}))\n);","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/expansion-settings-store.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":128,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":128,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[5785,5826],"text":"settings.sorts ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":139,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":139,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[6204,6245],"text":"settings.sorts ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":153,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":153,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[6723,6764],"text":"settings.sorts ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":170,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":170,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[7255,7296],"text":"settings.sorts ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":192,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":192,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[7918,7963],"text":"settings.filters ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":203,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":203,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[8346,8391],"text":"settings.filters ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":217,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":217,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[8877,8922],"text":"settings.filters ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":228,"column":6,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":228,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[9264,9309],"text":"settings.filters ??= [];"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":249,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":249,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[9954,9956],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Expansion settings store\n * Manages expansion configurations for each entity and edge type\n * Uses Zustand with Immer for state management and localStorage for persistence\n */\n\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport { createHybridStorage } from \"@academic-explorer/utils/storage\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type {\n\tExpansionSettings,\n\tExpansionTarget,\n\tSortCriteria,\n\tFilterCriteria\n} from \"@academic-explorer/graph\";\nimport { getDefaultSettingsForTarget } from \"@academic-explorer/graph\";\nimport { RelationType } from \"@academic-explorer/graph\";\n\ninterface ExpansionSettingsState {\n  /** Settings per target type */\n  settings: Record<ExpansionTarget, ExpansionSettings>;\n\n  /** Actions */\n  getSettings: (target: ExpansionTarget) => ExpansionSettings;\n  updateSettings: (target: ExpansionTarget, settings: Partial<ExpansionSettings>) => void;\n  resetSettings: (target: ExpansionTarget) => void;\n  resetAllSettings: () => void;\n\n  /** Sort criteria management */\n  addSortCriteria: (target: ExpansionTarget, criteria: Omit<SortCriteria, \"priority\">) => void;\n  updateSortCriteria: (target: ExpansionTarget, index: number, criteria: Partial<SortCriteria>) => void;\n  removeSortCriteria: (target: ExpansionTarget, index: number) => void;\n  reorderSortCriteria: (target: ExpansionTarget, fromIndex: number, toIndex: number) => void;\n\n  /** Filter criteria management */\n  addFilterCriteria: (target: ExpansionTarget, criteria: FilterCriteria) => void;\n  updateFilterCriteria: (target: ExpansionTarget, index: number, criteria: Partial<FilterCriteria>) => void;\n  removeFilterCriteria: (target: ExpansionTarget, index: number) => void;\n  toggleFilterEnabled: (target: ExpansionTarget, index: number) => void;\n\n  /** Utility functions */\n  getSettingsSummary: (target: ExpansionTarget) => string;\n  exportSettings: () => Record<string, ExpansionSettings>;\n  importSettings: (settings: Record<string, ExpansionSettings>) => void;\n}\n\n// Initialize with default settings\nconst initializeDefaultSettings = (): Record<ExpansionTarget, ExpansionSettings> => {\n\t// Explicitly create the complete settings object with all required keys\n\tconst settings = {\n\t\t// Entity types\n\t\tworks: getDefaultSettingsForTarget(\"works\"),\n\t\tauthors: getDefaultSettingsForTarget(\"authors\"),\n\t\tsources: getDefaultSettingsForTarget(\"sources\"),\n\t\tinstitutions: getDefaultSettingsForTarget(\"institutions\"),\n\t\ttopics: getDefaultSettingsForTarget(\"topics\"),\n\t\tconcepts: getDefaultSettingsForTarget(\"concepts\"),\n\t\tpublishers: getDefaultSettingsForTarget(\"publishers\"),\n\t\tfunders: getDefaultSettingsForTarget(\"funders\"),\n\t\tkeywords: getDefaultSettingsForTarget(\"keywords\"),\n\n\t\t// Relation types - each unique and specific\n\t\t[RelationType.AUTHORED]: getDefaultSettingsForTarget(RelationType.AUTHORED),\n\t\t[RelationType.AFFILIATED]: getDefaultSettingsForTarget(RelationType.AFFILIATED),\n\t\t[RelationType.PUBLISHED_IN]: getDefaultSettingsForTarget(RelationType.PUBLISHED_IN),\n\t\t[RelationType.FUNDED_BY]: getDefaultSettingsForTarget(RelationType.FUNDED_BY),\n\t\t[RelationType.REFERENCES]: getDefaultSettingsForTarget(RelationType.REFERENCES),\n\t\t[RelationType.RELATED_TO]: getDefaultSettingsForTarget(RelationType.RELATED_TO),\n\t\t[RelationType.SOURCE_PUBLISHED_BY]: getDefaultSettingsForTarget(RelationType.SOURCE_PUBLISHED_BY),\n\t\t[RelationType.INSTITUTION_CHILD_OF]: getDefaultSettingsForTarget(RelationType.INSTITUTION_CHILD_OF),\n\t\t[RelationType.PUBLISHER_CHILD_OF]: getDefaultSettingsForTarget(RelationType.PUBLISHER_CHILD_OF),\n\t\t[RelationType.WORK_HAS_TOPIC]: getDefaultSettingsForTarget(RelationType.WORK_HAS_TOPIC),\n\t\t[RelationType.WORK_HAS_KEYWORD]: getDefaultSettingsForTarget(RelationType.WORK_HAS_KEYWORD),\n\t\t[RelationType.AUTHOR_RESEARCHES]: getDefaultSettingsForTarget(RelationType.AUTHOR_RESEARCHES),\n\t\t[RelationType.INSTITUTION_LOCATED_IN]: getDefaultSettingsForTarget(RelationType.INSTITUTION_LOCATED_IN),\n\t\t[RelationType.FUNDER_LOCATED_IN]: getDefaultSettingsForTarget(RelationType.FUNDER_LOCATED_IN),\n\t\t[RelationType.TOPIC_PART_OF_FIELD]: getDefaultSettingsForTarget(RelationType.TOPIC_PART_OF_FIELD)\n\t};\n\n\treturn settings;\n};\n\nexport const useExpansionSettingsStore = create<ExpansionSettingsState>()(\n\tpersist(\n\t\timmer((set, get) => ({\n\t\t\tsettings: initializeDefaultSettings(),\n\n\t\t\tgetSettings: (target: ExpansionTarget) => {\n\t\t\t\treturn get().settings[target];\n\t\t\t},\n\n\t\t\tupdateSettings: (target: ExpansionTarget, settingsUpdate: Partial<ExpansionSettings>) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst currentSettings = state.settings[target];\n\t\t\t\t\tconst updatedSettings = { ...currentSettings, ...settingsUpdate };\n\t\t\t\t\tstate.settings[target] = updatedSettings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Updated settings for target\", { target, settingsUpdate }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\tresetSettings: (target: ExpansionTarget) => {\n\t\t\t\tconst defaultSettings = getDefaultSettingsForTarget(target);\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.settings[target] = defaultSettings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Reset settings for target\", { target }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\tresetAllSettings: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.settings = initializeDefaultSettings();\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Reset all expansion settings\", {}, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\taddSortCriteria: (target: ExpansionTarget, criteria: Omit<SortCriteria, \"priority\">) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tconst sorts = settings.sorts ?? [];\n\t\t\t\t\tconst newPriority = Math.max(0, ...sorts.map(s => s.priority)) + 1;\n\t\t\t\t\tconst newCriteria: SortCriteria = { ...criteria, priority: newPriority };\n\n\t\t\t\t\tif (!settings.sorts) settings.sorts = [];\n\t\t\t\t\tsettings.sorts.push(newCriteria);\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Added sort criteria\", { target, criteria }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\tupdateSortCriteria: (target: ExpansionTarget, index: number, criteriaUpdate: Partial<SortCriteria>) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tif (!settings.sorts) settings.sorts = [];\n\t\t\t\t\tconst existingCriteria = settings.sorts[index];\n\t\t\t\t\tif (existingCriteria) {\n\t\t\t\t\t\tsettings.sorts[index] = { ...existingCriteria, ...criteriaUpdate };\n\t\t\t\t\t}\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Updated sort criteria\", { target, index, criteriaUpdate }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\tremoveSortCriteria: (target: ExpansionTarget, index: number) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tif (!settings.sorts) settings.sorts = [];\n\t\t\t\t\tsettings.sorts.splice(index, 1);\n\n\t\t\t\t\t// Renumber priorities to maintain sequence\n\t\t\t\t\tsettings.sorts.forEach((sort, i) => {\n\t\t\t\t\t\tsort.priority = i + 1;\n\t\t\t\t\t});\n\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Removed sort criteria\", { target, index }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\treorderSortCriteria: (target: ExpansionTarget, fromIndex: number, toIndex: number) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tif (!settings.sorts) settings.sorts = [];\n\n\t\t\t\t\t// Move the item\n\t\t\t\t\tconst [movedItem] = settings.sorts.splice(fromIndex, 1);\n\t\t\t\t\tif (movedItem) {\n\t\t\t\t\t\tsettings.sorts.splice(toIndex, 0, movedItem);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Renumber priorities to maintain sequence\n\t\t\t\t\tsettings.sorts.forEach((sort, i) => {\n\t\t\t\t\t\tsort.priority = i + 1;\n\t\t\t\t\t});\n\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Reordered sort criteria\", { target, fromIndex, toIndex }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\taddFilterCriteria: (target: ExpansionTarget, criteria: FilterCriteria) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tif (!settings.filters) settings.filters = [];\n\t\t\t\t\tsettings.filters.push(criteria);\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Added filter criteria\", { target, criteria }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\tupdateFilterCriteria: (target: ExpansionTarget, index: number, criteriaUpdate: Partial<FilterCriteria>) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tif (!settings.filters) settings.filters = [];\n\t\t\t\t\tconst existingCriteria = settings.filters[index];\n\t\t\t\t\tif (existingCriteria) {\n\t\t\t\t\t\tsettings.filters[index] = { ...existingCriteria, ...criteriaUpdate };\n\t\t\t\t\t}\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Updated filter criteria\", { target, index, criteriaUpdate }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\tremoveFilterCriteria: (target: ExpansionTarget, index: number) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tif (!settings.filters) settings.filters = [];\n\t\t\t\t\tsettings.filters.splice(index, 1);\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Removed filter criteria\", { target, index }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\ttoggleFilterEnabled: (target: ExpansionTarget, index: number) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst settings = state.settings[target];\n\t\t\t\t\tif (!settings.filters) settings.filters = [];\n\t\t\t\t\tconst filter = settings.filters[index];\n\t\t\t\t\tif (filter) {\n\t\t\t\t\t\tfilter.enabled = !filter.enabled;\n\t\t\t\t\t}\n\t\t\t\t\tstate.settings[target] = settings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Toggled filter enabled\", { target, index }, \"ExpansionSettingsStore\");\n\t\t\t},\n\n\t\t\tgetSettingsSummary: (target: ExpansionTarget): string => {\n\t\t\t\tconst settings = get().settings[target];\n\n\t\t\t\tconst parts: string[] = [];\n\n\t\t\t\t// Add sort summary\n\t\t\t\tconst sorts = settings.sorts ?? [];\n\t\t\t\tif (sorts.length > 0) {\n\t\t\t\t\tconst sortSummary = sorts\n\t\t\t\t\t\t.sort((a, b) => a.priority - b.priority)\n\t\t\t\t\t\t.map(s => `${s.direction === \"desc\" ? \"↓\" : \"↑\"}${s.label || s.property}`)\n\t\t\t\t\t\t.join(\", \");\n\t\t\t\t\tparts.push(sortSummary);\n\t\t\t\t}\n\n\t\t\t\t// Add filter summary\n\t\t\t\tconst filters = settings.filters ?? [];\n\t\t\t\tconst enabledFilters = filters.filter(f => f.enabled);\n\t\t\t\tif (enabledFilters.length > 0) {\n\t\t\t\t\tparts.push(`${enabledFilters.length.toString()} filters`);\n\t\t\t\t}\n\n\t\t\t\t// Add limit\n\t\t\t\tconst limitValue = settings.limit ?? 0;\n\t\t\t\tparts.push(limitValue > 0 ? `${limitValue.toString()} max` : \"unlimited\");\n\n\t\t\t\treturn parts.join(\" | \");\n\t\t\t},\n\n\t\t\texportSettings: () => {\n\t\t\t\tconst {settings} = get();\n\t\t\t\treturn settings;\n\t\t\t},\n\n\t\t\timportSettings: (settingsObject: Record<string, ExpansionSettings>) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\t// Start with current settings and update only valid targets\n\t\t\t\t\tconst newSettings = { ...state.settings };\n\n\t\t\t\t\t// Copy only valid expansion targets (entity types or relation types)\n\t\t\t\t\tObject.entries(settingsObject).forEach(([key, value]) => {\n\t\t\t\t\t\t// Type guard for entity types\n\t\t\t\t\t\tfunction isEntityType(k: string): k is \"works\" | \"authors\" | \"sources\" | \"institutions\" | \"topics\" | \"concepts\" | \"publishers\" | \"funders\" | \"keywords\" {\n\t\t\t\t\t\t\treturn [\"works\", \"authors\", \"sources\", \"institutions\", \"topics\", \"concepts\", \"publishers\", \"funders\", \"keywords\"].includes(k);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Type guard for relation types\n\t\t\t\t\t\tfunction isRelationType(k: string): k is RelationType {\n\t\t\t\t\t\t\tconst relationTypes: string[] = Object.values(RelationType);\n\t\t\t\t\t\t\treturn relationTypes.includes(k);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isEntityType(key) || isRelationType(key)) {\n\t\t\t\t\t\t\tnewSettings[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tstate.settings = newSettings;\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"expansion\", \"Imported settings\", { count: Object.keys(settingsObject).length }, \"ExpansionSettingsStore\");\n\t\t\t}\n\t\t})),\n\t\t{\n\t\t\tname: \"academic-explorer-expansion-settings\",\n\t\t\tstorage: createJSONStorage(() => createHybridStorage({\n\t\t\t\tdbName: \"academic-explorer\",\n\t\t\t\tstoreName: \"expansion-settings\",\n\t\t\t\tversion: 1\n\t\t\t})),\n\t\t\tonRehydrateStorage: () => (state) => {\n\t\t\t\tif (state) {\n\t\t\t\t\tlogger.debug(\"expansion\", \"Rehydrated expansion settings from localStorage\", {\n\t\t\t\t\t\tsettingsCount: Object.keys(state.settings).length\n\t\t\t\t\t}, \"ExpansionSettingsStore\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t)\n);\n\n// Export a hook for getting settings for a specific target\nexport const useExpansionSettings = (target: ExpansionTarget) => {\n\treturn useExpansionSettingsStore((state) => state.getSettings(target));\n};\n\n// Export a hook for getting the settings summary\nexport const useExpansionSettingsSummary = (target: ExpansionTarget) => {\n\treturn useExpansionSettingsStore((state) => state.getSettingsSummary(target));\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/graph-store.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":421,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":421,"endColumn":17},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":426,"column":29,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":426,"endColumn":31,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[13099,13101],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":427,"column":28,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":427,"endColumn":30,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[13141,13143],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":440,"column":9,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":440,"endColumn":17},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":471,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":471,"endColumn":31},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removedFromSelection' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":488,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":488,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":594,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":594,"endColumn":102},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":594,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":594,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17887,17890],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17887,17890],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphAutoDetectedEdges on an `any` value.","line":594,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":594,"endColumn":66},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.","line":595,"column":7,"nodeType":"MemberExpression","messageId":"invalid","endLine":595,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .totalAdded on an `any` value.","line":595,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":595,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .lastBatch on an `any` value.","line":596,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":596,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":597,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":597,"endColumn":60},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":597,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":597,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18079,18082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18079,18082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .__graphAutoDetectedEdges on an `any` value.","line":597,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":597,"endColumn":47},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":653,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":653,"endColumn":31},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":699,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":699,"endColumn":31},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":720,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":720,"endColumn":31},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":876,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":876,"endColumn":36},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":896,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":896,"endColumn":36},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1052,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1052,"endColumn":34},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1068,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1068,"endColumn":34},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":1244,"column":22,"nodeType":null,"messageId":"preferOptionalChain","endLine":1244,"endColumn":66,"suggestions":[{"fix":{"range":[37277,37321],"text":"node.label?.includes(\"Loading\")"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":1336,"column":58,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":1336,"endColumn":91}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Graph store for provider-agnostic graph state management\n * Uses Zustand with Immer for immutable state updates that maintain stable references\n */\n\nimport { create } from \"zustand\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n// Using plain objects instead of Maps/Sets for stable references\n// No need for enableMapSet() with plain objects\nimport { createHybridStorage } from \"@academic-explorer/utils/storage\";\nimport type {\n\tGraphNode,\n\tGraphEdge,\n\tGraphProvider,\n\tProviderType,\n\tGraphLayout,\n\tEntityType,\n} from \"@academic-explorer/graph\";\nimport { RelationType } from \"@academic-explorer/graph\";\nimport { DEFAULT_FORCE_PARAMS } from \"@academic-explorer/graph\";\nimport { localEventBus, GraphEventType, EntityEventType } from \"@academic-explorer/graph\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport { useAnimatedGraphStore } from \"./animated-graph-store\";\n\n// Stable empty array for React 19 compatibility (prevents new object creation)\nconst EMPTY_ARRAY: GraphNode[] = [];\nconst EMPTY_EDGE_ARRAY: GraphEdge[] = [];\n\n// Helper function to create initial edge type stats\nconst createInitialEdgeTypeStats = () => ({\n\tvisible: {\n\t\t[RelationType.AUTHORED]: 0,\n\t\t[RelationType.AFFILIATED]: 0,\n\t\t[RelationType.PUBLISHED_IN]: 0,\n\t\t[RelationType.FUNDED_BY]: 0,\n\t\t[RelationType.REFERENCES]: 0,\n\t\t[RelationType.RELATED_TO]: 0,\n\t\t[RelationType.SOURCE_PUBLISHED_BY]: 0,\n\t\t[RelationType.INSTITUTION_CHILD_OF]: 0,\n\t\t[RelationType.PUBLISHER_CHILD_OF]: 0,\n\t\t[RelationType.WORK_HAS_TOPIC]: 0,\n\t\t[RelationType.WORK_HAS_KEYWORD]: 0,\n\t\t[RelationType.AUTHOR_RESEARCHES]: 0,\n\t\t[RelationType.INSTITUTION_LOCATED_IN]: 0,\n\t\t[RelationType.FUNDER_LOCATED_IN]: 0,\n\t\t[RelationType.TOPIC_PART_OF_FIELD]: 0\n\t},\n\ttotal: {\n\t\t[RelationType.AUTHORED]: 0,\n\t\t[RelationType.AFFILIATED]: 0,\n\t\t[RelationType.PUBLISHED_IN]: 0,\n\t\t[RelationType.FUNDED_BY]: 0,\n\t\t[RelationType.REFERENCES]: 0,\n\t\t[RelationType.RELATED_TO]: 0,\n\t\t[RelationType.SOURCE_PUBLISHED_BY]: 0,\n\t\t[RelationType.INSTITUTION_CHILD_OF]: 0,\n\t\t[RelationType.PUBLISHER_CHILD_OF]: 0,\n\t\t[RelationType.WORK_HAS_TOPIC]: 0,\n\t\t[RelationType.WORK_HAS_KEYWORD]: 0,\n\t\t[RelationType.AUTHOR_RESEARCHES]: 0,\n\t\t[RelationType.INSTITUTION_LOCATED_IN]: 0,\n\t\t[RelationType.FUNDER_LOCATED_IN]: 0,\n\t\t[RelationType.TOPIC_PART_OF_FIELD]: 0\n\t}\n});\n\ninterface GraphState {\n  // Data (library agnostic) - using plain objects for stable references\n  nodes: Record<string, GraphNode | undefined>;\n  edges: Record<string, GraphEdge | undefined>;\n\n  // Selection and interaction - using arrays/objects for stable references\n  selectedNodeId: string | null;\n  hoveredNodeId: string | null;\n  selectedNodes: Record<string, boolean>; // object instead of Set\n  pinnedNodes: Record<string, boolean>; // object instead of Set\n\n\n  // Cache visibility and traversal control\n  showAllCachedNodes: boolean;\n  traversalDepth: number;\n  nodeDepths: Record<string, number>; // object instead of Map\n\n  // Provider (can be swapped)\n  provider: GraphProvider | null;\n  providerType: ProviderType;\n\n  // Layout state\n  currentLayout: GraphLayout;\n\n  // Loading states\n  isLoading: boolean;\n  error: string | null;\n\n  // Entity type visibility and statistics - using objects for stable references\n  visibleEntityTypes: Record<EntityType, boolean>; // object instead of Set\n  lastSearchStats: Record<EntityType, number>; // object instead of Map\n\n  // Pre-computed statistics (cached to avoid getSnapshot infinite loops)\n  totalNodeCount: number;\n  totalEdgeCount: number;\n  entityTypeStats: {\n    visible: Record<EntityType, number>;\n    total: Record<EntityType, number>;\n    searchResults: Record<EntityType, number>;\n  };\n  edgeTypeStats: {\n    visible: Record<RelationType, number>;\n    total: Record<RelationType, number>;\n  };\n\n  // Edge type visibility\n  visibleEdgeTypes: Record<RelationType, boolean>; // object instead of Set\n\n  // Cached computed results (stable references for React 19 compatibility)\n  cachedVisibleNodes: GraphNode[];\n  cachedLoadingNodes: GraphNode[];\n  nodeNeighborsCache: Record<string, GraphNode[]>;\n  nodeEdgesCache: Record<string, GraphEdge[]>;\n\n  // Actions (work with any provider)\n  setProvider: (provider: GraphProvider) => void;\n  setProviderType: (type: ProviderType) => void;\n\n  // Layout management\n  setLayout: (layout: GraphLayout) => void;\n  applyCurrentLayout: () => void;\n\n  // Node management\n  addNode: (node: GraphNode) => void;\n  addNodes: (nodes: GraphNode[]) => void;\n  removeNode: (nodeId: string) => void;\n  updateNode: (nodeId: string, updates: Partial<GraphNode>) => void;\n  getNode: (nodeId: string) => GraphNode | undefined;\n\n  // Edge management\n  addEdge: (edge: GraphEdge) => void;\n  addEdges: (edges: GraphEdge[]) => void;\n  removeEdge: (edgeId: string) => void;\n  updateEdge: (edgeId: string, updates: Partial<GraphEdge>) => void;\n  getEdge: (edgeId: string) => GraphEdge | undefined;\n\n  // Selection\n  selectNode: (nodeId: string | null) => void;\n  hoverNode: (nodeId: string | null) => void;\n  addToSelection: (nodeId: string) => void;\n  removeFromSelection: (nodeId: string) => void;\n  clearSelection: () => void;\n\n  // Pinned node management - new multi-pin API\n  pinNode: (nodeId: string) => void;\n  unpinNode: (nodeId: string) => void;\n  clearAllPinnedNodes: () => void;\n  isPinned: (nodeId: string) => boolean;\n\n\n  // Cache visibility and traversal control\n  setShowAllCachedNodes: (show: boolean) => void;\n  setTraversalDepth: (depth: number) => void;\n  calculateNodeDepths: (originId: string) => void;\n  getNodesWithinDepth: (depth: number) => GraphNode[];\n\n  // Bulk operations\n  clear: () => void;\n  setGraphData: (nodes: GraphNode[], edges: GraphEdge[]) => void;\n\n  // Loading states\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n\n  // Entity type management\n  toggleEntityTypeVisibility: (entityType: EntityType) => void;\n  setEntityTypeVisibility: (entityType: EntityType, visible: boolean) => void;\n  setAllEntityTypesVisible: (visible: boolean) => void;\n  updateSearchStats: (stats: Record<EntityType, number>) => void;\n  recomputeEntityTypeStats: () => void;\n  recomputeEdgeTypeStats: () => void;\n  recomputeVisibleNodes: () => void;\n  recomputeLoadingNodes: () => void;\n  recomputeNodeCaches: () => void;\n  getEntityTypeStats: () => {\n    visible: Record<EntityType, number>;\n    total: Record<EntityType, number>;\n    searchResults: Record<EntityType, number>;\n  };\n  getVisibleNodes: () => GraphNode[];\n\n  // Edge type management\n  toggleEdgeTypeVisibility: (edgeType: RelationType) => void;\n  setEdgeTypeVisibility: (edgeType: RelationType, visible: boolean) => void;\n  setAllEdgeTypesVisible: (visible: boolean) => void;\n\n  // Loading state management\n  markNodeAsLoading: (nodeId: string, loading?: boolean) => void;\n  clearNodeLoading: (nodeId: string) => void;\n\n  // Graph queries (provider agnostic)\n  getNeighbors: (nodeId: string) => GraphNode[];\n  getConnectedEdges: (nodeId: string) => GraphEdge[];\n  findShortestPath: (sourceId: string, targetId: string) => string[];\n  getConnectedComponent: (nodeId: string) => string[];\n\n  // Incremental hydration support\n  markNodeAsLoaded: (nodeId: string, fullData: Partial<GraphNode>) => void;\n  markNodeAsError: (nodeId: string) => void;\n  getPlaceholderNodes: () => GraphNode[]; // Legacy - returns minimal nodes\n  getMinimalNodes: () => GraphNode[];\n  getFullyHydratedNodes: () => GraphNode[];\n  getLoadingNodes: () => GraphNode[];\n  hasPlaceholderOrLoadingNodes: () => boolean;\n}\n\nexport const useGraphStore = create<GraphState>()(\n\tpersist(\n\t\timmer((set, get) => ({\n\t\t\t// Initial state - using plain objects for stable references\n\t\t\tnodes: {},\n\t\t\tedges: {},\n\t\t\tselectedNodeId: null,\n\t\t\thoveredNodeId: null,\n\t\t\tselectedNodes: {},\n\t\t\tpinnedNodes: {},\n\t\t\tshowAllCachedNodes: false,\n\t\t\ttraversalDepth: 1,\n\t\t\tnodeDepths: {},\n\t\t\tprovider: null,\n\t\t\tproviderType: \"xyflow\",\n\t\t\tvisibleEntityTypes: {\n\t\t\t\tworks: true,\n\t\t\t\tauthors: true,\n\t\t\t\tsources: true,\n\t\t\t\tinstitutions: true,\n\t\t\t\ttopics: true,\n\t\t\t\tconcepts: true,\n\t\t\t\tpublishers: true,\n\t\t\t\tfunders: true,\n\t\t\t\tkeywords: true\n\t\t\t},\n\t\t\tlastSearchStats: {\n\t\t\t\tconcepts: 0,\n\t\t\t\ttopics: 0,\n\t\t\t\tkeywords: 0,\n\t\t\t\tworks: 0,\n\t\t\t\tauthors: 0,\n\t\t\t\tsources: 0,\n\t\t\t\tinstitutions: 0,\n\t\t\t\tpublishers: 0,\n\t\t\t\tfunders: 0\n\t\t\t},\n\t\t\tvisibleEdgeTypes: {\n\t\t\t\t[RelationType.AUTHORED]: true,\n\t\t\t\t[RelationType.AFFILIATED]: true,\n\t\t\t\t[RelationType.PUBLISHED_IN]: true,\n\t\t\t\t[RelationType.FUNDED_BY]: true,\n\t\t\t\t[RelationType.REFERENCES]: true,\n\t\t\t\t[RelationType.RELATED_TO]: true,\n\t\t\t\t[RelationType.SOURCE_PUBLISHED_BY]: true,\n\t\t\t\t[RelationType.INSTITUTION_CHILD_OF]: true,\n\t\t\t\t[RelationType.PUBLISHER_CHILD_OF]: true,\n\t\t\t\t[RelationType.WORK_HAS_TOPIC]: true,\n\t\t\t\t[RelationType.WORK_HAS_KEYWORD]: true,\n\t\t\t\t[RelationType.AUTHOR_RESEARCHES]: true,\n\t\t\t\t[RelationType.INSTITUTION_LOCATED_IN]: true,\n\t\t\t\t[RelationType.FUNDER_LOCATED_IN]: true,\n\t\t\t\t[RelationType.TOPIC_PART_OF_FIELD]: true\n\t\t\t},\n\n\t\t\t// Cached computed results (stable references for React 19 compatibility)\n\t\t\tcachedVisibleNodes: [],\n\t\t\tcachedLoadingNodes: [],\n\t\t\tnodeNeighborsCache: {},\n\t\t\tnodeEdgesCache: {},\n\n\t\t\tcurrentLayout: {\n\t\t\t\ttype: \"d3-force\",\n\t\t\t\toptions: {\n\t\t\t\t\titerations: 300,\n\t\t\t\t\t...DEFAULT_FORCE_PARAMS,\n\t\t\t\t\talpha: 1,\n\t\t\t\t}\n\t\t\t},\n\t\t\tisLoading: false,\n\t\t\terror: null,\n\n\t\t\t// Pre-computed statistics (cached to avoid getSnapshot infinite loops)\n\t\t\ttotalNodeCount: 0,\n\t\t\ttotalEdgeCount: 0,\n\t\t\tentityTypeStats: {\n\t\t\t\tvisible: {\n\t\t\t\t\tconcepts: 0,\n\t\t\t\t\ttopics: 0,\n\t\t\t\t\tkeywords: 0,\n\t\t\t\t\tworks: 0,\n\t\t\t\t\tauthors: 0,\n\t\t\t\t\tsources: 0,\n\t\t\t\t\tinstitutions: 0,\n\t\t\t\t\tpublishers: 0,\n\t\t\t\t\tfunders: 0\n\t\t\t\t},\n\t\t\t\ttotal: {\n\t\t\t\t\tconcepts: 0,\n\t\t\t\t\ttopics: 0,\n\t\t\t\t\tkeywords: 0,\n\t\t\t\t\tworks: 0,\n\t\t\t\t\tauthors: 0,\n\t\t\t\t\tsources: 0,\n\t\t\t\t\tinstitutions: 0,\n\t\t\t\t\tpublishers: 0,\n\t\t\t\t\tfunders: 0\n\t\t\t\t},\n\t\t\t\tsearchResults: {\n\t\t\t\t\tconcepts: 0,\n\t\t\t\t\ttopics: 0,\n\t\t\t\t\tkeywords: 0,\n\t\t\t\t\tworks: 0,\n\t\t\t\t\tauthors: 0,\n\t\t\t\t\tsources: 0,\n\t\t\t\t\tinstitutions: 0,\n\t\t\t\t\tpublishers: 0,\n\t\t\t\t\tfunders: 0\n\t\t\t\t}\n\t\t\t},\n\t\t\tedgeTypeStats: createInitialEdgeTypeStats(),\n\n\t\t\t// Provider management\n\t\t\tsetProvider: (provider) => {\n\t\t\t\tconst state = get();\n\n\t\t\t\t// Don't update if it's the same provider instance\n\t\t\t\tif (state.provider === provider) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set nodes and edges on the new provider outside of the Zustand set call\n\t\t\t\t// Type guard for filtering out undefined nodes\n\t\t\t\tfunction isValidNode(node: GraphNode | undefined): node is GraphNode {\n\t\t\t\t\treturn node !== undefined;\n\t\t\t\t}\n\n\t\t\t\t// Type guard for filtering out undefined edges\n\t\t\t\tfunction isValidEdge(edge: GraphEdge | undefined): edge is GraphEdge {\n\t\t\t\t\treturn edge !== undefined;\n\t\t\t\t}\n\n\t\t\t\tprovider.setNodes(Object.values(state.nodes).filter(isValidNode));\n\t\t\t\tprovider.setEdges(Object.values(state.edges).filter(isValidEdge));\n\n\t\t\t\t// Only update the provider in the store\n\t\t\t\tset({ provider });\n\t\t\t},\n\n\t\t\tsetProviderType: (type) => set({ providerType: type }),\n\n\t\t\t// Layout management\n\t\t\tsetLayout: (layout) => {\n\t\t\t\tset({ currentLayout: layout });\n\t\t\t\tconst state = get();\n\t\t\t\tstate.provider?.applyLayout(layout);\n\t\t\t},\n\n\t\t\tapplyCurrentLayout: () => {\n\t\t\t\tconst state = get();\n\t\t\t\tstate.provider?.applyLayout(state.currentLayout);\n\t\t\t},\n\n\t\t\t// Node management\n\t\t\taddNode: (node) => {\n\t\t\t\tconst existingNode = get().nodes[node.id];\n\t\t\t\tconst wasAdded = !existingNode;\n\n\t\t\t\tset((draft) => {\n\t\t\t\t\tdraft.nodes[node.id] = node;\n\t\t\t\t\tdraft.provider?.addNode(node);\n\t\t\t\t});\n\n\t\t\t\t// Unpin new nodes to allow movement\n\t\t\t\tget().unpinNode(node.id);\n\n\t\t\t\t// Only restart simulation if a new node was actually added\n\t\t\t\tif (wasAdded) {\n\t\t\t\t\t// Request layout restart when node is added to apply node forces\n\t\t\t\t\tconst animatedStore = useAnimatedGraphStore.getState();\n\t\t\t\t\tanimatedStore.requestRestart();\n\t\t\t\t\tlogger.debug(\"graph\", \"Requested layout restart after adding new node\", {\n\t\t\t\t\t\tnodeId: node.id,\n\t\t\t\t\t\tentityType: node.type\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recompute caches after single node addition\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEntityTypeStats();\n\t\t\t\tstate.recomputeVisibleNodes();\n\t\t\t\tstate.recomputeLoadingNodes();\n\t\t\t\tstate.recomputeNodeCaches();\n\n\t\t\t\t// Emit cross-context events\n\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\ttype: GraphEventType.ANY_NODE_ADDED,\n\t\t\t\t\tpayload: node\n\t\t\t\t});\n\t\t\t},\n\n\t\t\taddNodes: (nodes) => {\n\t\t\t\t// Check which nodes are actually new before adding\n\t\t\t\tconst currentNodes = get().nodes;\n\t\t\t\tconst newNodes = nodes.filter(node => !currentNodes[node.id]);\n\n\t\t\t\tset((draft) => {\n\t\t\t\t\tnodes.forEach(node => {\n\t\t\t\t\t\tdraft.nodes[node.id] = node;\n\t\t\t\t\t\tdraft.provider?.addNode(node);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// Unpin new nodes to allow movement\n\t\t\t\tnodes.forEach(node => { get().unpinNode(node.id); });\n\n\t\t\t\t// Only restart simulation if new nodes were actually added\n\t\t\t\tif (newNodes && newNodes.length > 0) {\n\t\t\t\t\t// Request layout restart when nodes are added to apply node forces\n\t\t\t\t\tconst animatedStore = useAnimatedGraphStore.getState();\n\t\t\t\t\tanimatedStore.requestRestart();\n\t\t\t\t\tlogger.debug(\"graph\", \"Requested layout restart after adding new nodes\", {\n\t\t\t\t\t\tnewNodeCount: newNodes?.length || 0,\n\t\t\t\t\t\ttotalNodeCount: nodes?.length || 0,\n\t\t\t\t\t\tnewNodeTypes: [...new Set(newNodes.map(node => node.type))]\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recompute cached statistics after data change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEntityTypeStats();\n\t\t\t\tstate.recomputeVisibleNodes();\n\t\t\t\tstate.recomputeLoadingNodes();\n\t\t\t\tstate.recomputeNodeCaches();\n\n\t\t\t\t// Emit cross-context events for new nodes only\n\t\t\t\tif (newNodes && newNodes.length > 0) {\n\t\t\t\t\tif (newNodes.length === 1) {\n\t\t\t\t\t\t// Single node event for consistency\n\t\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\t\ttype: GraphEventType.ANY_NODE_ADDED,\n\t\t\t\t\t\t\tpayload: newNodes[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Bulk nodes event for performance\n\t\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\t\ttype: GraphEventType.BULK_NODES_ADDED,\n\t\t\t\t\t\t\tpayload: { nodes: newNodes }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tremoveNode: (nodeId) => {\n\t\t\t\tlet removedNodeData: { entityId: string; type: EntityType } | undefined;\n\n\t\t\t\tset((draft) => {\n\t\t\t\t\t// Store removed node data for event emission (extract values before proxy revocation)\n\t\t\t\t\tconst removedNode = draft.nodes[nodeId];\n\t\t\t\t\tif (removedNode) {\n\t\t\t\t\t\tremovedNodeData = {\n\t\t\t\t\t\t\tentityId: removedNode.entityId,\n\t\t\t\t\t\t\ttype: removedNode.type\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove node\n\t\t\t\t\tconst { [nodeId]: removed, ...remainingNodes } = draft.nodes;\n\t\t\t\t\tdraft.nodes = remainingNodes;\n\t\t\t\t\tdraft.provider?.removeNode(nodeId);\n\n\t\t\t\t\t// Remove connected edges\n\t\t\t\t\tconst edgeEntries = Object.entries(draft.edges).filter((entry): entry is [string, GraphEdge] => entry[1] != null);\n\t\t\t\t\tconst remainingEdges: Record<string, GraphEdge> = {};\n\t\t\t\t\tedgeEntries.forEach(([edgeId, edge]) => {\n\t\t\t\t\t\tif (edge.source === nodeId || edge.target === nodeId) {\n\t\t\t\t\t\t\tdraft.provider?.removeEdge(edge.id);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tremainingEdges[edgeId] = edge;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdraft.edges = remainingEdges;\n\n\t\t\t\t\t// Clear selection if removed\n\t\t\t\t\tconst { [nodeId]: removedFromSelection, ...remainingSelection } = draft.selectedNodes;\n\t\t\t\t\tdraft.selectedNodes = remainingSelection;\n\t\t\t\t\tif (draft.selectedNodeId === nodeId) {\n\t\t\t\t\t\tdraft.selectedNodeId = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (draft.hoveredNodeId === nodeId) {\n\t\t\t\t\t\tdraft.hoveredNodeId = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Recompute cached statistics after data change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEntityTypeStats();\n\t\t\t\tstate.recomputeEdgeTypeStats();\n\t\t\t\tstate.recomputeVisibleNodes();\n\t\t\t\tstate.recomputeLoadingNodes();\n\t\t\t\tstate.recomputeNodeCaches();\n\n\t\t\t\t// Emit cross-context events\n\t\t\t\tif (removedNodeData) {\n\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\ttype: GraphEventType.ANY_NODE_REMOVED,\n\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\tnodeId,\n\t\t\t\t\t\t\tentityId: removedNodeData.entityId,\n\t\t\t\t\t\t\tentityType: removedNodeData.type\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\ttype: EntityEventType.ENTITY_REMOVED,\n\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\tentityId: removedNodeData.entityId,\n\t\t\t\t\t\t\tentityType: removedNodeData.type,\n\t\t\t\t\t\t\tnodeId\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tupdateNode: (nodeId, updates) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst existingNode = draft.nodes[nodeId];\n\t\t\t\t\tif (existingNode) {\n\t\t\t\t\t\tconst updatedNode = { ...existingNode, ...updates };\n\t\t\t\t\t\tdraft.nodes[nodeId] = updatedNode;\n\t\t\t\t\t\t// Note: Provider update would need to be handled by provider\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tgetNode: (nodeId) => {\n\t\t\t\treturn get().nodes[nodeId];\n\t\t\t},\n\n\t\t\t// Edge management\n\t\t\taddEdge: (edge) => {\n\t\t\t\tconst existingEdge = get().edges[edge.id];\n\t\t\t\tconst wasAdded = !existingEdge;\n\n\t\t\t\tset((draft) => {\n\t\t\t\t\tdraft.edges[edge.id] = edge;\n\t\t\t\t\tdraft.provider?.addEdge(edge);\n\t\t\t\t});\n\n\t\t\t\t// Only restart simulation if a new edge was actually added\n\t\t\t\tif (wasAdded) {\n\t\t\t\t\t// Request layout restart when edge is added to apply edge forces\n\t\t\t\t\tconst animatedStore = useAnimatedGraphStore.getState();\n\t\t\t\t\tanimatedStore.requestRestart();\n\t\t\t\t\tlogger.debug(\"graph\", \"Requested layout restart after adding new edge\", {\n\t\t\t\t\t\tedgeType: edge.type,\n\t\t\t\t\t\tedgeId: edge.id\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recompute node caches after single edge addition\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEdgeTypeStats();\n\t\t\t\tstate.recomputeNodeCaches();\n\n\t\t\t\t// Emit cross-context events\n\t\t\t\tif (wasAdded) {\n\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\ttype: GraphEventType.ANY_EDGE_ADDED,\n\t\t\t\t\t\tpayload: edge\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddEdges: (edges) => {\n\t\t\t\t// Check which edges are actually new before adding\n\t\t\t\tconst currentEdges = get().edges;\n\t\t\t\tconst newEdges = edges.filter(edge => !currentEdges[edge.id]);\n\n\n\t\t\t\tset((draft) => {\n\t\t\t\t\tedges.forEach(edge => {\n\t\t\t\t\t\tdraft.edges[edge.id] = edge;\n\t\t\t\t\t\tdraft.provider?.addEdge(edge);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// Only restart simulation if new edges were actually added\n\t\t\t\tif (newEdges.length > 0) {\n\t\t\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\t\t\tconst debugState = (window as any).__graphAutoDetectedEdges ?? { totalAdded: 0, lastBatch: [] };\n\t\t\t\t\t\tdebugState.totalAdded += newEdges.length;\n\t\t\t\t\t\tdebugState.lastBatch = newEdges.map(edge => edge.id);\n\t\t\t\t\t\t(window as any).__graphAutoDetectedEdges = debugState;\n\t\t\t\t\t}\n\t\t\t\t\t// FORCE REHEAT for auto-detected edges that arrive after simulation has settled\n\t\t\t\t\t// The weak requestRestart() is not sufficient for settled simulations\n\t\t\t\t\tlogger.debug(\"graph\", \"Store force reheating simulation for new edges\", {\n\t\t\t\t\t\tnewEdgeCount: newEdges.length,\n\t\t\t\t\t\ttotalEdgeCount: edges.length,\n\t\t\t\t\t\tnewEdgeTypes: [...new Set(newEdges.map(edge => edge.type))]\n\t\t\t\t\t});\n\n\t\t\t\t\t// Use both approaches: requestRestart for normal flow + direct reheat for settled simulations\n\t\t\t\t\tconst animatedStore = useAnimatedGraphStore.getState();\n\t\t\t\t\tanimatedStore.requestRestart();\n\n\t\t\t\t\t// Also trigger immediate reheat with events for settled simulations\n\t\t\t\t\tif (typeof window !== \"undefined\" && newEdges.length > 0) {\n\t\t\t\t\t\t// Force immediate reheat for any new edges to settled simulations\n\t\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\t\ttype: GraphEventType.FORCE_LAYOUT_RESTART,\n\t\t\t\t\t\t\tpayload: { reason: \"auto-detected-edges\", alpha: 1.0 }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Recompute cached statistics after data change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEdgeTypeStats();\n\t\t\t\tstate.recomputeNodeCaches();\n\n\t\t\t\t// Emit cross-context events for edges (both new and existing to trigger simulation updates)\n\t\t\t\tif (edges.length > 0) {\n\t\t\t\t\t// Always emit events for simulation updates, even for existing edges\n\t\t\t\t\t// This ensures forces are applied when edges are \"added\" to a running simulation\n\t\t\t\t\tif (edges.length === 1) {\n\t\t\t\t\t\t// Single edge event for consistency\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Store emitting ANY_EDGE_ADDED\", { edge: edges[0], wasNew: newEdges.length > 0 });\n\t\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\t\ttype: GraphEventType.ANY_EDGE_ADDED,\n\t\t\t\t\t\t\tpayload: edges[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Bulk edges event for performance\n\t\t\t\t\t\tlogger.debug(\"graph\", \"Store emitting BULK_EDGES_ADDED\", {\n\t\t\t\t\t\t\tedgeCount: edges.length,\n\t\t\t\t\t\t\tnewCount: newEdges.length\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlocalEventBus.emit({\n\t\t\t\t\t\t\ttype: GraphEventType.BULK_EDGES_ADDED,\n\t\t\t\t\t\t\tpayload: { edges }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tremoveEdge: (edgeId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst { [edgeId]: removed, ...remaining } = draft.edges;\n\t\t\t\t\tdraft.edges = remaining;\n\t\t\t\t\tdraft.provider?.removeEdge(edgeId);\n\t\t\t\t});\n\t\t\t\t// Recompute cached statistics after data change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEdgeTypeStats();\n\t\t\t\tstate.recomputeNodeCaches();\n\t\t\t},\n\n\t\t\tupdateEdge: (edgeId, updates) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst existingEdge = draft.edges[edgeId];\n\t\t\t\t\tif (existingEdge) {\n\t\t\t\t\t\tconst updatedEdge = { ...existingEdge, ...updates };\n\t\t\t\t\t\tdraft.edges[edgeId] = updatedEdge;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// Recompute cached statistics after data change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEdgeTypeStats();\n\t\t\t\tstate.recomputeNodeCaches();\n\t\t\t},\n\n\t\t\tgetEdge: (edgeId) => {\n\t\t\t\treturn get().edges[edgeId];\n\t\t\t},\n\n\t\t\t// Selection\n\t\t\tselectNode: (nodeId) => {\n\t\t\t\tconst currentState = get();\n\t\t\t\tif (currentState.selectedNodeId !== nodeId) {\n\t\t\t\t\tset({ selectedNodeId: nodeId });\n\t\t\t\t}\n\t\t\t},\n\n\t\t\thoverNode: (nodeId) => set({ hoveredNodeId: nodeId }),\n\n\t\t\taddToSelection: (nodeId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tdraft.selectedNodes[nodeId] = true;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tremoveFromSelection: (nodeId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst { [nodeId]: removed, ...remaining } = draft.selectedNodes;\n\t\t\t\t\tdraft.selectedNodes = remaining;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tclearSelection: () => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tdraft.selectedNodeId = null;\n\t\t\t\t\tdraft.selectedNodes = {};\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Multi-pin node management (new API)\n\t\t\tpinNode: (nodeId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tdraft.pinnedNodes[nodeId] = true;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tunpinNode: (nodeId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst { [nodeId]: removed, ...remaining } = draft.pinnedNodes;\n\t\t\t\t\tdraft.pinnedNodes = remaining;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tclearAllPinnedNodes: () => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tdraft.pinnedNodes = {};\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tisPinned: (nodeId) => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.pinnedNodes[nodeId] ?? false;\n\t\t\t},\n\n\n\t\t\t// Cache visibility and traversal control\n\t\t\tsetShowAllCachedNodes: (show) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tdraft.showAllCachedNodes = show;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetTraversalDepth: (depth) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\t// Ensure valid depth (minimum 1, allow Infinity)\n\t\t\t\t\tconst validDepth = Math.max(1, depth);\n\t\t\t\t\tdraft.traversalDepth = validDepth;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tcalculateNodeDepths: (originId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst { edges } = draft;\n\t\t\t\t\tconst depths: Record<string, number> = {};\n\n\t\t\t\t\t// BFS to calculate distances from origin\n\t\t\t\t\tconst queue: Array<{ nodeId: string; depth: number }> = [{ nodeId: originId, depth: 0 }];\n\t\t\t\t\tconst visited: Record<string, boolean> = {};\n\n\t\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\t\tconst current = queue.shift();\n\t\t\t\t\t\tif (!current) continue;\n\n\t\t\t\t\t\tconst { nodeId, depth } = current;\n\t\t\t\t\t\tif (visited[nodeId]) continue;\n\n\t\t\t\t\t\tvisited[nodeId] = true;\n\t\t\t\t\t\tdepths[nodeId] = depth;\n\n\t\t\t\t\t\t// Find connected nodes\n\t\t\t\t\t\tObject.values(edges).filter((edge): edge is NonNullable<typeof edge> => edge != null).forEach(edge => {\n\t\t\t\t\t\t\tlet neighbor: string | null = null;\n\t\t\t\t\t\t\tif (edge.source === nodeId && !visited[edge.target]) {\n\t\t\t\t\t\t\t\tneighbor = edge.target;\n\t\t\t\t\t\t\t} else if (edge.target === nodeId && !visited[edge.source]) {\n\t\t\t\t\t\t\t\tneighbor = edge.source;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (neighbor) {\n\t\t\t\t\t\t\t\tqueue.push({ nodeId: neighbor, depth: depth + 1 });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tdraft.nodeDepths = depths;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tgetNodesWithinDepth: (depth) => {\n\t\t\t\tconst { nodes, nodeDepths } = get();\n\t\t\t\tconst nodeValues = Object.values(nodes).filter((node): node is NonNullable<typeof node> => node != null);\n\t\t\t\tif (depth === Infinity) {\n\t\t\t\t\treturn nodeValues;\n\t\t\t\t}\n\n\t\t\t\treturn nodeValues.filter(node => {\n\t\t\t\t\tconst nodeDepth = nodeDepths[node.id];\n\t\t\t\t\treturn nodeDepth !== undefined && nodeDepth <= depth;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Bulk operations\n\t\t\tclear: () => {\n\t\t\t\tconst { provider } = get();\n\t\t\t\tprovider?.clear();\n\t\t\t\tset({\n\t\t\t\t\tnodes: {},\n\t\t\t\t\tedges: {},\n\t\t\t\t\tselectedNodeId: null,\n\t\t\t\t\thoveredNodeId: null,\n\t\t\t\t\tselectedNodes: {},\n\t\t\t\t\tpinnedNodes: {},\n\t\t\t\t\tnodeDepths: {},\n\t\t\t\t\t// Clear cached state\n\t\t\t\t\tcachedVisibleNodes: [],\n\t\t\t\t\tcachedLoadingNodes: [],\n\t\t\t\t\tnodeNeighborsCache: {},\n\t\t\t\t\tnodeEdgesCache: {},\n\t\t\t\t\tedgeTypeStats: createInitialEdgeTypeStats(),\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetGraphData: (nodes, edges) => {\n\t\t\t\tconst { provider } = get();\n\t\t\t\tconst nodesRecord: Record<string, GraphNode> = {};\n\t\t\t\tconst edgesRecord: Record<string, GraphEdge> = {};\n\n\t\t\t\tnodes.forEach(node => {\n\t\t\t\t\tnodesRecord[node.id] = node;\n\t\t\t\t});\n\t\t\t\tedges.forEach(edge => {\n\t\t\t\t\tedgesRecord[edge.id] = edge;\n\t\t\t\t});\n\n\t\t\t\tif (provider) {\n\t\t\t\t\tprovider.setNodes(nodes);\n\t\t\t\t\tprovider.setEdges(edges);\n\t\t\t\t}\n\n\t\t\t\tset({\n\t\t\t\t\tnodes: nodesRecord,\n\t\t\t\t\tedges: edgesRecord,\n\t\t\t\t\tselectedNodeId: null,\n\t\t\t\t\thoveredNodeId: null,\n\t\t\t\t\tselectedNodes: {}, // Clear selected nodes on data change\n\t\t\t\t\tpinnedNodes: {}, // Clear pinned nodes on data change\n\t\t\t\t\tnodeDepths: {}, // Clear depths, will be recalculated when needed\n\t\t\t\t\t// Clear cached state as data has changed\n\t\t\t\t\tcachedVisibleNodes: [],\n\t\t\t\t\tcachedLoadingNodes: [],\n\t\t\t\t\tnodeNeighborsCache: {},\n\t\t\t\t\tnodeEdgesCache: {},\n\t\t\t\t\tedgeTypeStats: createInitialEdgeTypeStats(),\n\t\t\t\t});\n\n\t\t\t\t// Unpin all nodes on graph load to allow movement\n\t\t\t\tget().clearAllPinnedNodes();\n\n\t\t\t\t// Recompute all caches after setting new data\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeVisibleNodes();\n\t\t\t\tstate.recomputeNodeCaches();\n\t\t\t\tstate.recomputeEdgeTypeStats();\n\t\t\t},\n\n\t\t\t// Loading states\n\t\t\tsetLoading: (loading) => set({ isLoading: loading }),\n\t\t\tsetError: (error) => set({ error }),\n\n\t\t\t// Entity type management\n\t\t\ttoggleEntityTypeVisibility: (entityType) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst newVisibleTypes: Record<EntityType, boolean> = { ...state.visibleEntityTypes };\n\t\t\t\t\tif (newVisibleTypes[entityType]) {\n\t\t\t\t\t\tconst { [entityType]: removed, ...remaining } = newVisibleTypes;\n\t\t\t\t\t\treturn { visibleEntityTypes: remaining };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewVisibleTypes[entityType] = true;\n\t\t\t\t\t\treturn { visibleEntityTypes: newVisibleTypes };\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// Recompute cached statistics after visibility change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEntityTypeStats();\n\t\t\t\tstate.recomputeVisibleNodes();\n\t\t\t},\n\n\t\t\tsetEntityTypeVisibility: (entityType, visible) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst newVisibleTypes: Record<EntityType, boolean> = { ...state.visibleEntityTypes };\n\t\t\t\t\tif (visible) {\n\t\t\t\t\t\tnewVisibleTypes[entityType] = true;\n\t\t\t\t\t\treturn { visibleEntityTypes: newVisibleTypes };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst { [entityType]: removed, ...remaining } = newVisibleTypes;\n\t\t\t\t\t\treturn { visibleEntityTypes: remaining };\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// Recompute cached statistics after visibility change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEntityTypeStats();\n\t\t\t\tstate.recomputeVisibleNodes();\n\t\t\t},\n\n\t\t\tsetAllEntityTypesVisible: (visible) => {\n\t\t\t\tconst visibleTypes: Record<EntityType, boolean> = {\n\t\t\t\t\tconcepts: visible,\n\t\t\t\t\ttopics: visible,\n\t\t\t\t\tkeywords: visible,\n\t\t\t\t\tworks: visible,\n\t\t\t\t\tauthors: visible,\n\t\t\t\t\tsources: visible,\n\t\t\t\t\tinstitutions: visible,\n\t\t\t\t\tpublishers: visible,\n\t\t\t\t\tfunders: visible\n\t\t\t\t};\n\t\t\t\tset({\n\t\t\t\t\tvisibleEntityTypes: visibleTypes\n\t\t\t\t});\n\t\t\t\t// Recompute cached statistics after visibility change\n\t\t\t\tconst state = get();\n\t\t\t\tstate.recomputeEntityTypeStats();\n\t\t\t\tstate.recomputeVisibleNodes();\n\t\t\t},\n\n\t\t\tupdateSearchStats: (stats) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tstate.lastSearchStats = stats;\n\t\t\t\t\t// Also update the cached search results in entityTypeStats\n\t\t\t\t\tstate.entityTypeStats.searchResults = stats;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\trecomputeVisibleNodes: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst { nodes, visibleEntityTypes } = state;\n\t\t\t\t\tstate.cachedVisibleNodes = Object.values(nodes).filter((node): node is GraphNode =>\n\t\t\t\t\t\tnode !== undefined && visibleEntityTypes[node.type]\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\n\t\t\trecomputeLoadingNodes: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst { nodes } = state;\n\t\t\t\t\tstate.cachedLoadingNodes = Object.values(nodes).filter((node): node is GraphNode =>\n\t\t\t\t\t\tnode !== undefined && typeof node.label === \"string\" && node.label.includes(\"Loading\")\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\n\t\t\trecomputeNodeCaches: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst { nodes, edges } = state;\n\t\t\t\t\tconst newNeighborsCache: Record<string, GraphNode[]> = {};\n\t\t\t\t\tconst newEdgesCache: Record<string, GraphEdge[]> = {};\n\n\t\t\t\t\t// Clear and rebuild node-specific caches\n\t\t\t\t\tObject.keys(nodes).forEach(nodeId => {\n\t\t\t\t\t\tconst neighbors: GraphNode[] = [];\n\t\t\t\t\t\tconst connectedEdges: GraphEdge[] = [];\n\n\t\t\t\t\t\tObject.values(edges).forEach(edge => {\n\t\t\t\t\t\t\tif (!edge) return;\n\n\t\t\t\t\t\t\t// Collect connected edges\n\t\t\t\t\t\t\tif (edge.source === nodeId || edge.target === nodeId) {\n\t\t\t\t\t\t\t\tconnectedEdges.push(edge);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Collect neighbor nodes\n\t\t\t\t\t\t\tif (edge.source === nodeId) {\n\t\t\t\t\t\t\t\tconst neighbor = nodes[edge.target];\n\t\t\t\t\t\t\t\tif (neighbor) neighbors.push(neighbor);\n\t\t\t\t\t\t\t} else if (edge.target === nodeId) {\n\t\t\t\t\t\t\t\tconst neighbor = nodes[edge.source];\n\t\t\t\t\t\t\t\tif (neighbor) neighbors.push(neighbor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tnewNeighborsCache[nodeId] = neighbors;\n\t\t\t\t\t\tnewEdgesCache[nodeId] = connectedEdges;\n\t\t\t\t\t});\n\n\t\t\t\t\tstate.nodeNeighborsCache = newNeighborsCache;\n\t\t\t\t\tstate.nodeEdgesCache = newEdgesCache;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\trecomputeEntityTypeStats: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\t// Initialize with all entity types set to 0\n\t\t\t\t\tconst total: Record<EntityType, number> = {\n\t\t\t\t\t\tconcepts: 0,\n\t\t\t\t\t\ttopics: 0,\n\t\t\t\t\t\tkeywords: 0,\n\t\t\t\t\t\tworks: 0,\n\t\t\t\t\t\tauthors: 0,\n\t\t\t\t\t\tsources: 0,\n\t\t\t\t\t\tinstitutions: 0,\n\t\t\t\t\t\tpublishers: 0,\n\t\t\t\t\t\tfunders: 0\n\t\t\t\t\t};\n\t\t\t\t\tconst visible: Record<EntityType, number> = {\n\t\t\t\t\t\tconcepts: 0,\n\t\t\t\t\t\ttopics: 0,\n\t\t\t\t\t\tkeywords: 0,\n\t\t\t\t\t\tworks: 0,\n\t\t\t\t\t\tauthors: 0,\n\t\t\t\t\t\tsources: 0,\n\t\t\t\t\t\tinstitutions: 0,\n\t\t\t\t\t\tpublishers: 0,\n\t\t\t\t\t\tfunders: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Count total and visible nodes by type\n\t\t\t\t\tconst nodeValues = Object.values(state.nodes).filter((node): node is GraphNode => node !== undefined);\n\t\t\t\t\tnodeValues.forEach(node => {\n\t\t\t\t\t\ttotal[node.type] = (total[node.type] || 0) + 1;\n\n\t\t\t\t\t\tif (state.visibleEntityTypes[node.type]) {\n\t\t\t\t\t\t\tvisible[node.type] = (visible[node.type] || 0) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update cached statistics including total counts\n\t\t\t\t\tstate.totalNodeCount = nodeValues.length;\n\t\t\t\t\tstate.entityTypeStats = {\n\t\t\t\t\t\ttotal,\n\t\t\t\t\t\tvisible,\n\t\t\t\t\t\tsearchResults: state.lastSearchStats\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tgetEntityTypeStats: () => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.entityTypeStats;\n\t\t\t},\n\n\t\t\tgetVisibleNodes: () => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.cachedVisibleNodes;\n\t\t\t},\n\n\t\t\t// Edge type management\n\t\t\ttoggleEdgeTypeVisibility: (edgeType) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst newVisibleTypes: Record<RelationType, boolean> = { ...state.visibleEdgeTypes };\n\t\t\t\t\tif (newVisibleTypes[edgeType]) {\n\t\t\t\t\t\tconst { [edgeType]: removed, ...remaining } = newVisibleTypes;\n\t\t\t\t\t\treturn { visibleEdgeTypes: remaining };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewVisibleTypes[edgeType] = true;\n\t\t\t\t\t\treturn { visibleEdgeTypes: newVisibleTypes };\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetEdgeTypeVisibility: (edgeType, visible) => {\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst newVisibleTypes: Record<RelationType, boolean> = { ...state.visibleEdgeTypes };\n\t\t\t\t\tif (visible) {\n\t\t\t\t\t\tnewVisibleTypes[edgeType] = true;\n\t\t\t\t\t\treturn { visibleEdgeTypes: newVisibleTypes };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst { [edgeType]: removed, ...remaining } = newVisibleTypes;\n\t\t\t\t\t\treturn { visibleEdgeTypes: remaining };\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tsetAllEdgeTypesVisible: (visible) => {\n\t\t\t\tconst visibleTypes: Record<RelationType, boolean> = {\n\t\t\t\t\t[RelationType.AUTHORED]: visible,\n\t\t\t\t\t[RelationType.AFFILIATED]: visible,\n\t\t\t\t\t[RelationType.PUBLISHED_IN]: visible,\n\t\t\t\t\t[RelationType.FUNDED_BY]: visible,\n\t\t\t\t\t[RelationType.REFERENCES]: visible,\n\t\t\t\t\t[RelationType.RELATED_TO]: visible,\n\t\t\t\t\t[RelationType.SOURCE_PUBLISHED_BY]: visible,\n\t\t\t\t\t[RelationType.INSTITUTION_CHILD_OF]: visible,\n\t\t\t\t\t[RelationType.PUBLISHER_CHILD_OF]: visible,\n\t\t\t\t\t[RelationType.WORK_HAS_TOPIC]: visible,\n\t\t\t\t\t[RelationType.WORK_HAS_KEYWORD]: visible,\n\t\t\t\t\t[RelationType.AUTHOR_RESEARCHES]: visible,\n\t\t\t\t\t[RelationType.INSTITUTION_LOCATED_IN]: visible,\n\t\t\t\t\t[RelationType.FUNDER_LOCATED_IN]: visible,\n\t\t\t\t\t[RelationType.TOPIC_PART_OF_FIELD]: visible\n\t\t\t\t};\n\t\t\t\tset({\n\t\t\t\t\tvisibleEdgeTypes: visibleTypes\n\t\t\t\t});\n\t\t\t},\n\n\t\t\trecomputeEdgeTypeStats: () => {\n\t\t\t\tset((state) => {\n\t\t\t\t\t// Initialize with all relation types set to 0\n\t\t\t\t\tconst total: Record<RelationType, number> = {\n\t\t\t\t\t\t[RelationType.AUTHORED]: 0,\n\t\t\t\t\t\t[RelationType.AFFILIATED]: 0,\n\t\t\t\t\t\t[RelationType.PUBLISHED_IN]: 0,\n\t\t\t\t\t\t[RelationType.FUNDED_BY]: 0,\n\t\t\t\t\t\t[RelationType.REFERENCES]: 0,\n\t\t\t\t\t\t[RelationType.RELATED_TO]: 0,\n\t\t\t\t\t\t[RelationType.SOURCE_PUBLISHED_BY]: 0,\n\t\t\t\t\t\t[RelationType.INSTITUTION_CHILD_OF]: 0,\n\t\t\t\t\t\t[RelationType.PUBLISHER_CHILD_OF]: 0,\n\t\t\t\t\t\t[RelationType.WORK_HAS_TOPIC]: 0,\n\t\t\t\t\t\t[RelationType.WORK_HAS_KEYWORD]: 0,\n\t\t\t\t\t\t[RelationType.AUTHOR_RESEARCHES]: 0,\n\t\t\t\t\t\t[RelationType.INSTITUTION_LOCATED_IN]: 0,\n\t\t\t\t\t\t[RelationType.FUNDER_LOCATED_IN]: 0,\n\t\t\t\t\t\t[RelationType.TOPIC_PART_OF_FIELD]: 0\n\t\t\t\t\t};\n\t\t\t\t\tconst visible: Record<RelationType, number> = {\n\t\t\t\t\t\t[RelationType.AUTHORED]: 0,\n\t\t\t\t\t\t[RelationType.AFFILIATED]: 0,\n\t\t\t\t\t\t[RelationType.PUBLISHED_IN]: 0,\n\t\t\t\t\t\t[RelationType.FUNDED_BY]: 0,\n\t\t\t\t\t\t[RelationType.REFERENCES]: 0,\n\t\t\t\t\t\t[RelationType.RELATED_TO]: 0,\n\t\t\t\t\t\t[RelationType.SOURCE_PUBLISHED_BY]: 0,\n\t\t\t\t\t\t[RelationType.INSTITUTION_CHILD_OF]: 0,\n\t\t\t\t\t\t[RelationType.PUBLISHER_CHILD_OF]: 0,\n\t\t\t\t\t\t[RelationType.WORK_HAS_TOPIC]: 0,\n\t\t\t\t\t\t[RelationType.WORK_HAS_KEYWORD]: 0,\n\t\t\t\t\t\t[RelationType.AUTHOR_RESEARCHES]: 0,\n\t\t\t\t\t\t[RelationType.INSTITUTION_LOCATED_IN]: 0,\n\t\t\t\t\t\t[RelationType.FUNDER_LOCATED_IN]: 0,\n\t\t\t\t\t\t[RelationType.TOPIC_PART_OF_FIELD]: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Count total and visible edges by type\n\t\t\t\t\tconst edgeValues = Object.values(state.edges).filter((edge): edge is GraphEdge => edge !== undefined);\n\t\t\t\t\tedgeValues.forEach(edge => {\n\t\t\t\t\t\tconst edgeType = edge.type;\n\t\t\t\t\t\tconst currentTotal = total[edgeType];\n\t\t\t\t\t\ttotal[edgeType] = (typeof currentTotal === \"number\" ? currentTotal : 0) + 1;\n\n\t\t\t\t\t\tif (state.visibleEdgeTypes[edgeType]) {\n\t\t\t\t\t\t\tconst currentVisible = visible[edgeType];\n\t\t\t\t\t\t\tvisible[edgeType] = (typeof currentVisible === \"number\" ? currentVisible : 0) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update cached statistics including total counts\n\t\t\t\t\tstate.totalEdgeCount = edgeValues.length;\n\t\t\t\t\tstate.edgeTypeStats = {\n\t\t\t\t\t\ttotal,\n\t\t\t\t\t\tvisible\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Graph algorithms (work with generic data)\n\t\t\tgetNeighbors: (nodeId) => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.nodeNeighborsCache[nodeId] ?? EMPTY_ARRAY;\n\t\t\t},\n\n\t\t\tgetConnectedEdges: (nodeId) => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.nodeEdgesCache[nodeId] ?? EMPTY_EDGE_ARRAY;\n\t\t\t},\n\n\t\t\tfindShortestPath: (sourceId, targetId) => {\n\t\t\t\tconst { nodes, edges } = get();\n\n\t\t\t\t// Simple BFS implementation\n\t\t\t\tconst queue: string[] = [sourceId];\n\t\t\t\tconst visited: Record<string, boolean> = { [sourceId]: true };\n\t\t\t\tconst parent: Record<string, string> = {};\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst current = queue.shift();\n\t\t\t\t\tif (!current) continue;\n\n\t\t\t\t\tif (current === targetId) {\n\t\t\t\t\t\t// Reconstruct path\n\t\t\t\t\t\tconst path: string[] = [];\n\t\t\t\t\t\tlet node: string | undefined = targetId;\n\t\t\t\t\t\twhile (node) {\n\t\t\t\t\t\t\tpath.unshift(node);\n\t\t\t\t\t\t\tnode = parent[node];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn path;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check all connected nodes\n\t\t\t\t\tObject.values(edges).filter((edge): edge is NonNullable<typeof edge> => edge != null).forEach(edge => {\n\t\t\t\t\t\tlet neighbor: string | null = null;\n\t\t\t\t\t\tif (edge.source === current && !visited[edge.target]) {\n\t\t\t\t\t\t\tneighbor = edge.target;\n\t\t\t\t\t\t} else if (edge.target === current && !visited[edge.source]) {\n\t\t\t\t\t\t\tneighbor = edge.source;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (neighbor && nodes[neighbor]) {\n\t\t\t\t\t\t\tvisited[neighbor] = true;\n\t\t\t\t\t\t\tparent[neighbor] = current;\n\t\t\t\t\t\t\tqueue.push(neighbor);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn []; // No path found\n\t\t\t},\n\n\t\t\tgetConnectedComponent: (nodeId) => {\n\t\t\t\tconst { edges } = get();\n\t\t\t\tconst visited: Record<string, boolean> = {};\n\t\t\t\tconst stack: string[] = [nodeId];\n\n\t\t\t\twhile (stack.length > 0) {\n\t\t\t\t\tconst current = stack.pop();\n\t\t\t\t\tif (!current) continue;\n\t\t\t\t\tif (visited[current]) continue;\n\n\t\t\t\t\tvisited[current] = true;\n\n\t\t\t\t\t// Add all connected nodes\n\t\t\t\t\tObject.values(edges).filter((edge): edge is NonNullable<typeof edge> => edge != null).forEach(edge => {\n\t\t\t\t\t\tif (edge.source === current && !visited[edge.target]) {\n\t\t\t\t\t\t\tstack.push(edge.target);\n\t\t\t\t\t\t} else if (edge.target === current && !visited[edge.source]) {\n\t\t\t\t\t\t\tstack.push(edge.source);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Return array of visited node IDs for consistency\n\t\t\t\treturn Object.keys(visited);\n\t\t\t},\n\n\t\t\t// Incremental hydration support\n\n\t\t\tmarkNodeAsLoading: (nodeId, loading = true) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst node = draft.nodes[nodeId];\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tif (loading) {\n\t\t\t\t\t\t\tnode.label = (node.label && node.label.includes(\"Loading\")) ? node.label : `Loading ${node.label || \"Node\"}...`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove \"Loading \" prefix when clearing loading state\n\t\t\t\t\t\t\tnode.label = (node.label || \"\").replace(/^Loading /, \"\").replace(/\\.\\.\\.$/, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tmarkNodeAsLoaded: (nodeId, fullData) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst node = draft.nodes[nodeId];\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\t// Update node with data - no artificial metadata\n\t\t\t\t\t\tObject.assign(node, fullData);\n\t\t\t\t\t\t// Remove \"Loading...\" from label if present\n\t\t\t\t\t\tif (node.label.startsWith(\"Loading \")) {\n\t\t\t\t\t\t\tnode.label = node.label.replace(\"Loading \", \"\").replace(\"...\", \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tmarkNodeAsError: (nodeId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst node = draft.nodes[nodeId];\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\t// Update label to show error - no artificial metadata needed\n\t\t\t\t\t\tnode.label = `Error: ${node.label.replace(\"Loading \", \"\").replace(\"...\", \"\")}`;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tclearNodeLoading: (nodeId) => {\n\t\t\t\tset((draft) => {\n\t\t\t\t\tconst node = draft.nodes[nodeId];\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\t// Remove \"Loading \" prefix and \"...\" suffix from label\n\t\t\t\t\t\tnode.label = node.label.replace(/^Loading /, \"\").replace(/\\.\\.\\.$/, \"\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tgetPlaceholderNodes: () => {\n\t\t\t\t// Legacy method - return empty array (no artificial distinctions)\n\t\t\t\treturn [];\n\t\t\t},\n\t\t\tgetMinimalNodes: () => {\n\t\t\t\t// No artificial distinctions - return empty array\n\t\t\t\treturn [];\n\t\t\t},\n\t\t\tgetFullyHydratedNodes: () => {\n\t\t\t\tconst { nodes } = get();\n\t\t\t\t// All nodes are considered equal - return all nodes\n\t\t\t\treturn Object.values(nodes).filter((node): node is NonNullable<typeof node> => node != null);\n\t\t\t},\n\n\t\t\tgetLoadingNodes: () => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.cachedLoadingNodes;\n\t\t\t},\n\n\t\t\thasPlaceholderOrLoadingNodes: () => {\n\t\t\t\t// No artificial distinctions - always return false\n\t\t\t\treturn false;\n\t\t\t},\n\t\t})),\n\t\t{\n\t\t\tname: \"graph-layout-storage\",\n\t\t\tstorage: createJSONStorage(() => createHybridStorage({\n\t\t\t\tdbName: \"academic-explorer\",\n\t\t\t\tstoreName: \"graph-store\",\n\t\t\t\tversion: 1\n\t\t\t})),\n\t\t\tpartialize: (state) => ({\n\t\t\t\tcurrentLayout: state.currentLayout,\n\t\t\t\tproviderType: state.providerType,\n\t\t\t\tvisibleEntityTypes: state.visibleEntityTypes,\n\t\t\t\tvisibleEdgeTypes: state.visibleEdgeTypes,\n\t\t\t\tshowAllCachedNodes: state.showAllCachedNodes,\n\t\t\t\ttraversalDepth: state.traversalDepth,\n\t\t\t}),\n\t\t\tonRehydrateStorage: () => (state) => {\n\t\t\t\t// Type guard for state object\n\t\t\t\tconst isStateObject = (value: unknown): value is Record<string, unknown> => {\n\t\t\t\t\treturn typeof value === \"object\" && value !== null;\n\t\t\t\t};\n\n\t\t\t\tif (!isStateObject(state)) return;\n\n\t\t\t\t// Type guard for visibleEntityTypes object (new format) or array (legacy format)\n\t\t\t\tif (\"visibleEntityTypes\" in state) {\n\t\t\t\t\tif (typeof state.visibleEntityTypes === \"object\" && state.visibleEntityTypes !== null && !Array.isArray(state.visibleEntityTypes)) {\n\t\t\t\t\t\t// New object format - validate and use directly\n\t\t\t\t\t\tconst visibleTypesRecord: Record<EntityType, boolean> = {\n\t\t\t\t\t\t\tconcepts: false,\n\t\t\t\t\t\t\ttopics: false,\n\t\t\t\t\t\t\tkeywords: false,\n\t\t\t\t\t\t\tworks: false,\n\t\t\t\t\t\t\tauthors: false,\n\t\t\t\t\t\t\tsources: false,\n\t\t\t\t\t\t\tinstitutions: false,\n\t\t\t\t\t\t\tpublishers: false,\n\t\t\t\t\t\t\tfunders: false\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Copy valid entity types from stored object\n\t\t\t\t\t\tObject.entries(state.visibleEntityTypes).forEach(([key, value]) => {\n\t\t\t\t\t\t\tif (typeof key === \"string\" && typeof value === \"boolean\") {\n\t\t\t\t\t\t\t\t// Use specific property assignments to avoid type assertions\n\t\t\t\t\t\t\t\tswitch (key) {\n\t\t\t\t\t\t\t\t\tcase \"works\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.works = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"authors\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.authors = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"sources\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.sources = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"institutions\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.institutions = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"topics\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.topics = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"concepts\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.concepts = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"publishers\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.publishers = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"funders\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.funders = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"keywords\":\n\t\t\t\t\t\t\t\t\t\tvisibleTypesRecord.keywords = value;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tstate.visibleEntityTypes = visibleTypesRecord;\n\t\t\t\t\t} else if (Array.isArray(state.visibleEntityTypes)) {\n\t\t\t\t\t\t// Legacy array format - convert to object\n\t\t\t\t\t\tconst validEntityTypes = state.visibleEntityTypes.filter((type): type is EntityType =>\n\t\t\t\t\t\t\ttypeof type === \"string\" &&\n\t\t\t\t\t\t\t[\"works\", \"authors\", \"sources\", \"institutions\", \"topics\", \"concepts\", \"publishers\", \"funders\", \"keywords\"].includes(type)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst visibleTypesRecord: Record<EntityType, boolean> = {\n\t\t\t\t\t\t\tconcepts: false,\n\t\t\t\t\t\t\ttopics: false,\n\t\t\t\t\t\t\tkeywords: false,\n\t\t\t\t\t\t\tworks: false,\n\t\t\t\t\t\t\tauthors: false,\n\t\t\t\t\t\t\tsources: false,\n\t\t\t\t\t\t\tinstitutions: false,\n\t\t\t\t\t\t\tpublishers: false,\n\t\t\t\t\t\t\tfunders: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvalidEntityTypes.forEach(type => {\n\t\t\t\t\t\t\tvisibleTypesRecord[type] = true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tstate.visibleEntityTypes = visibleTypesRecord;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Type guard for visibleEdgeTypes array\n\t\t\t\tif (\"visibleEdgeTypes\" in state && Array.isArray(state.visibleEdgeTypes)) {\n\t\t\t\t\t// Type guard: only valid RelationType values\n\t\t\t\t\tconst isValidRelationType = (type: unknown): type is RelationType => {\n\t\t\t\t\t\tif (typeof type !== \"string\") return false;\n\t\t\t\t\t\treturn Object.values(RelationType).some((validType: string) => validType === type);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst validEdgeTypes = state.visibleEdgeTypes.filter(isValidRelationType);\n\t\t\t\t\tconst visibleEdgeTypesRecord: Record<RelationType, boolean> = {\n\t\t\t\t\t\t[RelationType.AUTHORED]: false,\n\t\t\t\t\t\t[RelationType.AFFILIATED]: false,\n\t\t\t\t\t\t[RelationType.PUBLISHED_IN]: false,\n\t\t\t\t\t\t[RelationType.FUNDED_BY]: false,\n\t\t\t\t\t\t[RelationType.REFERENCES]: false,\n\t\t\t\t\t\t[RelationType.RELATED_TO]: false,\n\t\t\t\t\t\t[RelationType.SOURCE_PUBLISHED_BY]: false,\n\t\t\t\t\t\t[RelationType.INSTITUTION_CHILD_OF]: false,\n\t\t\t\t\t\t[RelationType.PUBLISHER_CHILD_OF]: false,\n\t\t\t\t\t\t[RelationType.WORK_HAS_TOPIC]: false,\n\t\t\t\t\t\t[RelationType.WORK_HAS_KEYWORD]: false,\n\t\t\t\t\t\t[RelationType.AUTHOR_RESEARCHES]: false,\n\t\t\t\t\t\t[RelationType.INSTITUTION_LOCATED_IN]: false,\n\t\t\t\t\t\t[RelationType.FUNDER_LOCATED_IN]: false,\n\t\t\t\t\t\t[RelationType.TOPIC_PART_OF_FIELD]: false\n\t\t\t\t\t};\n\t\t\t\t\tvalidEdgeTypes.forEach(type => {\n\t\t\t\t\t\tvisibleEdgeTypesRecord[type] = true;\n\t\t\t\t\t});\n\t\t\t\t\tstate.visibleEdgeTypes = visibleEdgeTypesRecord;\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/group-registry.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":137,"column":85,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":137,"endColumn":87,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3472,3474],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":179,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":179,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4984,4986],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":180,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":180,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5067,5069],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Group registry for VSCode-style tool groups\n * Maps categories to group definitions with icons and descriptions\n */\n\nimport {\n\tIconSearch,\n\tIconFilter,\n\tIconGraph,\n\tIconInfoCircle,\n\tIconEye,\n\tIconChartBar,\n\tIconSettings,\n} from \"@tabler/icons-react\";\n\nexport interface ToolGroupDefinition {\n\tid: string;\n\ttitle: string;\n\ticon: React.ComponentType<{ size?: number; className?: string }>;\n\tdescription: string;\n\tcategory: string;\n\torder?: number; // For ordering in ribbons (lower numbers appear first)\n}\n\n// Version counter to track changes for React re-renders\nlet registryVersion = 0;\n\nexport const getRegistryVersion = (): number => registryVersion;\n\n/**\n * Tool group definitions mapped by category\n * This is mutable to allow dynamic registration of new groups\n */\nexport const GROUP_DEFINITIONS: Record<string, ToolGroupDefinition> = {\n\t\"data-input\": {\n\t\tid: \"data-input\",\n\t\ttitle: \"Search & Input\",\n\t\ticon: IconSearch,\n\t\tdescription: \"Search and input academic data\",\n\t\tcategory: \"data-input\",\n\t\torder: 1,\n\t},\n\t\"filtering\": {\n\t\tid: \"filtering\",\n\t\ttitle: \"Filters\",\n\t\ticon: IconFilter,\n\t\tdescription: \"Filter entities and edges\",\n\t\tcategory: \"filtering\",\n\t\torder: 2,\n\t},\n\t\"graph-control\": {\n\t\tid: \"graph-control\",\n\t\ttitle: \"Graph Control\",\n\t\ticon: IconGraph,\n\t\tdescription: \"Graph layout and control\",\n\t\tcategory: \"graph-control\",\n\t\torder: 3,\n\t},\n\t\"entity-details\": {\n\t\tid: \"entity-details\",\n\t\ttitle: \"Entity Details\",\n\t\ticon: IconInfoCircle,\n\t\tdescription: \"Entity information and links\",\n\t\tcategory: \"entity-details\",\n\t\torder: 4,\n\t},\n\t\"view-control\": {\n\t\tid: \"view-control\",\n\t\ttitle: \"View Options\",\n\t\ticon: IconEye,\n\t\tdescription: \"View and display options\",\n\t\tcategory: \"view-control\",\n\t\torder: 5,\n\t},\n\t\"debugging\": {\n\t\tid: \"debugging\",\n\t\ttitle: \"Debug Tools\",\n\t\ticon: IconEye,\n\t\tdescription: \"Debugging and inspection\",\n\t\tcategory: \"debugging\",\n\t\torder: 6,\n\t},\n\t\"analysis\": {\n\t\tid: \"analysis\",\n\t\ttitle: \"Analysis\",\n\t\ticon: IconChartBar,\n\t\tdescription: \"Graph analysis and statistics\",\n\t\tcategory: \"analysis\",\n\t\torder: 7,\n\t},\n\t\"settings\": {\n\t\tid: \"settings\",\n\t\ttitle: \"Settings\",\n\t\ticon: IconSettings,\n\t\tdescription: \"User preferences and data management\",\n\t\tcategory: \"settings\",\n\t\torder: 8,\n\t},\n};\n\n/**\n * Register a new group definition dynamically\n */\nexport const registerGroupDefinition = (groupDefinition: ToolGroupDefinition): void => {\n\tGROUP_DEFINITIONS[groupDefinition.id] = groupDefinition;\n\tregistryVersion++; // Increment version to trigger re-renders\n};\n\n/**\n * Create and register a new group with a primary section\n */\nexport const createNewGroup = (_primarySectionId: string): ToolGroupDefinition => {\n\t// Generate a unique group ID\n\tconst timestamp = Date.now();\n\tconst random = Math.random().toString(36).substring(2, 8);\n\tconst groupId = `group_${timestamp.toString()}_${random}`;\n\n\t// We'll update the definition dynamically when sections change\n\t// For now, create a placeholder\n\tconst dataInputDef = GROUP_DEFINITIONS[\"data-input\"];\n\tconst newDefinition: ToolGroupDefinition = {\n\t\tid: groupId,\n\t\ttitle: \"New Group\",\n\t\ticon: dataInputDef?.icon ?? (() => null), // Placeholder icon with fallback\n\t\tdescription: \"Dynamic group\",\n\t\tcategory: \"dynamic\",\n\t};\n\n\tregisterGroupDefinition(newDefinition);\n\treturn newDefinition;\n};\n\n/**\n * Get the next available order number (for placing new groups at the end)\n */\nconst getNextOrderNumber = (): number => {\n\tconst maxOrder = Math.max(...Object.values(GROUP_DEFINITIONS).map(def => def.order || 0));\n\treturn maxOrder + 1;\n};\n\n/**\n * Update a group's definition based on its current sections\n * Note: This function will be called from the layout store after sections change\n */\nimport type { SidebarSection } from \"@/types/sidebar-sections\";\n\nexport const updateGroupDefinition = (groupId: string, sections: string[], getSectionById: (id: string) => SidebarSection | undefined): void => {\n\tif (sections.length === 0) {\n\t\t// Skip empty groups - they will be filtered out when needed\n\t\treturn;\n\t}\n\n\t// Get the first (topmost) section to determine group properties\n\tconst firstSectionId = sections[0];\n\tif (!firstSectionId) return;\n\n\tconst primarySection = getSectionById(firstSectionId);\n\tif (!primarySection) return;\n\n\t// Preserve existing order if group already exists, otherwise assign new order\n\tconst existingDefinition = GROUP_DEFINITIONS[groupId];\n\tconst order = existingDefinition?.order ?? getNextOrderNumber();\n\n\t// Type guard for icon component\n\tfunction isIconComponent(icon: unknown): icon is React.ComponentType<{ size?: number; className?: string }> {\n\t\treturn typeof icon === \"function\";\n\t}\n\n\t// Use icon if it's a valid component, otherwise use default\n\tconst fallbackIcon = GROUP_DEFINITIONS[\"data-input\"]?.icon ?? (() => null);\n\tconst iconComponent = isIconComponent(primarySection.icon)\n\t\t? primarySection.icon\n\t\t: fallbackIcon;\n\n\tconst updatedDefinition: ToolGroupDefinition = {\n\t\tid: groupId,\n\t\ttitle: primarySection.title,\n\t\ticon: iconComponent,\n\t\tdescription: primarySection.tooltip || `Group containing ${primarySection.title}`,\n\t\tcategory: primarySection.category || \"General\",\n\t\torder,\n\t};\n\n\tregisterGroupDefinition(updatedDefinition);\n};\n\n/**\n * Get group definition by category/id\n */\nexport const getGroupDefinition = (categoryId: string): ToolGroupDefinition | undefined => {\n\treturn GROUP_DEFINITIONS[categoryId];\n};\n\n/**\n * Get all group definitions\n */\nexport const getAllGroups = (): ToolGroupDefinition[] => {\n\treturn Object.values(GROUP_DEFINITIONS);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/layout-store.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":345,"column":28,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":345,"endColumn":30,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[11409,11411],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removedGroup' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":350,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":350,"endColumn":38},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":554,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":554,"endColumn":39},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":557,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":557,"endColumn":39},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":643,"column":56,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":643,"endColumn":93},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":646,"column":56,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":646,"endColumn":93},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":649,"column":51,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":649,"endColumn":83},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":652,"column":49,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":652,"endColumn":79}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Group-based layout store for VSCode-style sidebar state management\n * Ribbon buttons represent tool groups (categories), multiple tools can be in each group\n */\n\nimport { create } from \"zustand\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport type { ProviderType } from \"@academic-explorer/graph\";\nimport { getDefaultSectionPlacements, getAllSectionIds, getSectionById } from \"@/stores/section-registry\";\nimport { updateGroupDefinition, getGroupDefinition, registerGroupDefinition } from \"@/stores/group-registry\";\nimport { createHybridStorage } from \"@academic-explorer/utils/storage\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\ninterface ToolGroup {\n  id: string;\n  sections: string[];\n  activeSection: string | null;\n}\n\ninterface LayoutState {\n  // Sidebar states\n  leftSidebarOpen: boolean;\n  leftSidebarPinned: boolean;\n  rightSidebarOpen: boolean;\n  rightSidebarPinned: boolean;\n\n  // Autohide states\n  leftSidebarAutoHidden: boolean;\n  rightSidebarAutoHidden: boolean;\n\n  // Hover states for autohide\n  leftSidebarHovered: boolean;\n  rightSidebarHovered: boolean;\n\n  // Section collapsed states (for tool headers)\n  collapsedSections: Record<string, boolean>;\n\n  // Section placement states (which sidebar each section is in)\n  sectionPlacements: Record<string, \"left\" | \"right\">;\n\n  // Active group for each sidebar (VSCode-style single active group)\n  activeGroups: Record<\"left\" | \"right\", string | null>;\n\n  // Tool groups for each sidebar (category-based groups with multiple tools)\n  toolGroups: Record<\"left\" | \"right\", Record<string, ToolGroup>>;\n\n  // Graph provider selection\n  graphProvider: ProviderType;\n\n  // Preview entity (for hover/selection)\n  previewEntityId: string | null;\n\n  // Graph behavior preferences\n  autoPinOnLayoutStabilization: boolean;\n\n  // Actions\n  toggleLeftSidebar: () => void;\n  toggleRightSidebar: () => void;\n  setLeftSidebarOpen: (open: boolean) => void;\n  setRightSidebarOpen: (open: boolean) => void;\n  pinLeftSidebar: (pinned: boolean) => void;\n  pinRightSidebar: (pinned: boolean) => void;\n  setLeftSidebarAutoHidden: (autoHidden: boolean) => void;\n  setRightSidebarAutoHidden: (autoHidden: boolean) => void;\n  setLeftSidebarHovered: (hovered: boolean) => void;\n  setRightSidebarHovered: (hovered: boolean) => void;\n  setSectionCollapsed: (sectionKey: string, collapsed: boolean) => void;\n  expandSidebarToSection: (sidebar: \"left\" | \"right\", sectionKey: string) => void;\n  setActiveGroup: (sidebar: \"left\" | \"right\", groupId: string | null) => void;\n  addSectionToGroup: (sidebar: \"left\" | \"right\", groupId: string, sectionId: string) => void;\n  removeSectionFromGroup: (sidebar: \"left\" | \"right\", groupId: string, sectionId: string) => void;\n  setActiveTabInGroup: (sidebar: \"left\" | \"right\", groupId: string, sectionId: string) => void;\n  moveSectionToSidebar: (sectionId: string, targetSidebar: \"left\" | \"right\") => void;\n  resetSectionPlacements: () => void;\n  getSectionsForSidebar: (sidebar: \"left\" | \"right\") => string[];\n  getActiveGroup: (sidebar: \"left\" | \"right\") => string | null;\n  getToolGroupsForSidebar: (sidebar: \"left\" | \"right\") => Record<string, ToolGroup>;\n  reorderGroups: (sidebar: \"left\" | \"right\", sourceGroupId: string, targetGroupId: string, insertBefore: boolean) => void;\n  moveGroupToSidebar: (sourceGroupId: string, targetSidebar: \"left\" | \"right\", targetGroupId?: string, insertBefore?: boolean) => void;\n  setGraphProvider: (provider: ProviderType) => void;\n  setPreviewEntity: (entityId: string | null) => void;\n  setAutoPinOnLayoutStabilization: (enabled: boolean) => void;\n}\n\n// Helper function to create default tool groups based on categories\nconst createDefaultToolGroups = (): Record<\"left\" | \"right\", Record<string, ToolGroup>> => {\n\tconst placements = getDefaultSectionPlacements();\n\tconst leftSections = getAllSectionIds().filter(id => placements[id] === \"left\");\n\tconst rightSections = getAllSectionIds().filter(id => placements[id] === \"right\");\n\n\t// Get unique categories for each sidebar\n\tconst leftCategories = [...new Set(leftSections.map(id => getSectionById(id)?.category).filter((cat): cat is string => Boolean(cat)))];\n\tconst rightCategories = [...new Set(rightSections.map(id => getSectionById(id)?.category).filter((cat): cat is string => Boolean(cat)))];\n\n\tconst createGroupsForSide = (sections: string[], categories: string[]) => {\n\t\tconst groups: Record<string, ToolGroup> = {};\n\t\tfor (const category of categories) {\n\t\t\tconst categorySections = sections.filter(id => {\n\t\t\t\tconst section = getSectionById(id);\n\t\t\t\treturn section?.category === category;\n\t\t\t});\n\t\t\tif (categorySections.length > 0) {\n\t\t\t\tgroups[category] = {\n\t\t\t\t\tid: category,\n\t\t\t\t\tsections: categorySections,\n\t\t\t\t\tactiveSection: categorySections[0] ?? null, // Default to first section\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn groups;\n\t};\n\n\treturn {\n\t\tleft: createGroupsForSide(leftSections, leftCategories),\n\t\tright: createGroupsForSide(rightSections, rightCategories),\n\t};\n};\n\ntype LayoutPersistedState = Partial<Pick<LayoutState,\n  | \"leftSidebarOpen\"\n  | \"leftSidebarPinned\"\n  | \"rightSidebarOpen\"\n  | \"rightSidebarPinned\"\n  | \"collapsedSections\"\n  | \"sectionPlacements\"\n  | \"activeGroups\"\n  | \"toolGroups\"\n  | \"graphProvider\"\n  | \"autoPinOnLayoutStabilization\"\n>>;\n\nexport const useLayoutStore = create<LayoutState>()(\n\tpersist(\n\t\t(set, get) => ({\n\t\t\t// Initial state\n\t\t\tleftSidebarOpen: true,\n\t\t\tleftSidebarPinned: false,\n\t\t\trightSidebarOpen: true,\n\t\t\trightSidebarPinned: false,\n\t\t\tleftSidebarAutoHidden: false,\n\t\t\trightSidebarAutoHidden: false,\n\t\t\tleftSidebarHovered: false,\n\t\t\trightSidebarHovered: false,\n\t\t\tcollapsedSections: {},\n\t\t\tsectionPlacements: getDefaultSectionPlacements(),\n\t\t\tactiveGroups: { left: null, right: null },\n\t\t\ttoolGroups: createDefaultToolGroups(),\n\t\t\tgraphProvider: \"xyflow\",\n\t\t\tpreviewEntityId: null,\n\t\t\tautoPinOnLayoutStabilization: false,\n\n\t\t\t// Actions\n\t\t\ttoggleLeftSidebar: () =>\n\t\t\t\tset((state) => ({\n\t\t\t\t\tleftSidebarOpen: !state.leftSidebarOpen,\n\t\t\t\t})),\n\n\t\t\ttoggleRightSidebar: () =>\n\t\t\t\tset((state) => ({\n\t\t\t\t\trightSidebarOpen: !state.rightSidebarOpen,\n\t\t\t\t})),\n\n\t\t\tsetLeftSidebarOpen: (open) =>\n\t\t\t\tset({ leftSidebarOpen: open }),\n\n\t\t\tsetRightSidebarOpen: (open) =>\n\t\t\t\tset({ rightSidebarOpen: open }),\n\n\t\t\tpinLeftSidebar: (pinned) =>\n\t\t\t\tset({ leftSidebarPinned: pinned }),\n\n\t\t\tpinRightSidebar: (pinned) =>\n\t\t\t\tset({ rightSidebarPinned: pinned }),\n\n\t\t\tsetLeftSidebarAutoHidden: (autoHidden) =>\n\t\t\t\tset({ leftSidebarAutoHidden: autoHidden }),\n\n\t\t\tsetRightSidebarAutoHidden: (autoHidden) =>\n\t\t\t\tset({ rightSidebarAutoHidden: autoHidden }),\n\n\t\t\tsetLeftSidebarHovered: (hovered) =>\n\t\t\t\tset({ leftSidebarHovered: hovered }),\n\n\t\t\tsetRightSidebarHovered: (hovered) =>\n\t\t\t\tset({ rightSidebarHovered: hovered }),\n\n\t\t\tsetSectionCollapsed: (sectionKey, collapsed) =>\n\t\t\t\tset((state) => ({\n\t\t\t\t\tcollapsedSections: {\n\t\t\t\t\t\t...state.collapsedSections,\n\t\t\t\t\t\t[sectionKey]: collapsed,\n\t\t\t\t\t},\n\t\t\t\t})),\n\n\t\t\texpandSidebarToSection: (sidebar, sectionKey) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\t// Find which group contains this section\n\t\t\t\t\tconst toolGroups = state.toolGroups[sidebar];\n\t\t\t\t\tlet targetGroupId: string | null = null;\n\n\t\t\t\t\tfor (const [groupId, group] of Object.entries(toolGroups)) {\n\t\t\t\t\t\tif (group.sections.includes(sectionKey)) {\n\t\t\t\t\t\t\ttargetGroupId = groupId;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!targetGroupId) return state;\n\n\t\t\t\t\t// Update the group's active section and set as active group\n\t\t\t\t\tconst updatedGroups = {\n\t\t\t\t\t\t...toolGroups,\n\t\t\t\t\t\t[targetGroupId]: {\n\t\t\t\t\t\t\t...toolGroups[targetGroupId],\n\t\t\t\t\t\t\tactiveSection: sectionKey,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t// Open the appropriate sidebar\n\t\t\t\t\t\tleftSidebarOpen: sidebar === \"left\" ? true : state.leftSidebarOpen,\n\t\t\t\t\t\trightSidebarOpen: sidebar === \"right\" ? true : state.rightSidebarOpen,\n\t\t\t\t\t\ttoolGroups: {\n\t\t\t\t\t\t\t...state.toolGroups,\n\t\t\t\t\t\t\t[sidebar]: updatedGroups,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tactiveGroups: {\n\t\t\t\t\t\t\t...state.activeGroups,\n\t\t\t\t\t\t\t[sidebar]: targetGroupId,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\tsetActiveGroup: (sidebar, groupId) =>\n\t\t\t\tset((state) => ({\n\t\t\t\t\tactiveGroups: {\n\t\t\t\t\t\t...state.activeGroups,\n\t\t\t\t\t\t[sidebar]: groupId,\n\t\t\t\t\t},\n\t\t\t\t})),\n\n\t\t\taddSectionToGroup: (sidebar, groupId, sectionId) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst toolGroups = state.toolGroups[sidebar];\n\t\t\t\t\t// Type guard for group existence\n\t\t\t\t\tfunction isValidGroup(g: ToolGroup | undefined): g is ToolGroup {\n\t\t\t\t\t\treturn g !== undefined;\n\t\t\t\t\t}\n\t\t\t\t\tconst group = toolGroups[groupId];\n\t\t\t\t\tconst groupExists = isValidGroup(group);\n\n\t\t\t\t\tconst existingGroupSections = groupExists ? group.sections : undefined;\n\t\t\t\t\tlogger.debug(\"ui\", `addSectionToGroup called`, {\n\t\t\t\t\t\tsidebar,\n\t\t\t\t\t\tgroupId,\n\t\t\t\t\t\tsectionId,\n\t\t\t\t\t\tgroupExists,\n\t\t\t\t\t\texistingGroupIds: Object.keys(toolGroups),\n\t\t\t\t\t\texistingGroupSections\n\t\t\t\t\t});\n\n\t\t\t\t\t// Handle existing group\n\t\t\t\t\tif (group) {\n\t\t\t\t\t\t// If group already contains the section, do nothing\n\t\t\t\t\t\tif (group.sections.includes(sectionId)) {\n\t\t\t\t\t\t\tlogger.debug(\"ui\", `Section ${sectionId} already in group ${groupId}, skipping`);\n\t\t\t\t\t\t\treturn state;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check if this is a valid group definition from the registry\n\t\t\t\t\t\tconst groupDefinition = getGroupDefinition(groupId);\n\t\t\t\t\t\tif (!groupDefinition) {\n\t\t\t\t\t\t\tlogger.error(\"ui\", `Cannot add section to non-existent group - no group definition found`, {\n\t\t\t\t\t\t\t\tsidebar,\n\t\t\t\t\t\t\t\tgroupId,\n\t\t\t\t\t\t\t\tsectionId,\n\t\t\t\t\t\t\t\tavailableGroups: Object.keys(toolGroups)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn state; // Only allow adding to groups that exist in the registry\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger.debug(\"ui\", `Creating new group from registry definition`, {\n\t\t\t\t\t\t\tsidebar,\n\t\t\t\t\t\t\tgroupId,\n\t\t\t\t\t\t\tsectionId,\n\t\t\t\t\t\t\tgroupDefinition: { id: groupDefinition.id, title: groupDefinition.title }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update existing group or create new one from registry\n\t\t\t\t\tlet updatedGroup: ToolGroup;\n\t\t\t\t\tif (group) {\n\t\t\t\t\t\t// Update existing group\n\t\t\t\t\t\tupdatedGroup = {\n\t\t\t\t\t\t\t...group,\n\t\t\t\t\t\t\tsections: [...group.sections, sectionId],\n\t\t\t\t\t\t\tactiveSection: sectionId, // Focus the newly added section\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Create new group from registry definition\n\t\t\t\t\t\tupdatedGroup = {\n\t\t\t\t\t\t\tid: groupId,\n\t\t\t\t\t\t\tsections: [sectionId],\n\t\t\t\t\t\t\tactiveSection: sectionId,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.debug(\"ui\", `Adding section ${sectionId} to group ${groupId}`, {\n\t\t\t\t\t\tsidebar,\n\t\t\t\t\t\tgroupId,\n\t\t\t\t\t\tsectionId,\n\t\t\t\t\t\tisNewGroup: !group,\n\t\t\t\t\t\t...(group?.sections !== undefined && { oldSections: group.sections }),\n\t\t\t\t\t\tnewSections: updatedGroup.sections\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update group definition based on sections\n\t\t\t\t\tupdateGroupDefinition(groupId, updatedGroup.sections, getSectionById);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttoolGroups: {\n\t\t\t\t\t\t\t...state.toolGroups,\n\t\t\t\t\t\t\t[sidebar]: {\n\t\t\t\t\t\t\t\t...toolGroups,\n\t\t\t\t\t\t\t\t[groupId]: updatedGroup,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tactiveGroups: {\n\t\t\t\t\t\t\t...state.activeGroups,\n\t\t\t\t\t\t\t[sidebar]: groupId, // Activate the group\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\tremoveSectionFromGroup: (sidebar, groupId, sectionId) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst toolGroups = state.toolGroups[sidebar];\n\t\t\t\t\tconst group: ToolGroup | undefined = toolGroups[groupId];\n\n\t\t\t\t\tif (!(groupId in toolGroups)) return state;\n\t\t\t\t\tif (!group) return state;\n\n\t\t\t\t\tconst updatedSections = group.sections.filter(id => id !== sectionId);\n\t\t\t\t\tconst newActiveSection = group.activeSection === sectionId\n\t\t\t\t\t\t? updatedSections[0] || null\n\t\t\t\t\t\t: group.activeSection;\n\n\t\t\t\t\t// If group becomes empty, remove it entirely\n\t\t\t\t\tif (updatedSections.length === 0) {\n\t\t\t\t\t\tconst { [groupId]: removedGroup, ...remainingGroups } = toolGroups;\n\t\t\t\t\t\tconst newActiveGroup = state.activeGroups[sidebar] === groupId\n\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t: state.activeGroups[sidebar];\n\n\t\t\t\t\t\t// Remove group definition\n\t\t\t\t\t\tupdateGroupDefinition(groupId, [], getSectionById);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttoolGroups: {\n\t\t\t\t\t\t\t\t...state.toolGroups,\n\t\t\t\t\t\t\t\t[sidebar]: remainingGroups,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tactiveGroups: {\n\t\t\t\t\t\t\t\t...state.activeGroups,\n\t\t\t\t\t\t\t\t[sidebar]: newActiveGroup,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tconst updatedGroup = {\n\t\t\t\t\t\t...group,\n\t\t\t\t\t\tsections: updatedSections,\n\t\t\t\t\t\tactiveSection: newActiveSection,\n\t\t\t\t\t};\n\n\t\t\t\t\t// Update group definition based on new sections\n\t\t\t\t\tupdateGroupDefinition(groupId, updatedGroup.sections, getSectionById);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttoolGroups: {\n\t\t\t\t\t\t\t...state.toolGroups,\n\t\t\t\t\t\t\t[sidebar]: {\n\t\t\t\t\t\t\t\t...toolGroups,\n\t\t\t\t\t\t\t\t[groupId]: updatedGroup,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\tsetActiveTabInGroup: (sidebar, groupId, sectionId) =>\n\t\t\t\tset((state) => {\n\t\t\t\t\tconst toolGroups = state.toolGroups[sidebar];\n\t\t\t\t\tconst group: ToolGroup | undefined = toolGroups[groupId];\n\n\t\t\t\t\tif (!(groupId in toolGroups)) return state;\n\t\t\t\t\tif (!group?.sections.includes(sectionId)) return state;\n\n\t\t\t\t\tconst updatedGroup = {\n\t\t\t\t\t\t...group,\n\t\t\t\t\t\tactiveSection: sectionId,\n\t\t\t\t\t};\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttoolGroups: {\n\t\t\t\t\t\t\t...state.toolGroups,\n\t\t\t\t\t\t\t[sidebar]: {\n\t\t\t\t\t\t\t\t...toolGroups,\n\t\t\t\t\t\t\t\t[groupId]: updatedGroup,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\tmoveSectionToSidebar: (sectionId, targetSidebar) =>\n\t\t\t\tset((state) => ({\n\t\t\t\t\tsectionPlacements: {\n\t\t\t\t\t\t...state.sectionPlacements,\n\t\t\t\t\t\t[sectionId]: targetSidebar,\n\t\t\t\t\t},\n\t\t\t\t})),\n\n\t\t\tresetSectionPlacements: () =>\n\t\t\t\tset({\n\t\t\t\t\tsectionPlacements: getDefaultSectionPlacements(),\n\t\t\t\t\tactiveGroups: { left: null, right: null },\n\t\t\t\t\ttoolGroups: createDefaultToolGroups(),\n\t\t\t\t}),\n\n\t\t\tgetSectionsForSidebar: (sidebar) => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn getAllSectionIds().filter(\n\t\t\t\t\tsectionId => state.sectionPlacements[sectionId] === sidebar\n\t\t\t\t);\n\t\t\t},\n\n\t\t\tgetActiveGroup: (sidebar) => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.activeGroups[sidebar];\n\t\t\t},\n\n\t\t\tgetToolGroupsForSidebar: (sidebar) => {\n\t\t\t\tconst state = get();\n\t\t\t\treturn state.toolGroups[sidebar];\n\t\t\t},\n\n\t\t\treorderGroups: (sidebar, sourceGroupId, targetGroupId, insertBefore) => {\n\t\t\t\tconst state = get();\n\t\t\t\tconst toolGroups = state.toolGroups[sidebar];\n\n\t\t\t\tlogger.debug(\"ui\", `Starting reorderGroups`, {\n\t\t\t\t\tsidebar,\n\t\t\t\t\tsourceGroupId,\n\t\t\t\t\ttargetGroupId,\n\t\t\t\t\tinsertBefore,\n\t\t\t\t\tavailableGroups: Object.keys(toolGroups)\n\t\t\t\t});\n\n\t\t\t\t// Get group definitions for both source and target\n\t\t\t\tconst sourceDefinition = getGroupDefinition(sourceGroupId);\n\t\t\t\tconst targetDefinition = getGroupDefinition(targetGroupId);\n\n\t\t\t\tlogger.debug(\"ui\", `Group definitions found`, {\n\t\t\t\t\tsourceDefinition: sourceDefinition ? { id: sourceDefinition.id, order: sourceDefinition.order } : null,\n\t\t\t\t\ttargetDefinition: targetDefinition ? { id: targetDefinition.id, order: targetDefinition.order } : null\n\t\t\t\t});\n\n\t\t\t\tif (!sourceDefinition || !targetDefinition) {\n\t\t\t\t\tlogger.warn(\"ui\", `Missing group definitions, cannot reorder`, {\n\t\t\t\t\t\tsourceDefinition: !!sourceDefinition,\n\t\t\t\t\t\ttargetDefinition: !!targetDefinition\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Get all groups for this sidebar and sort them by current order\n\t\t\t\tconst allGroupIds = Object.keys(toolGroups);\n\t\t\t\tconst allGroups = allGroupIds\n\t\t\t\t\t.map(id => ({ id, definition: getGroupDefinition(id) }))\n\t\t\t\t\t.filter((item): item is { id: string; definition: NonNullable<ReturnType<typeof getGroupDefinition>> } => item.definition !== undefined)\n\t\t\t\t\t.sort((a, b) => (a.definition.order ?? 999) - (b.definition.order ?? 999));\n\n\t\t\t\t// Create a new ordered list by removing source and inserting it at the target position\n\t\t\t\tconst reorderedGroups = allGroups.filter(({ id }) => id !== sourceGroupId);\n\t\t\t\tconst targetIndex = reorderedGroups.findIndex(({ id }) => id === targetGroupId);\n\n\t\t\t\tconst insertIndex = insertBefore ? targetIndex : targetIndex + 1;\n\t\t\t\treorderedGroups.splice(insertIndex, 0, { id: sourceGroupId, definition: sourceDefinition });\n\n\t\t\t\t// Reassign orders starting from 1\n\t\t\t\treorderedGroups.forEach(({ id, definition }, index) => {\n\t\t\t\t\tconst newOrder = index + 1;\n\t\t\t\t\tlogger.debug(\"ui\", `Reassigning order for group ${id}`, {\n\t\t\t\t\t\tgroupId: id,\n\t\t\t\t\t\toldOrder: definition.order,\n\t\t\t\t\t\tnewOrder\n\t\t\t\t\t});\n\n\t\t\t\t\tregisterGroupDefinition({\n\t\t\t\t\t\t...definition,\n\t\t\t\t\t\torder: newOrder\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tlogger.debug(\"ui\", `Reorder complete`);\n\t\t\t},\n\n\t\t\tmoveGroupToSidebar: (sourceGroupId, targetSidebar, targetGroupId, insertBefore = false) => {\n\t\t\t\tconst state = get();\n\n\t\t\t\tlogger.debug(\"ui\", `Starting moveGroupToSidebar`, {\n\t\t\t\t\tsourceGroupId,\n\t\t\t\t\ttargetSidebar,\n\t\t\t\t\ttargetGroupId,\n\t\t\t\t\tinsertBefore\n\t\t\t\t});\n\n\t\t\t\t// Find the source group in both sidebars\n\t\t\t\tconst leftGroups = state.toolGroups.left;\n\t\t\t\tconst rightGroups = state.toolGroups.right;\n\t\t\t\tlet sourceGroup: ToolGroup | null = null;\n\t\t\t\tlet sourceSidebar: \"left\" | \"right\" | null = null;\n\n\t\t\t\tif (sourceGroupId in leftGroups) {\n\t\t\t\t\tsourceGroup = leftGroups[sourceGroupId] ?? null;\n\t\t\t\t\tsourceSidebar = \"left\";\n\t\t\t\t} else if (sourceGroupId in rightGroups) {\n\t\t\t\t\tsourceGroup = rightGroups[sourceGroupId] ?? null;\n\t\t\t\t\tsourceSidebar = \"right\";\n\t\t\t\t}\n\n\t\t\t\tif (!sourceGroup || !sourceSidebar) {\n\t\t\t\t\tlogger.warn(\"ui\", `Source group ${sourceGroupId} not found in either sidebar`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (sourceSidebar === targetSidebar) {\n\t\t\t\t\tlogger.debug(\"ui\", `Group ${sourceGroupId} is already on ${targetSidebar} sidebar, using reorderGroups instead`);\n\t\t\t\t\tif (targetGroupId) {\n\t\t\t\t\t\tget().reorderGroups(targetSidebar, sourceGroupId, targetGroupId, insertBefore);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\"ui\", `Moving group ${sourceGroupId} from ${sourceSidebar} to ${targetSidebar}`, {\n\t\t\t\t\tsourceGroup: { id: sourceGroup.id, sections: sourceGroup.sections }\n\t\t\t\t});\n\n\t\t\t\t// Remove from source sidebar\n\t\t\t\tset(state => {\n\t\t\t\t\tconst newToolGroups = { ...state.toolGroups };\n\n\t\t\t\t\t// Remove from source sidebar\n\t\t\t\t\tif (sourceSidebar === \"left\") {\n\t\t\t\t\t\tconst { [sourceGroupId]: removed, ...remaining } = newToolGroups.left;\n\t\t\t\t\t\tnewToolGroups.left = remaining;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst { [sourceGroupId]: removed, ...remaining } = newToolGroups.right;\n\t\t\t\t\t\tnewToolGroups.right = remaining;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add to target sidebar\n\t\t\t\t\tnewToolGroups[targetSidebar] = {\n\t\t\t\t\t\t...newToolGroups[targetSidebar],\n\t\t\t\t\t\t[sourceGroupId]: sourceGroup\n\t\t\t\t\t};\n\n\t\t\t\t\treturn { toolGroups: newToolGroups };\n\t\t\t\t});\n\n\t\t\t\t// If a target position is specified, reorder within the target sidebar\n\t\t\t\tif (targetGroupId) {\n\t\t\t\t\t// Give a moment for the state to update, then reorder\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tget().reorderGroups(targetSidebar, sourceGroupId, targetGroupId, insertBefore);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\n\t\t\t\t// Set the moved group as active on the target sidebar\n\t\t\t\tget().setActiveGroup(targetSidebar, sourceGroupId);\n\n\t\t\t\t// Open the target sidebar to show the moved group\n\t\t\t\tif (targetSidebar === \"left\") {\n\t\t\t\t\tget().setLeftSidebarOpen(true);\n\t\t\t\t} else {\n\t\t\t\t\tget().setRightSidebarOpen(true);\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\"ui\", `Move to ${targetSidebar} sidebar complete`);\n\t\t\t},\n\n\t\t\tsetGraphProvider: (provider) =>\n\t\t\t\tset({ graphProvider: provider }),\n\n\t\t\tsetPreviewEntity: (entityId) => {\n\t\t\t\tconst currentState = get();\n\t\t\t\tif (currentState.previewEntityId !== entityId) {\n\t\t\t\t\tset({ previewEntityId: entityId });\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsetAutoPinOnLayoutStabilization: (enabled) =>\n\t\t\t\tset({ autoPinOnLayoutStabilization: enabled }),\n\t\t}),\n\t\t{\n\t\t\tname: \"academic-explorer-layout\",\n\t\t\tstorage: createJSONStorage(() => createHybridStorage({\n\t\t\t\tdbName: \"academic-explorer\",\n\t\t\t\tstoreName: \"layout-store\",\n\t\t\t\tversion: 1\n\t\t\t})),\n\t\t\t// Only persist certain values\n\t\t\tpartialize: (state) => ({\n\t\t\t\tleftSidebarPinned: state.leftSidebarPinned,\n\t\t\t\trightSidebarPinned: state.rightSidebarPinned,\n\t\t\t\tcollapsedSections: state.collapsedSections,\n\t\t\t\tsectionPlacements: state.sectionPlacements,\n\t\t\t\tactiveGroups: state.activeGroups,\n\t\t\t\ttoolGroups: state.toolGroups,\n\t\t\t\tgraphProvider: state.graphProvider,\n\t\t\t\tautoPinOnLayoutStabilization: state.autoPinOnLayoutStabilization,\n\t\t\t}),\n\t\t\t// Migration for existing localStorage entries\n\t\t\tmigrate: (persistedState: unknown): unknown => {\n\t\t\t\tfunction isValidPersistedState(state: unknown): state is Record<string, unknown> {\n\t\t\t\t\treturn state !== null && typeof state === \"object\";\n\t\t\t\t}\n\n\t\t\t\tfunction isLayoutPersistedState(state: unknown): state is LayoutPersistedState {\n\t\t\t\t\tif (!isValidPersistedState(state)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst typedState = state as LayoutPersistedState;\n\n\t\t\t\t\t// Validate optional boolean fields\n\t\t\t\t\tconst booleanFields = [\"leftSidebarOpen\", \"leftSidebarPinned\", \"rightSidebarOpen\", \"rightSidebarPinned\", \"autoPinOnLayoutStabilization\"] as const;\n\t\t\t\t\tfor (const field of booleanFields) {\n\t\t\t\t\t\tif (typedState[field] !== undefined && typeof typedState[field] !== \"boolean\") {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Validate optional object fields\n\t\t\t\t\tif (typedState.collapsedSections !== undefined && typedState.collapsedSections !== null && typeof typedState.collapsedSections !== \"object\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typedState.sectionPlacements !== undefined && typedState.sectionPlacements !== null && typeof typedState.sectionPlacements !== \"object\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typedState.activeGroups !== undefined && typedState.activeGroups !== null && typeof typedState.activeGroups !== \"object\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typedState.toolGroups !== undefined && typedState.toolGroups !== null && typeof typedState.toolGroups !== \"object\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t// Validate optional string fields\n\t\t\t\t\tif (typedState.graphProvider !== undefined && typeof typedState.graphProvider !== \"string\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (isLayoutPersistedState(persistedState)) {\n\t\t\t\t\tconst state = persistedState;\n\t\t\t\t\tlet migrated = false;\n\n\t\t\t\t\t// Add autoPinOnLayoutStabilization if missing\n\t\t\t\t\tif (typeof state.autoPinOnLayoutStabilization === \"undefined\") {\n\t\t\t\t\t\tstate.autoPinOnLayoutStabilization = true;\n\t\t\t\t\t\tmigrated = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add sectionPlacements if missing\n\t\t\t\t\tif (!state.sectionPlacements) {\n\t\t\t\t\t\tstate.sectionPlacements = getDefaultSectionPlacements();\n\t\t\t\t\t\tmigrated = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add collapsedSections if missing\n\t\t\t\t\tif (!state.collapsedSections) {\n\t\t\t\t\t\tstate.collapsedSections = {};\n\t\t\t\t\t\tmigrated = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add toolGroups if missing (new group-based system)\n\t\t\t\t\tif (!state.toolGroups) {\n\t\t\t\t\t\tstate.toolGroups = createDefaultToolGroups();\n\t\t\t\t\t\tmigrated = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add activeGroups if missing\n\t\t\t\t\tif (!state.activeGroups) {\n\t\t\t\t\t\tstate.activeGroups = { left: null, right: null };\n\t\t\t\t\t\tmigrated = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn migrated ? { ...state } : persistedState;\n\t\t\t\t}\n\t\t\t\treturn persistedState;\n\t\t\t},\n\t\t\tversion: 2,\n\t\t}\n\t)\n);","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/network-activity-store.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":110,"column":83,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":110,"endColumn":85,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3519,3521],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":121,"column":74,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":121,"endColumn":76,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4179,4181],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":271,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":271,"endColumn":26}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Store for tracking network activity and API requests\n * Monitors all HTTP requests with real-time status updates\n */\n\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\nimport { logger } from \"@academic-explorer/utils/logger\";\n\nexport interface NetworkRequest {\n  id: string;\n  type: \"api\" | \"cache\" | \"worker\" | \"resource\";\n  category: \"foreground\" | \"background\";\n  url: string;\n  method: string;\n  status: \"pending\" | \"success\" | \"error\" | \"cached\" | \"deduplicated\";\n  statusCode?: number;\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  size?: number;\n  cacheStrategy?: string;\n  error?: string;\n  metadata?: {\n    entityType?: string;\n    entityId?: string;\n    queryParams?: Record<string, unknown>;\n    headers?: Record<string, string>;\n    fromCache?: boolean;\n    deduplicated?: boolean;\n  };\n}\n\nexport interface NetworkStats {\n  totalRequests: number;\n  activeRequests: number;\n  successCount: number;\n  errorCount: number;\n  cacheHits: number;\n  deduplicatedCount: number;\n  averageResponseTime: number;\n  requestsPerSecond: number;\n  totalDataTransferred: number;\n}\n\ninterface NetworkActivityState {\n  // State - using plain objects for Immer compatibility\n  requests: Record<string, NetworkRequest>;\n  maxHistorySize: number;\n\n  // Cached computed state for stable references\n  activeRequests: NetworkRequest[];\n  recentRequests: NetworkRequest[];\n  networkStats: NetworkStats;\n  filteredRequests: NetworkRequest[];\n\n  // Filters\n  filters: {\n    status: string[];\n    type: string[];\n    category: string[];\n    searchTerm: string;\n    timeRange: number; // hours\n  };\n\n  // Actions\n  addRequest: (request: Omit<NetworkRequest, \"id\" | \"startTime\">) => string;\n  updateRequest: (id: string, updates: Partial<NetworkRequest>) => void;\n  completeRequest: (id: string, statusCode?: number, size?: number) => void;\n  failRequest: (id: string, error: string, statusCode?: number) => void;\n  removeRequest: (id: string) => void;\n  clearOldRequests: () => void;\n  clearAllRequests: () => void;\n\n  // Filter actions\n  setStatusFilter: (statuses: string[]) => void;\n  setTypeFilter: (types: string[]) => void;\n  setCategoryFilter: (categories: string[]) => void;\n  setSearchTerm: (term: string) => void;\n  setTimeRange: (hours: number) => void;\n  clearFilters: () => void;\n\n  // Recomputation functions (called after mutations)\n  recomputeActiveRequests: () => void;\n  recomputeRecentRequests: () => void;\n  recomputeNetworkStats: () => void;\n  recomputeFilteredRequests: () => void;\n  recomputeAll: () => void;\n}\n\nconst generateRequestId = () => `req_${Date.now().toString()}_${Math.random().toString(36).substring(2, 11)}`;\n\nconst computeActiveRequests = (requests: Record<string, NetworkRequest>): NetworkRequest[] => {\n\treturn Object.values(requests).filter(req => req.status === \"pending\");\n};\n\nconst computeRecentRequests = (requests: Record<string, NetworkRequest>): NetworkRequest[] => {\n\treturn Object.values(requests)\n\t\t.sort((a, b) => b.startTime - a.startTime)\n\t\t.slice(0, 50); // Show last 50 requests\n};\n\nconst computeNetworkStats = (requests: Record<string, NetworkRequest>): NetworkStats => {\n\tconst requestList = Object.values(requests);\n\tconst now = Date.now();\n\tconst oneSecondAgo = now - 1000;\n\n\tconst recentRequests = requestList.filter(req => req.startTime > oneSecondAgo);\n\tconst completedRequests = requestList.filter(req => req.endTime !== undefined);\n\tconst totalDuration = completedRequests.reduce((sum, req) => sum + (req.duration || 0), 0);\n\n\treturn {\n\t\ttotalRequests: requestList.length,\n\t\tactiveRequests: requestList.filter(req => req.status === \"pending\").length,\n\t\tsuccessCount: requestList.filter(req => req.status === \"success\").length,\n\t\terrorCount: requestList.filter(req => req.status === \"error\").length,\n\t\tcacheHits: requestList.filter(req => req.status === \"cached\").length,\n\t\tdeduplicatedCount: requestList.filter(req => req.status === \"deduplicated\").length,\n\t\taverageResponseTime: completedRequests.length > 0 ? totalDuration / completedRequests.length : 0,\n\t\trequestsPerSecond: recentRequests.length,\n\t\ttotalDataTransferred: requestList.reduce((sum, req) => sum + (req.size || 0), 0),\n\t};\n};\n\nconst computeFilteredRequests = (\n\trequests: Record<string, NetworkRequest>,\n\tfilters: NetworkActivityState[\"filters\"]\n): NetworkRequest[] => {\n\tconst requestList = Object.values(requests);\n\tconst cutoffTime = Date.now() - (filters.timeRange * 60 * 60 * 1000);\n\n\treturn requestList.filter(req => {\n\t\t// Time range filter\n\t\tif (req.startTime < cutoffTime) return false;\n\n\t\t// Status filter\n\t\tif (filters.status.length > 0 && !filters.status.includes(req.status)) return false;\n\n\t\t// Type filter\n\t\tif (filters.type.length > 0 && !filters.type.includes(req.type)) return false;\n\n\t\t// Category filter\n\t\tif (filters.category.length > 0 && !filters.category.includes(req.category)) return false;\n\n\t\t// Search term filter\n\t\tif (filters.searchTerm) {\n\t\t\tconst term = filters.searchTerm.toLowerCase();\n\t\t\tconst searchableText = [\n\t\t\t\treq.url,\n\t\t\t\treq.method,\n\t\t\t\treq.metadata?.entityType,\n\t\t\t\treq.metadata?.entityId,\n\t\t\t\treq.error\n\t\t\t].filter(Boolean).join(\" \").toLowerCase();\n\n\t\t\tif (!searchableText.includes(term)) return false;\n\t\t}\n\n\t\treturn true;\n\t}).sort((a, b) => b.startTime - a.startTime);\n};\n\nexport const useNetworkActivityStore = create<NetworkActivityState>()(\n\timmer((set, get) => ({\n\t\t// State\n\t\trequests: {},\n\t\tmaxHistorySize: 500,\n\n\t\t// Cached computed state (stable references)\n\t\tactiveRequests: [],\n\t\trecentRequests: [],\n\t\tnetworkStats: {\n\t\t\ttotalRequests: 0,\n\t\t\tactiveRequests: 0,\n\t\t\tsuccessCount: 0,\n\t\t\terrorCount: 0,\n\t\t\tcacheHits: 0,\n\t\t\tdeduplicatedCount: 0,\n\t\t\taverageResponseTime: 0,\n\t\t\trequestsPerSecond: 0,\n\t\t\ttotalDataTransferred: 0,\n\t\t},\n\t\tfilteredRequests: [],\n\n\t\t// Filters\n\t\tfilters: {\n\t\t\tstatus: [],\n\t\t\ttype: [],\n\t\t\tcategory: [],\n\t\t\tsearchTerm: \"\",\n\t\t\ttimeRange: 24, // 24 hours default\n\t\t},\n\n\t\t// Actions\n\t\taddRequest: (request) => {\n\t\t\tconst id = generateRequestId();\n\n\t\t\tset(state => {\n\t\t\t\tstate.requests[id] = {\n\t\t\t\t\t...request,\n\t\t\t\t\tid,\n\t\t\t\t\tstartTime: Date.now(),\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tget().recomputeAll();\n\n\t\t\tlogger.debug(\"api\", \"Network request added\", {\n\t\t\t\tid,\n\t\t\t\turl: request.url,\n\t\t\t\ttype: request.type,\n\t\t\t\tcategory: request.category\n\t\t\t}, \"NetworkActivityStore\");\n\n\t\t\treturn id;\n\t\t},\n\n\t\tupdateRequest: (id, updates) => {\n\t\t\tset(state => {\n\t\t\t\tconst request = state.requests[id];\n\t\t\t\tif (request) {\n\t\t\t\t\tObject.assign(request, updates);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tget().recomputeAll();\n\t\t},\n\n\t\tcompleteRequest: (id, statusCode, size) => {\n\t\t\tconst endTime = Date.now();\n\n\t\t\tset(state => {\n\t\t\t\tconst request = state.requests[id];\n\t\t\t\tif (request) {\n\t\t\t\t\trequest.status = \"success\";\n\t\t\t\t\trequest.endTime = endTime;\n\t\t\t\t\trequest.duration = endTime - request.startTime;\n\t\t\t\t\tif (statusCode !== undefined) request.statusCode = statusCode;\n\t\t\t\t\tif (size !== undefined) request.size = size;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tget().recomputeAll();\n\t\t},\n\n\t\tfailRequest: (id, error, statusCode) => {\n\t\t\tconst endTime = Date.now();\n\n\t\t\tset(state => {\n\t\t\t\tconst request = state.requests[id];\n\t\t\t\tif (request) {\n\t\t\t\t\trequest.status = \"error\";\n\t\t\t\t\trequest.endTime = endTime;\n\t\t\t\t\trequest.duration = endTime - request.startTime;\n\t\t\t\t\trequest.error = error;\n\t\t\t\t\tif (statusCode !== undefined) request.statusCode = statusCode;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tget().recomputeAll();\n\n\t\t\tlogger.warn(\"api\", \"Network request failed\", {\n\t\t\t\tid,\n\t\t\t\terror,\n\t\t\t\tstatusCode\n\t\t\t}, \"NetworkActivityStore\");\n\t\t},\n\n\t\tremoveRequest: (id) => {\n\t\t\tset(state => {\n\t\t\t\tconst { [id]: removed, ...rest } = state.requests;\n\t\t\t\tstate.requests = rest;\n\t\t\t});\n\n\t\t\tget().recomputeAll();\n\t\t},\n\n\t\tclearOldRequests: () => {\n\t\t\tconst { maxHistorySize } = get();\n\t\t\tconst requests = Object.values(get().requests);\n\n\t\t\tif (requests.length <= maxHistorySize) return;\n\n\t\t\t// Keep most recent requests\n\t\t\tconst sorted = requests.sort((a, b) => b.startTime - a.startTime);\n\t\t\tconst toKeep = sorted.slice(0, maxHistorySize);\n\n\t\t\tset(state => {\n\t\t\t\tstate.requests = {};\n\t\t\t\ttoKeep.forEach(req => {\n\t\t\t\t\tstate.requests[req.id] = req;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tget().recomputeAll();\n\n\t\t\tlogger.debug(\"api\", \"Cleared old network requests\", {\n\t\t\t\tremoved: requests.length - toKeep.length,\n\t\t\t\tkept: toKeep.length\n\t\t\t}, \"NetworkActivityStore\");\n\t\t},\n\n\t\tclearAllRequests: () => {\n\t\t\tset(state => {\n\t\t\t\tstate.requests = {};\n\t\t\t});\n\n\t\t\tget().recomputeAll();\n\n\t\t\tlogger.debug(\"api\", \"Cleared all network requests\", {}, \"NetworkActivityStore\");\n\t\t},\n\n\t\t// Filter actions\n\t\tsetStatusFilter: (statuses) => {\n\t\t\tset(state => {\n\t\t\t\tstate.filters.status = statuses;\n\t\t\t});\n\t\t\tget().recomputeFilteredRequests();\n\t\t},\n\n\t\tsetTypeFilter: (types) => {\n\t\t\tset(state => {\n\t\t\t\tstate.filters.type = types;\n\t\t\t});\n\t\t\tget().recomputeFilteredRequests();\n\t\t},\n\n\t\tsetCategoryFilter: (categories) => {\n\t\t\tset(state => {\n\t\t\t\tstate.filters.category = categories;\n\t\t\t});\n\t\t\tget().recomputeFilteredRequests();\n\t\t},\n\n\t\tsetSearchTerm: (term) => {\n\t\t\tset(state => {\n\t\t\t\tstate.filters.searchTerm = term;\n\t\t\t});\n\t\t\tget().recomputeFilteredRequests();\n\t\t},\n\n\t\tsetTimeRange: (hours) => {\n\t\t\tset(state => {\n\t\t\t\tstate.filters.timeRange = hours;\n\t\t\t});\n\t\t\tget().recomputeFilteredRequests();\n\t\t},\n\n\t\tclearFilters: () => {\n\t\t\tset(state => {\n\t\t\t\tstate.filters = {\n\t\t\t\t\tstatus: [],\n\t\t\t\t\ttype: [],\n\t\t\t\t\tcategory: [],\n\t\t\t\t\tsearchTerm: \"\",\n\t\t\t\t\ttimeRange: 24,\n\t\t\t\t};\n\t\t\t});\n\t\t\tget().recomputeFilteredRequests();\n\t\t},\n\n\t\t// Recomputation functions (called after mutations)\n\t\trecomputeActiveRequests: () => {\n\t\t\tset(state => {\n\t\t\t\tstate.activeRequests = computeActiveRequests(state.requests);\n\t\t\t});\n\t\t},\n\n\t\trecomputeRecentRequests: () => {\n\t\t\tset(state => {\n\t\t\t\tstate.recentRequests = computeRecentRequests(state.requests);\n\t\t\t});\n\t\t},\n\n\t\trecomputeNetworkStats: () => {\n\t\t\tset(state => {\n\t\t\t\tstate.networkStats = computeNetworkStats(state.requests);\n\t\t\t});\n\t\t},\n\n\t\trecomputeFilteredRequests: () => {\n\t\t\tset(state => {\n\t\t\t\tstate.filteredRequests = computeFilteredRequests(state.requests, state.filters);\n\t\t\t});\n\t\t},\n\n\t\trecomputeAll: () => {\n\t\t\tconst state = get();\n\t\t\tstate.recomputeActiveRequests();\n\t\t\tstate.recomputeRecentRequests();\n\t\t\tstate.recomputeNetworkStats();\n\t\t\tstate.recomputeFilteredRequests();\n\n\t\t\t// Auto-cleanup old requests\n\t\t\tif (Object.keys(state.requests).length > state.maxHistorySize) {\n\t\t\t\tstate.clearOldRequests();\n\t\t\t}\n\t\t},\n\t}))\n);","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/repository-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/section-registry.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":286,"column":23,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":286,"endColumn":25,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8198,8200],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":286,"column":55,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":286,"endColumn":57,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8230,8232],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":288,"column":19,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":288,"endColumn":21,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8260,8262],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":288,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":288,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[8277,8279],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Section registry for sidebar sections\n * Centralizes section definitions and provides lookup utilities\n */\n\nimport React from \"react\";\nimport {\n\tIconSearch,\n\tIconFilter,\n\tIconGraph,\n\tIconDatabase,\n\tIconLink,\n\tIconInfoCircle,\n\tIconExternalLink,\n\tIconStar,\n\tIconEye,\n\tIconUsers,\n\tIconSettings,\n\tIconActivity,\n\tIconArchive,\n\tIconArrowsExchange,\n\tIconCircleDot,\n\tIconRoute,\n\tIconWaveSquare,\n\tIconBrain,\n} from \"@tabler/icons-react\";\nimport type { SidebarSection } from \"@/types/sidebar-sections\";\n\n// Lazy-loaded section components\nconst SearchSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.SearchSection })));\nconst EntityFiltersSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.EntityFiltersSection })));\nconst GraphActionsSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.GraphActionsSection })));\nconst CacheSettingsSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.CacheSettingsSection })));\nconst EdgeFiltersSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.EdgeFiltersSection })));\nconst EntityInfoSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.EntityInfoSection })));\nconst ExternalLinksSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.ExternalLinksSection })));\nconst ViewOptionsSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.ViewOptionsSection })));\nconst RawApiDataSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.RawApiDataSection })));\nconst GraphStatsSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.GraphStatsSection })));\nconst SettingsSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.SettingsSection })));\nconst NetworkActivitySection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.NetworkActivitySection })));\nconst AppActivitySection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.AppActivitySection })));\nconst NodeRepositorySection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.NodeRepositorySection })));\nconst EdgeRepositorySection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.EdgeRepositorySection })));\nconst AllNodesSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.AllNodesSection })));\nconst AllEdgesSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.AllEdgesSection })));\nconst CustomForcesSection = React.lazy(() => import(\"@/components/sections\").then(m => ({ default: m.CustomForcesSection })));\n\n/**\n * Registry of all available sidebar sections\n */\nexport const SECTION_DEFINITIONS: ReadonlyArray<SidebarSection> = [\n\t// Left sidebar sections (default)\n\t{\n\t\tid: \"search\",\n\t\ttitle: \"Search Academic Entities\",\n\t\ticon: IconSearch,\n\t\tcomponent: SearchSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"data-input\",\n\t\torder: 1,\n\t\ttooltip: \"Search academic entities\",\n\t},\n\t{\n\t\tid: \"entity-filters\",\n\t\ttitle: \"Entity Types & Visibility\",\n\t\ticon: IconFilter,\n\t\tcomponent: EntityFiltersSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"filtering\",\n\t\torder: 2,\n\t\ttooltip: \"Entity & edge filters\",\n\t},\n\t{\n\t\tid: \"graph-actions\",\n\t\ttitle: \"Graph Actions\",\n\t\ticon: IconGraph,\n\t\tcomponent: GraphActionsSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"graph-control\",\n\t\torder: 3,\n\t\ttooltip: \"Graph layout controls\",\n\t},\n\t{\n\t\tid: \"cache-settings\",\n\t\ttitle: \"Cache & Traversal Settings\",\n\t\ticon: IconDatabase,\n\t\tcomponent: CacheSettingsSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"graph-control\",\n\t\torder: 4,\n\t\ttooltip: \"Cache & traversal settings\",\n\t},\n\t{\n\t\tid: \"edge-filters\",\n\t\ttitle: \"Edge Types & Visibility\",\n\t\ticon: IconLink,\n\t\tcomponent: EdgeFiltersSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"filtering\",\n\t\torder: 5,\n\t\ttooltip: \"Edge types & visibility\",\n\t},\n\t{\n\t\tid: \"node-repository\",\n\t\ttitle: \"Node Repository\",\n\t\ticon: IconArchive,\n\t\tcomponent: NodeRepositorySection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"repository\",\n\t\torder: 6,\n\t\ttooltip: \"Drag nodes to add to graph\",\n\t},\n\t{\n\t\tid: \"edge-repository\",\n\t\ttitle: \"Edge Repository\",\n\t\ticon: IconArrowsExchange,\n\t\tcomponent: EdgeRepositorySection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"repository\",\n\t\torder: 7,\n\t\ttooltip: \"Drag edges to add to graph\",\n\t},\n\t{\n\t\tid: \"all-nodes\",\n\t\ttitle: \"All Nodes\",\n\t\ticon: IconCircleDot,\n\t\tcomponent: AllNodesSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"graph-tools\",\n\t\torder: 8,\n\t\ttooltip: \"View and manage all graph nodes\",\n\t},\n\t{\n\t\tid: \"all-edges\",\n\t\ttitle: \"All Edges\",\n\t\ticon: IconRoute,\n\t\tcomponent: AllEdgesSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"graph-tools\",\n\t\torder: 9,\n\t\ttooltip: \"View and manage all graph edges\",\n\t},\n\t{\n\t\tid: \"custom-forces\",\n\t\ttitle: \"Custom Forces\",\n\t\ticon: IconWaveSquare,\n\t\tcomponent: CustomForcesSection,\n\t\tdefaultSidebar: \"left\",\n\t\tcategory: \"graph-control\",\n\t\torder: 10,\n\t\ttooltip: \"Configure custom forces for graph layout\",\n\t},\n\n\t// Right sidebar sections (default)\n\t{\n\t\tid: \"entity-info\",\n\t\ttitle: \"Entity Information\",\n\t\ticon: IconInfoCircle,\n\t\tcomponent: EntityInfoSection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"entity-details\",\n\t\torder: 1,\n\t\ttooltip: \"Entity details\",\n\t},\n\t{\n\t\tid: \"external-links\",\n\t\ttitle: \"External Links\",\n\t\ticon: IconExternalLink,\n\t\tcomponent: ExternalLinksSection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"entity-details\",\n\t\torder: 2,\n\t\ttooltip: \"External links\",\n\t},\n\t{\n\t\tid: \"view-options\",\n\t\ttitle: \"View Options\",\n\t\ticon: IconStar,\n\t\tcomponent: ViewOptionsSection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"view-control\",\n\t\torder: 3,\n\t\ttooltip: \"View options\",\n\t},\n\t{\n\t\tid: \"raw-api-data\",\n\t\ttitle: \"Raw API Data\",\n\t\ticon: IconEye,\n\t\tcomponent: RawApiDataSection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"debugging\",\n\t\torder: 4,\n\t\ttooltip: \"Raw API data\",\n\t},\n\t{\n\t\tid: \"network-activity\",\n\t\ttitle: \"Network Activity\",\n\t\ticon: IconActivity,\n\t\tcomponent: NetworkActivitySection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"debugging\",\n\t\torder: 5,\n\t\ttooltip: \"Monitor network requests and API activity\",\n\t},\n\t{\n\t\tid: \"app-activity\",\n\t\ttitle: \"Application Activity\",\n\t\ticon: IconBrain,\n\t\tcomponent: AppActivitySection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"debugging\",\n\t\torder: 6,\n\t\ttooltip: \"Monitor application events and system activity\",\n\t},\n\t{\n\t\tid: \"graph-stats\",\n\t\ttitle: \"Graph Statistics\",\n\t\ticon: IconUsers,\n\t\tcomponent: GraphStatsSection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"analysis\",\n\t\torder: 7,\n\t\ttooltip: \"Graph statistics\",\n\t},\n\t{\n\t\tid: \"settings\",\n\t\ttitle: \"Settings\",\n\t\ticon: IconSettings,\n\t\tcomponent: SettingsSection,\n\t\tdefaultSidebar: \"right\",\n\t\tcategory: \"settings\",\n\t\torder: 8,\n\t\ttooltip: \"User preferences and data management\",\n\t},\n] as const;\n\n/**\n * Map of section ID to section definition for fast lookup\n */\nexport const SECTIONS_BY_ID = new Map(\n\tSECTION_DEFINITIONS.map(section => [section.id, section])\n);\n\n/**\n * Get section definition by ID\n */\nexport const getSectionById = (id: string): SidebarSection | undefined => {\n\treturn SECTIONS_BY_ID.get(id);\n};\n\n/**\n * Get all section IDs\n */\nexport const getAllSectionIds = (): string[] => {\n\treturn SECTION_DEFINITIONS.map(section => section.id);\n};\n\n/**\n * Get sections by category\n */\nexport const getSectionsByCategory = (category: string): SidebarSection[] => {\n\treturn SECTION_DEFINITIONS.filter(section => section.category === category);\n};\n\n/**\n * Get default section placements for new installations\n */\nexport const getDefaultSectionPlacements = (): Record<string, \"left\" | \"right\"> => {\n\tconst placements: Record<string, \"left\" | \"right\"> = {};\n\n\tfor (const section of SECTION_DEFINITIONS) {\n\t\tplacements[section.id] = section.defaultSidebar;\n\t}\n\n\treturn placements;\n};\n\n/**\n * Get sections sorted by order within their category\n */\nexport const getSectionsSorted = (sections: SidebarSection[]): SidebarSection[] => {\n\treturn [...sections].sort((a, b) => {\n\t\t// Sort by category first, then by order\n\t\tif (a.category !== b.category) {\n\t\t\treturn (a.category || \"\").localeCompare(b.category || \"\");\n\t\t}\n\t\treturn (a.order || 0) - (b.order || 0);\n\t});\n};","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/stores/settings-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/styles/layout.css.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/styles/theme.css.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/types/sidebar-sections.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/src/workers/background.worker.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":8,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":8,"endColumn":12,"suggestions":[{"fix":{"range":[227,297],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":10,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":10,"endColumn":14,"suggestions":[{"fix":{"range":[342,406],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":174,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":174,"endColumn":18,"suggestions":[{"fix":{"range":[6937,7464],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":414,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":416,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[14494,14571],"text":"simulationEngine ??= createSimulationEngine();"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":445,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":447,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[15130,15207],"text":"simulationEngine ??= createSimulationEngine();"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":456,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":458,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[15345,15422],"text":"simulationEngine ??= createSimulationEngine();"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":468,"column":3,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":470,"endColumn":4,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[15611,15688],"text":"simulationEngine ??= createSimulationEngine();"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":482,"column":12,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":482,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":484,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":484,"endColumn":16,"suggestions":[{"fix":{"range":[15875,16158],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":485,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":485,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .type on an `any` value.","line":485,"column":71,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":485,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":486,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":486,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":487,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":487,"endColumn":72},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":493,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":493,"endColumn":20,"suggestions":[{"fix":{"range":[16266,16490],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":518,"column":32,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":518,"endColumn":51},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":556,"column":38,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":556,"endColumn":54},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":559,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":559,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":564,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":564,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":579,"column":38,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":579,"endColumn":62},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":580,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":580,"endColumn":48},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":584,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":584,"endColumn":48},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":609,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":609,"endColumn":48},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":613,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":613,"endColumn":48},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":650,"column":30,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":650,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":699,"column":38,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":699,"endColumn":54},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":702,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":702,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":726,"column":38,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":726,"endColumn":54},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":727,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":727,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":754,"column":24,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":754,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":768,"column":55,"nodeType":"Property","messageId":"anyAssignment","endLine":768,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .type on an `any` value.","line":775,"column":85,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":775,"endColumn":89},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":785,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":785,"endColumn":11}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Background Worker with D3 Force Simulation Implementation\n * Uses ForceSimulationEngine for testable simulation logic\n * Supports deterministic seeded layouts and real-time position updates\n */\n\n// Log when worker loads\nconsole.log(\"🤖 WORKER DEBUG: Background worker loaded and starting\");\nself.addEventListener(\"message\", (e) => {\n  console.log(\"🤖 WORKER DEBUG: Worker received message\", e.data);\n});\n\nimport { z } from \"zod\";\nimport { WorkerEventType } from \"@academic-explorer/graph\";\nimport { createLocalEventBus } from \"@academic-explorer/graph\";\nimport { logger } from \"@academic-explorer/utils/logger\";\nimport type {\n  SimulationNode as ForceSimulationNode,\n  SimulationLink as ForceSimulationLink,\n  ForceSimulationConfig\n} from \"@academic-explorer/simulation\";\nimport type { EntityType } from \"@academic-explorer/graph\";\nimport { ForceSimulationEngine, DEFAULT_FORCE_PARAMS } from \"@academic-explorer/simulation\";\n\n// Create worker event bus for cross-context communication\nconst workerEventBus = createLocalEventBus();\n\n// Type guard for EntityType validation\nfunction isValidEntityType(value: unknown): value is EntityType {\n  return typeof value === \"string\" &&\n    [\"works\", \"authors\", \"sources\", \"institutions\", \"topics\", \"concepts\", \"publishers\", \"funders\", \"keywords\"].includes(value);\n}\n\n// Helper to safely extract defined properties from Zod-validated config\n// Handles exactOptionalPropertyTypes by only including properties with defined values\nfunction extractDefinedProperties(config: Record<string, unknown>): Partial<ForceSimulationConfig> {\n  const result: Partial<ForceSimulationConfig> = {};\n\n  // Use object spreading to only include defined properties\n  if (typeof config['alphaDecay'] === 'number') {\n    result.alphaDecay = config['alphaDecay'];\n  }\n  if (typeof config['velocityDecay'] === 'number') {\n    result.velocityDecay = config['velocityDecay'];\n  }\n  if (typeof config['maxIterations'] === 'number') {\n    result.maxIterations = config['maxIterations'];\n  }\n  if (typeof config['seed'] === 'number') {\n    result.seed = config['seed'];\n  }\n  if (typeof config['linkDistance'] === 'number') {\n    result.linkDistance = config['linkDistance'];\n  }\n  if (typeof config['linkStrength'] === 'number') {\n    result.linkStrength = config['linkStrength'];\n  }\n  if (typeof config['chargeStrength'] === 'number') {\n    result.chargeStrength = config['chargeStrength'];\n  }\n  if (typeof config['centerStrength'] === 'number') {\n    result.centerStrength = config['centerStrength'];\n  }\n  if (typeof config['collisionRadius'] === 'number') {\n    result.collisionRadius = config['collisionRadius'];\n  }\n  if (typeof config['collisionStrength'] === 'number') {\n    result.collisionStrength = config['collisionStrength'];\n  }\n  if (typeof config['targetFPS'] === 'number') {\n    result.targetFPS = config['targetFPS'];\n  }\n  if (typeof config['sendEveryNTicks'] === 'number') {\n    result.sendEveryNTicks = config['sendEveryNTicks'];\n  }\n  if (typeof config['enableOptimizations'] === 'boolean') {\n    result.enableOptimizations = config['enableOptimizations'];\n  }\n  if (typeof config['batchUpdates'] === 'boolean') {\n    result.batchUpdates = config['batchUpdates'];\n  }\n\n  return result;\n}\n\n// Helper to create a ForceSimulationConfig with conditional spreads for exact optional types\nfunction createSafeConfig(config: Record<string, unknown> | undefined): Required<ForceSimulationConfig> {\n  if (!config) return DEFAULT_FORCE_PARAMS;\n\n  const result: Required<ForceSimulationConfig> = { ...DEFAULT_FORCE_PARAMS };\n\n  // Only override properties that are present and of the correct type\n  if (config['alphaDecay'] !== undefined && typeof config['alphaDecay'] === 'number') {\n    result.alphaDecay = config['alphaDecay'];\n  }\n  if (config['velocityDecay'] !== undefined && typeof config['velocityDecay'] === 'number') {\n    result.velocityDecay = config['velocityDecay'];\n  }\n  if (config['maxIterations'] !== undefined && typeof config['maxIterations'] === 'number') {\n    result.maxIterations = config['maxIterations'];\n  }\n  if (config['seed'] !== undefined && typeof config['seed'] === 'number') {\n    result.seed = config['seed'];\n  }\n  if (config['linkDistance'] !== undefined && typeof config['linkDistance'] === 'number') {\n    result.linkDistance = config['linkDistance'];\n  }\n  if (config['linkStrength'] !== undefined && typeof config['linkStrength'] === 'number') {\n    result.linkStrength = config['linkStrength'];\n  }\n  if (config['chargeStrength'] !== undefined && typeof config['chargeStrength'] === 'number') {\n    result.chargeStrength = config['chargeStrength'];\n  }\n  if (config['centerStrength'] !== undefined && typeof config['centerStrength'] === 'number') {\n    result.centerStrength = config['centerStrength'];\n  }\n  if (config['collisionRadius'] !== undefined && typeof config['collisionRadius'] === 'number') {\n    result.collisionRadius = config['collisionRadius'];\n  }\n  if (config['collisionStrength'] !== undefined && typeof config['collisionStrength'] === 'number') {\n    result.collisionStrength = config['collisionStrength'];\n  }\n  if (config['targetFPS'] !== undefined && typeof config['targetFPS'] === 'number') {\n    result.targetFPS = config['targetFPS'];\n  }\n  if (config['sendEveryNTicks'] !== undefined && typeof config['sendEveryNTicks'] === 'number') {\n    result.sendEveryNTicks = config['sendEveryNTicks'];\n  }\n  if (config['enableOptimizations'] !== undefined && typeof config['enableOptimizations'] === 'boolean') {\n    result.enableOptimizations = config['enableOptimizations'];\n  }\n  if (config['batchUpdates'] !== undefined && typeof config['batchUpdates'] === 'boolean') {\n    result.batchUpdates = config['batchUpdates'];\n  }\n\n  return result;\n}\n\n// Helper to validate and ensure links have required properties\nfunction validateLinks(links: unknown[]): ForceSimulationLink[] {\n  return links.filter((link): link is ForceSimulationLink => {\n    return typeof link === 'object' &&\n           link !== null &&\n           'id' in link && typeof link.id === 'string' &&\n           'source' in link && typeof link.source === 'string' &&\n           'target' in link && typeof link.target === 'string';\n  });\n}\n\n// Worker state\nlet simulationEngine: ForceSimulationEngine | null = null;\nlet startTime = 0;\nlet lastProgressTime = 0;\nlet lastFpsTime = 0;\nlet frameCount = 0;\nlet currentSimulationTaskId: string | null = null;\nconst PROGRESS_THROTTLE_MS = 16; // ~60fps\nconst FPS_CALCULATION_INTERVAL = 1000; // 1 second\n\n// Create simulation engine with event listeners\nfunction createSimulationEngine(): ForceSimulationEngine {\n  const engine = new ForceSimulationEngine({\n    logger,\n    config: DEFAULT_FORCE_PARAMS,\n    progressThrottleMs: PROGRESS_THROTTLE_MS,\n    fpsIntervalMs: FPS_CALCULATION_INTERVAL\n  });\n\n  // Set up event listeners\n  engine.on(\"progress\", (event) => {\n    const now = Date.now();\n\n    if (event.messageType === \"tick\") {\n      console.log(\"🔄 WORKER TICK: Sending progress update\", {\n        messageType: event.messageType,\n        positionsLength: event.positions?.length,\n        alpha: event.alpha,\n        iteration: event.iteration,\n        timeSinceLastProgress: now - lastProgressTime,\n        throttleMs: PROGRESS_THROTTLE_MS,\n        samplePosition: event.positions?.[0] ? {\n          id: event.positions[0].id,\n          x: Number(event.positions[0].x.toFixed(2)),\n          y: Number(event.positions[0].y.toFixed(2))\n        } : null\n      });\n    }\n\n    // Throttle progress updates except for important state changes\n    if (event.messageType === \"tick\" && (now - lastProgressTime) < PROGRESS_THROTTLE_MS) {\n      logger.debug(\"worker\", \"Throttling tick event\");\n      return;\n    }\n\n    lastProgressTime = now;\n\n    // Calculate FPS for tick messages\n    let fps = 0;\n    if (event.messageType === \"tick\") {\n      frameCount++;\n      if (now - lastFpsTime >= FPS_CALCULATION_INTERVAL) {\n        fps = Math.round((frameCount * 1000) / (now - lastFpsTime));\n        frameCount = 0;\n        lastFpsTime = now;\n      }\n    }\n\n    const progress = event.alpha ? Math.max(0, Math.min(1, 1 - event.alpha)) : 1;\n\n    const progressEvent = {\n      type: WorkerEventType.FORCE_SIMULATION_PROGRESS,\n      payload: {\n        workerId: \"background-worker\",\n        workerType: \"force-animation\" as const,\n        messageType: event.messageType,\n        positions: event.positions,\n        alpha: event.alpha,\n        iteration: event.iteration,\n        progress,\n        ...(fps && { fps }),\n        nodeCount: event.nodeCount,\n        linkCount: event.linkCount,\n        timestamp: now\n      }\n    };\n\n    workerEventBus.emit(progressEvent);\n\n    const message = {\n      type: \"PROGRESS\" as const,\n      ...(currentSimulationTaskId && { taskId: currentSimulationTaskId }),\n      payload: {\n        type: WorkerEventType.FORCE_SIMULATION_PROGRESS,\n        ...progressEvent.payload\n      }\n    };\n\n    if (event.messageType === \"tick\") {\n      logger.debug(\"worker\", \"Worker postMessage\", { messageType: event.messageType, payloadType: message.payload.type });\n    }\n\n    self.postMessage(message);\n  });\n\n  engine.on(\"complete\", (event) => {\n    const completeEvent = {\n      type: WorkerEventType.FORCE_SIMULATION_COMPLETE,\n      payload: {\n        workerId: \"background-worker\",\n        workerType: \"force-animation\" as const,\n        positions: event.positions,\n        totalIterations: event.totalIterations,\n        finalAlpha: event.finalAlpha,\n        reason: event.reason,\n        timestamp: Date.now()\n      }\n    };\n\n    workerEventBus.emit(completeEvent);\n\n    self.postMessage({\n      type: \"SUCCESS\" as const,\n      ...(currentSimulationTaskId && { taskId: currentSimulationTaskId }),\n      payload: {\n        type: WorkerEventType.FORCE_SIMULATION_COMPLETE,\n        ...completeEvent.payload\n      }\n    });\n\n    currentSimulationTaskId = null;\n  });\n\n  engine.on(\"error\", (event) => {\n    const errorPayload = {\n      workerId: \"background-worker\",\n      workerType: \"force-animation\" as const,\n      error: event.message,\n      context: {\n        ...event.context,\n        runtime: startTime > 0 ? Date.now() - startTime : 0\n      },\n      timestamp: Date.now()\n    };\n\n    logger.error(\"worker\", \"Force simulation error with context\", errorPayload);\n\n    workerEventBus.emit({\n      type: WorkerEventType.FORCE_SIMULATION_ERROR,\n      payload: errorPayload\n    });\n\n    self.postMessage({\n      type: \"ERROR\" as const,\n      ...(currentSimulationTaskId && { taskId: currentSimulationTaskId }),\n      payload: `Force simulation error: ${event.message}. Context: ${JSON.stringify(errorPayload.context)}`\n    });\n  });\n\n  return engine;\n}\n\n\n// Zod schemas for type validation\nconst forceSimulationNodeSchema = z.object({\n  id: z.string(),\n  type: z.enum([\"works\", \"authors\", \"sources\", \"institutions\", \"topics\", \"concepts\", \"publishers\", \"funders\", \"keywords\"]).optional(),\n  x: z.number().optional(),\n  y: z.number().optional(),\n  fx: z.number().optional(),\n  fy: z.number().optional(),\n});\n\nconst forceSimulationLinkSchema = z.object({\n  id: z.string(),\n  source: z.string(),\n  target: z.string(),\n});\n\nconst forceSimulationConfigSchema = z.object({\n  linkDistance: z.number().optional(),\n  linkStrength: z.number().optional(),\n  chargeStrength: z.number().optional(),\n  centerStrength: z.number().optional(),\n  collisionRadius: z.number().optional(),\n  collisionStrength: z.number().optional(),\n  velocityDecay: z.number().optional(),\n  alphaDecay: z.number().optional(),\n  maxIterations: z.number().optional(),\n  seed: z.number().optional(),\n});\n\nconst forceSimulationStartMessageSchema = z.object({\n  type: z.literal(\"FORCE_SIMULATION_START\"),\n  nodes: z.array(forceSimulationNodeSchema),\n  links: z.array(forceSimulationLinkSchema),\n  config: forceSimulationConfigSchema.optional(),\n  pinnedNodes: z.array(z.string()).optional(),\n});\n\nconst forceSimulationControlMessageSchema = z.object({\n  type: z.enum([\"FORCE_SIMULATION_STOP\", \"FORCE_SIMULATION_PAUSE\", \"FORCE_SIMULATION_RESUME\", \"FORCE_SIMULATION_UPDATE_PARAMETERS\", \"FORCE_SIMULATION_REHEAT\", \"FORCE_SIMULATION_UPDATE_LINKS\", \"FORCE_SIMULATION_UPDATE_NODES\"]),\n  config: forceSimulationConfigSchema.partial().optional(),\n});\n\nconst forceSimulationReheatMessageSchema = z.object({\n  type: z.literal(\"FORCE_SIMULATION_REHEAT\"),\n  nodes: z.array(forceSimulationNodeSchema),\n  links: z.array(forceSimulationLinkSchema),\n  config: forceSimulationConfigSchema.optional(),\n  pinnedNodes: z.array(z.string()).optional(),\n  alpha: z.number().optional().default(1.0),\n});\n\nconst forceSimulationUpdateLinksMessageSchema = z.object({\n  type: z.literal(\"FORCE_SIMULATION_UPDATE_LINKS\"),\n  links: z.array(forceSimulationLinkSchema),\n  alpha: z.number().optional().default(1.0), // Full alpha reset to restart current simulation\n});\n\nconst forceSimulationUpdateNodesMessageSchema = z.object({\n  type: z.literal(\"FORCE_SIMULATION_UPDATE_NODES\"),\n  nodes: z.array(forceSimulationNodeSchema),\n  pinnedNodes: z.array(z.string()).optional(),\n  alpha: z.number().optional().default(1.0),\n});\n\ntype ForceSimulationControlAction = z.infer<typeof forceSimulationControlMessageSchema>[\"type\"];\n\nfunction sendControlAck(taskId: string | undefined, action: ForceSimulationControlAction, extra: Record<string, unknown> = {}) {\n  if (!taskId) {\n    return;\n  }\n\n  self.postMessage({\n    type: \"SUCCESS\" as const,\n    taskId,\n    payload: {\n      type: \"FORCE_SIMULATION_CONTROL_ACK\",\n      action,\n      status: \"ok\",\n      timestamp: Date.now(),\n      ...extra\n    }\n  });\n}\n\n// Schema for worker pool task wrapper\nconst executeTaskMessageSchema = z.object({\n  type: z.literal(\"EXECUTE_TASK\"),\n  taskId: z.string(),\n  payload: z.unknown()\n});\n\n// Type guards using Zod\nfunction isForceSimulationStartMessage(data: unknown): data is z.infer<typeof forceSimulationStartMessageSchema> {\n  return forceSimulationStartMessageSchema.safeParse(data).success;\n}\n\nfunction isForceSimulationMessage(data: unknown): data is z.infer<typeof forceSimulationControlMessageSchema> {\n  return forceSimulationControlMessageSchema.safeParse(data).success;\n}\n\nfunction isExecuteTaskMessage(data: unknown): data is z.infer<typeof executeTaskMessageSchema> {\n  return executeTaskMessageSchema.safeParse(data).success;\n}\n\n// Simple wrapper functions that delegate to the ForceSimulationEngine\nfunction startSimulation(params: {\n  nodes: ForceSimulationNode[];\n  links: ForceSimulationLink[];\n  config?: ForceSimulationConfig;\n  pinnedNodes?: string[];\n}) {\n  if (!simulationEngine) {\n    simulationEngine = createSimulationEngine();\n  }\n\n  startTime = Date.now();\n  simulationEngine.start(params);\n}\n\nfunction stopSimulation() {\n  simulationEngine?.stop();\n}\n\nfunction pauseSimulation() {\n  simulationEngine?.pause();\n}\n\nfunction resumeSimulation() {\n  simulationEngine?.resume();\n}\n\nfunction updateSimulationParameters(config: Partial<ForceSimulationConfig>) {\n  simulationEngine?.updateParameters(config);\n}\n\nfunction reheatSimulation(params: {\n  nodes: ForceSimulationNode[];\n  links: ForceSimulationLink[];\n  config: ForceSimulationConfig;\n  pinnedNodes?: string[];\n  alpha?: number;\n}) {\n  if (!simulationEngine) {\n    simulationEngine = createSimulationEngine();\n  }\n\n  simulationEngine.reheat(params);\n}\n\nfunction updateSimulationLinks(params: {\n  links: ForceSimulationLink[];\n  alpha?: number;\n}) {\n  if (!simulationEngine) {\n    simulationEngine = createSimulationEngine();\n  }\n\n  simulationEngine.updateLinks(params.links, params.alpha);\n}\n\nfunction updateSimulationNodes(params: {\n  nodes: ForceSimulationNode[];\n  pinnedNodes?: string[];\n  alpha?: number;\n}) {\n  if (!simulationEngine) {\n    simulationEngine = createSimulationEngine();\n  }\n\n  simulationEngine.updateNodes(params.nodes, params.pinnedNodes ?? [], params.alpha);\n}\n\n\n\n\n\n\n  // Message handling\n  self.onmessage = (e: MessageEvent) => {\n    const {data} = e;\n\n    console.log(\"📨 WORKER: Received message\", {\n      type: data && typeof data === \"object\" && \"type\" in data ? data.type : \"unknown\",\n      hasTaskId: data && typeof data === \"object\" && \"taskId\" in data,\n      hasPayload: data && typeof data === \"object\" && \"payload\" in data\n    });\n\n    try {\n      // Handle worker pool task wrapper format\n      if (isExecuteTaskMessage(data)) {\n        console.log(\"📨 WORKER: Processing EXECUTE_TASK\", {\n          taskId: data.taskId,\n          payloadType: data.payload && typeof data.payload === \"object\" && \"type\" in data.payload ? data.payload.type : \"unknown\"\n        });\n\n        logger.debug(\"worker\", \"Received EXECUTE_TASK message\", {\n          taskId: data.taskId,\n          payloadType: typeof data.payload\n        });\n\n      // Extract the actual payload and process it\n      const actualPayload = data.payload;\n\n      if (isForceSimulationStartMessage(actualPayload)) {\n        const validatedNodes = actualPayload.nodes.map(node => ({\n          id: node.id,\n          x: node.x ?? 0,\n          y: node.y ?? 0,\n          fx: node.fx ?? null,\n          fy: node.fy ?? null,\n          ...(isValidEntityType(node.type) && { type: node.type })\n        }));\n        currentSimulationTaskId = data.taskId;\n        startSimulation({\n          nodes: validatedNodes,\n          links: validateLinks(actualPayload.links ?? []),\n          config: createSafeConfig(actualPayload.config),\n          pinnedNodes: actualPayload.pinnedNodes ?? []\n        });\n      } else if (isForceSimulationMessage(actualPayload)) {\n        switch (actualPayload.type) {\n          case \"FORCE_SIMULATION_STOP\":\n            stopSimulation();\n            sendControlAck(data.taskId, actualPayload.type);\n            break;\n          case \"FORCE_SIMULATION_PAUSE\":\n            pauseSimulation();\n            sendControlAck(data.taskId, actualPayload.type);\n            break;\n          case \"FORCE_SIMULATION_RESUME\":\n            resumeSimulation();\n            sendControlAck(data.taskId, actualPayload.type);\n            break;\n          case \"FORCE_SIMULATION_UPDATE_PARAMETERS\":\n            if (actualPayload.config) {\n              const definedConfig = extractDefinedProperties(actualPayload.config);\n              updateSimulationParameters(definedConfig);\n            }\n            sendControlAck(data.taskId, actualPayload.type);\n            break;\n          case \"FORCE_SIMULATION_REHEAT\":\n            if (forceSimulationReheatMessageSchema.safeParse(actualPayload).success) {\n              const reheatData = forceSimulationReheatMessageSchema.parse(actualPayload);\n              const validatedNodes = reheatData.nodes.map(node => ({\n                id: node.id,\n                x: node.x ?? 0,\n                y: node.y ?? 0,\n                fx: node.fx ?? null,\n                fy: node.fy ?? null,\n                ...(isValidEntityType(node.type) && { type: node.type })\n              }));\n              reheatSimulation({\n                nodes: validatedNodes,\n                links: validateLinks(reheatData.links ?? []),\n                config: createSafeConfig(reheatData.config),\n                pinnedNodes: reheatData.pinnedNodes ?? [],\n                alpha: reheatData.alpha ?? 1.0\n              });\n              sendControlAck(data.taskId, actualPayload.type, {\n                nodeCount: validatedNodes.length,\n                linkCount: reheatData.links.length,\n                alpha: reheatData.alpha ?? 1.0\n              });\n            } else {\n              logger.warn(\"worker\", \"Invalid reheat payload in task\", { actualPayload });\n              self.postMessage({\n                type: \"ERROR\" as const,\n                taskId: data.taskId,\n                payload: \"Invalid reheat payload\"\n              });\n            }\n            break;\n          case \"FORCE_SIMULATION_UPDATE_LINKS\":\n            if (forceSimulationUpdateLinksMessageSchema.safeParse(actualPayload).success) {\n              const updateLinksPayload = forceSimulationUpdateLinksMessageSchema.parse(actualPayload);\n              updateSimulationLinks({\n                links: validateLinks(updateLinksPayload.links ?? []),\n                alpha: updateLinksPayload.alpha ?? 1.0\n              });\n              sendControlAck(data.taskId, actualPayload.type, {\n                linkCount: updateLinksPayload.links.length,\n                alpha: updateLinksPayload.alpha ?? 1.0\n              });\n            } else {\n              logger.warn(\"worker\", \"Invalid link update payload in task\", { actualPayload });\n              self.postMessage({\n                type: \"ERROR\" as const,\n                taskId: data.taskId,\n                payload: \"Invalid link update payload\"\n              });\n            }\n            break;\n          case \"FORCE_SIMULATION_UPDATE_NODES\":\n            if (forceSimulationUpdateNodesMessageSchema.safeParse(actualPayload).success) {\n              const updateNodesPayload = forceSimulationUpdateNodesMessageSchema.parse(actualPayload);\n              const validatedNodes = updateNodesPayload.nodes.map(node => ({\n                id: node.id,\n                x: node.x ?? 0,\n                y: node.y ?? 0,\n                fx: node.fx ?? null,\n                fy: node.fy ?? null,\n                ...(isValidEntityType(node.type) && { type: node.type })\n              }));\n              updateSimulationNodes({\n                nodes: validatedNodes,\n                pinnedNodes: updateNodesPayload.pinnedNodes ?? [],\n                alpha: updateNodesPayload.alpha ?? 1.0\n              });\n              sendControlAck(data.taskId, actualPayload.type, {\n                nodeCount: validatedNodes.length,\n                alpha: updateNodesPayload.alpha ?? 1.0,\n                pinnedCount: updateNodesPayload.pinnedNodes?.length ?? 0\n              });\n            } else {\n              logger.warn(\"worker\", \"Invalid node update payload in task\", { actualPayload });\n              self.postMessage({\n                type: \"ERROR\" as const,\n                taskId: data.taskId,\n                payload: \"Invalid node update payload\"\n              });\n            }\n            break;\n          default:\n            logger.warn(\"worker\", \"Unknown simulation control message in task\", { actualPayload });\n            self.postMessage({\n              type: \"ERROR\" as const,\n              taskId: data.taskId,\n              payload: `Unknown control message: ${String(actualPayload.type)}`\n            });\n        }\n      } else {\n        logger.warn(\"worker\", \"Unknown task payload format\", {\n          taskId: data.taskId,\n          payload: actualPayload\n        });\n      }\n    }\n    // Handle direct message format (for backwards compatibility)\n    else if (isForceSimulationStartMessage(data)) {\n      startSimulation({\n        nodes: data.nodes.map(node => ({\n          id: node.id,\n          x: node.x ?? 0,\n          y: node.y ?? 0,\n          fx: node.fx ?? null,\n          fy: node.fy ?? null\n        })),\n        links: validateLinks(data.links ?? []),\n        config: createSafeConfig(data.config),\n        pinnedNodes: data.pinnedNodes ?? []\n      });\n    } else if (isForceSimulationMessage(data)) {\n      switch (data.type) {\n        case \"FORCE_SIMULATION_STOP\":\n          stopSimulation();\n          break;\n\n        case \"FORCE_SIMULATION_PAUSE\":\n          pauseSimulation();\n          break;\n\n        case \"FORCE_SIMULATION_RESUME\":\n          resumeSimulation();\n          break;\n\n        case \"FORCE_SIMULATION_UPDATE_PARAMETERS\":\n          if (data.config) {\n            const definedConfig = extractDefinedProperties(data.config);\n            updateSimulationParameters(definedConfig);\n          }\n          break;\n\n        case \"FORCE_SIMULATION_REHEAT\":\n          // Handle reheat with updated data\n          logger.debug(\"worker\", \"Worker received reheat message\", data);\n          if (forceSimulationReheatMessageSchema.safeParse(data).success) {\n            const reheatData = forceSimulationReheatMessageSchema.parse(data);\n            // Convert nodes to proper ForceSimulationNode format with type guard\n            const validatedNodes = reheatData.nodes.map(node => ({\n              id: node.id,\n              x: node.x ?? 0,\n              y: node.y ?? 0,\n              fx: node.fx ?? null,\n              fy: node.fy ?? null,\n              ...(isValidEntityType(node.type) && { type: node.type })\n            }));\n            logger.debug(\"worker\", \"Worker calling reheatSimulation\", {\n              nodeCount: validatedNodes.length,\n              linkCount: reheatData.links.length,\n              alpha: reheatData.alpha,\n              linkDetails: reheatData.links.map(link => ({ id: link.id, source: link.source, target: link.target }))\n            });\n            try {\n              logger.debug(\"worker\", \"About to call reheatSimulation\");\n              reheatSimulation({\n                nodes: validatedNodes,\n                links: validateLinks(reheatData.links ?? []),\n                config: createSafeConfig(reheatData.config),\n                pinnedNodes: reheatData.pinnedNodes ?? [],\n                alpha: reheatData.alpha ?? 1.0\n              });\n              logger.debug(\"worker\", \"ReheatSimulation call completed\");\n            } catch (error) {\n              logger.error(\"worker\", \"Error calling reheatSimulation\", { error });\n            }\n          } else {\n            logger.error(\"worker\", \"Worker reheat message validation failed\", { error: forceSimulationReheatMessageSchema.safeParse(data).error });\n          }\n          break;\n\n        case \"FORCE_SIMULATION_UPDATE_LINKS\":\n          // Handle dynamic link updates during running simulation\n          logger.debug(\"worker\", \"Worker received update links message\", data);\n          if (forceSimulationUpdateLinksMessageSchema.safeParse(data).success) {\n            const updateData = forceSimulationUpdateLinksMessageSchema.parse(data);\n            logger.debug(\"worker\", \"Worker calling updateSimulationLinks\", {\n              linkCount: updateData.links.length,\n              alpha: updateData.alpha,\n              linkDetails: updateData.links.slice(0, 3).map(link => ({ id: link.id, source: link.source, target: link.target }))\n            });\n            try {\n              logger.debug(\"worker\", \"About to call updateSimulationLinks\");\n              updateSimulationLinks({\n                links: validateLinks(updateData.links ?? []),\n                alpha: updateData.alpha ?? 1.0\n              });\n              logger.debug(\"worker\", \"UpdateSimulationLinks call completed\");\n            } catch (error) {\n              logger.error(\"worker\", \"Error calling updateSimulationLinks\", { error });\n            }\n          } else {\n            logger.error(\"worker\", \"Worker update links message validation failed\", { error: forceSimulationUpdateLinksMessageSchema.safeParse(data).error });\n          }\n          break;\n\n        case \"FORCE_SIMULATION_UPDATE_NODES\":\n          logger.debug(\"worker\", \"Worker received update nodes message\", data);\n          if (forceSimulationUpdateNodesMessageSchema.safeParse(data).success) {\n            const updateData = forceSimulationUpdateNodesMessageSchema.parse(data);\n            try {\n              const validatedNodes = updateData.nodes.map(node => ({\n                id: node.id,\n                x: node.x ?? 0,\n                y: node.y ?? 0,\n                fx: node.fx ?? null,\n                fy: node.fy ?? null,\n                ...(isValidEntityType(node.type) && { type: node.type })\n              }));\n              updateSimulationNodes({\n                nodes: validatedNodes,\n                pinnedNodes: updateData.pinnedNodes ?? [],\n                alpha: updateData.alpha ?? 1.0\n              });\n            } catch (error) {\n              logger.error(\"worker\", \"Error calling updateSimulationNodes\", { error });\n            }\n          } else {\n            logger.error(\"worker\", \"Worker update nodes message validation failed\", { error: forceSimulationUpdateNodesMessageSchema.safeParse(data).error });\n          }\n          break;\n\n        default:\n          logger.warn(\"worker\", \"Unknown simulation message type\", { type: data.type });\n      }\n    } else {\n      logger.warn(\"worker\", \"Unknown message type\", { data });\n    }\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorStack = error instanceof Error ? error.stack : \"No stack trace\";\n    const errorContext = {\n      messageData: JSON.stringify(data).substring(0, 200) + \"...\",\n      messageType: typeof data === \"object\" && data && \"type\" in data ? String(data.type) : \"unknown\",\n      errorStack,\n      workerState: {\n        hasSimulationEngine: !!simulationEngine\n      }\n    };\n\n    logger.error(\"worker\", \"Error handling worker message\", {\n      error: errorMessage,\n      stack: errorStack,\n      data,\n      context: errorContext\n    });\n    self.postMessage({\n      type: \"ERROR\",\n      payload: `Message handling error: ${errorMessage}. Context: ${JSON.stringify(errorContext)}`\n    });\n  }\n};\n\n// Initialize worker\nfunction initializeWorker() {\n  try {\n    // Emit worker ready event via both event bus (for worker context) and postMessage (for main thread)\n    const readyEvent = {\n      type: WorkerEventType.WORKER_READY,\n      payload: {\n        workerId: \"background-worker\",\n        workerType: \"force-animation\",\n        timestamp: Date.now()\n      }\n    };\n\n    // Emit via event bus for worker context\n    workerEventBus.emit(readyEvent);\n\n    // Post message to main thread\n    self.postMessage(readyEvent);\n\n    logger.debug(\"worker\", \"D3 Force simulation worker initialized successfully\");\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorStack = error instanceof Error ? error.stack : \"No stack trace\";\n    const errorContext = {\n      initializationPhase: \"worker_setup\",\n      errorStack,\n      workerState: {\n        hasSimulationEngine: !!simulationEngine\n      }\n    };\n\n    logger.error(\"worker\", \"Failed to initialize D3 force simulation worker\", {\n      error: errorMessage,\n      stack: errorStack,\n      context: errorContext\n    });\n\n    const errorEvent = {\n      type: WorkerEventType.WORKER_ERROR,\n      payload: {\n        workerId: \"background-worker\",\n        workerType: \"force-animation\",\n        error: `Worker initialization failed: ${errorMessage}`,\n        context: errorContext,\n        timestamp: Date.now()\n      }\n    };\n\n    workerEventBus.emit(errorEvent);\n    // Send error to TaskQueue in expected format\n    self.postMessage({\n      type: \"ERROR\",\n      payload: `Worker initialization failed: ${errorMessage}. Context: ${JSON.stringify(errorContext)}`\n    });\n  }\n}\n\n// Handle worker termination\nself.addEventListener(\"beforeunload\", () => {\n  if (simulationEngine) {\n    simulationEngine.stop();\n  }\n});\n\n// Initialize worker on startup\ntry {\n  initializeWorker();\n} catch (error: unknown) {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const errorStack = error instanceof Error ? error.stack : \"No stack trace\";\n  const errorContext = {\n    initializationPhase: \"global_init\",\n    errorStack,\n    workerEnvironment: {\n      hasSimulationEngine: !!simulationEngine,\n      hasLogger: typeof logger !== \"undefined\",\n      hasEventBus: !!workerEventBus\n    }\n  };\n\n  const errorEvent = {\n    type: WorkerEventType.WORKER_ERROR,\n    payload: {\n      workerId: \"background-worker\",\n      workerType: \"force-animation\",\n      error: `Global worker initialization failed: ${errorMessage}`,\n      context: errorContext,\n      timestamp: Date.now()\n    }\n  };\n\n  workerEventBus.emit(errorEvent);\n  // Send error to TaskQueue in expected format\n  self.postMessage({\n    type: \"ERROR\",\n    payload: `Global worker initialization failed: ${errorMessage}. Context: ${JSON.stringify(errorContext)}`\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/vite.config.ts","messages":[{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'devtools' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":18,"fix":{"range":[244,295],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'openalexDataPlugin' is defined but never used.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":28,"fix":{"range":[454,533],"text":"\n"}},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":29,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":29,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1267,1269],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":40,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":40,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1680,1682],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'mode' is defined but never used. Allowed unused args must match /^_/u.","line":47,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":36},{"ruleId":"@typescript-eslint/no-deprecated","severity":2,"message":"`TanStackRouterVite` is deprecated. Use `tanstackRouter` instead.","line":63,"column":5,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":63,"endColumn":23}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { TanStackRouterVite } from '@tanstack/router-plugin/vite'\nimport { vanillaExtractPlugin } from '@vanilla-extract/vite-plugin'\nimport { devtools } from '@tanstack/devtools-vite'\nimport { VitePWA } from 'vite-plugin-pwa'\nimport path from 'path'\nimport { execSync } from 'child_process'\nimport { workspaceRoot } from '../../config/shared'\nimport { openalexDataPlugin } from './src/build-plugins/openalex-data-plugin'\n\n// Build metadata generation\nfunction getBuildInfo() {\n  try {\n    const now = new Date()\n    const commitHash = execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim()\n    const shortCommitHash = execSync('git rev-parse --short HEAD', { encoding: 'utf8' }).trim()\n    const commitTimestamp = execSync('git log -1 --format=%ct', { encoding: 'utf8' }).trim()\n    const commitDate = new Date(parseInt(commitTimestamp) * 1000)\n    const branchName = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim()\n\n    return {\n      buildTimestamp: now.toISOString(),\n      commitHash,\n      shortCommitHash,\n      commitTimestamp: commitDate.toISOString(),\n      branchName,\n      version: process.env.npm_package_version || '0.0.0',\n      repositoryUrl: 'https://github.com/Mearman/Academic-Explorer'\n    }\n  } catch (error) {\n    console.warn('Failed to get git information:', error)\n    return {\n      buildTimestamp: new Date().toISOString(),\n      commitHash: 'unknown',\n      shortCommitHash: 'unknown',\n      commitTimestamp: new Date().toISOString(),\n      branchName: 'unknown',\n      version: process.env.npm_package_version || '0.0.0',\n      repositoryUrl: 'https://github.com/Mearman/Academic-Explorer'\n    }\n  }\n}\n\n// https://vite.dev/config/\nexport default defineConfig(({ mode }) => ({\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n      '@academic-explorer/utils': path.resolve(workspaceRoot, 'packages/utils/src'),\n      '@academic-explorer/client': path.resolve(workspaceRoot, 'packages/client/src'),\n      '@academic-explorer/ui': path.resolve(workspaceRoot, 'packages/ui/src'),\n      '@academic-explorer/graph': path.resolve(workspaceRoot, 'packages/graph/src'),\n      '@academic-explorer/simulation': path.resolve(workspaceRoot, 'packages/simulation/src'),\n    },\n  },\n  plugins: [\n    // Only run OpenAlex data plugin in production builds, not during tests\n    // ...(mode !== 'test' ? [openalexDataPlugin()] : []), // Temporarily disabled during monorepo refactoring\n    // Temporarily disable devtools to avoid port conflicts\n    // devtools(),\n    TanStackRouterVite({\n      // Enable hash-based routing for GitHub Pages compatibility\n      routeFilePrefix: '',\n      routeFileIgnorePrefix: '-',\n      routesDirectory: './src/routes',\n      generatedRouteTree: './src/routeTree.gen.ts',\n    }),\n    vanillaExtractPlugin(),\n    react(),\n    VitePWA({\n      registerType: 'autoUpdate',\n      workbox: {\n        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],\n        runtimeCaching: [\n          {\n            urlPattern: /^https:\\/\\/api\\.openalex\\.org\\/.*/,\n            handler: 'CacheFirst',\n            options: {\n              cacheName: 'openalex-api-cache',\n              cacheableResponse: {\n                statuses: [0, 200]\n              },\n              expiration: {\n                maxEntries: 1000,\n                maxAgeSeconds: 60 * 60 * 24 * 7 // 7 days\n              }\n            }\n          }\n        ]\n      },\n      manifest: {\n        name: 'Academic Explorer',\n        short_name: 'AcademicExplorer',\n        description: 'Explore academic literature through the OpenAlex API with interactive visualizations',\n        theme_color: '#228be6',\n        background_color: '#ffffff',\n        display: 'standalone',\n        orientation: 'portrait-primary',\n        scope: './',\n        start_url: './',\n        icons: [\n          {\n            src: 'pwa-192x192.svg',\n            sizes: '192x192',\n            type: 'image/svg+xml'\n          },\n          {\n            src: 'pwa-512x512.svg',\n            sizes: '512x512',\n            type: 'image/svg+xml'\n          },\n          {\n            src: 'pwa-512x512.svg',\n            sizes: '512x512',\n            type: 'image/svg+xml',\n            purpose: 'any maskable'\n          }\n        ]\n      }\n    }),\n  ],\n  // Configure for hash-based routing deployment\n  base: './',\n  server: {\n    port: 5173,\n    strictPort: true, // Fail if port is already in use instead of trying another port\n    hmr: {\n      overlay: false\n    }\n  },\n  preview: {\n    port: 4173,\n    strictPort: true, // Fail if port is already in use instead of trying another port\n  },\n  define: {\n    __DEV__: JSON.stringify(true),\n    __BUILD_INFO__: JSON.stringify(getBuildInfo()),\n  },\n  worker: {\n    format: 'es', // Enable ES module format for workers\n  },\n  test: {\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    watch: false,\n    reporters: [\n      [\n        'default',\n        {\n          summary: false\n        }\n      ]\n    ],\n    coverage: {\n      enabled: true,\n      provider: 'v8',\n      reporter: ['text', 'json', 'html', 'lcov'],\n      exclude: [\n        'node_modules/**',\n        'dist/**',\n        'coverage/**',\n        '**/*.d.ts',\n        '**/*.config.ts',\n        '**/*.config.js',\n        '**/test/**',\n        '**/tests/**',\n        '**/__tests__/**',\n        '**/*.test.{ts,tsx,js,jsx}',\n        '**/*.spec.{ts,tsx,js,jsx}',\n        'src/routeTree.gen.ts',\n        'src/test/**',\n        '**/vite.config.ts',\n        '**/vitest.config.ts',\n        '**/vitest.workspace.ts',\n        '**/.eslintrc.{js,cjs}',\n        '**/eslint.config.{js,ts}',\n      ],\n      thresholds: {\n        global: {\n          branches: 75,\n          functions: 80,\n          lines: 80,\n          statements: 80,\n        },\n        perFile: true,\n        skipFull: false,\n        autoUpdate: false,\n        './packages/shared-utils/src/graph/graph-utilities-service.ts': {\n          branches: 0,\n          functions: 0,\n          lines: 0,\n          statements: 0,\n        },\n        './src/hooks/use-graph-utilities.ts': {\n          branches: 0,\n          functions: 0,\n          lines: 0,\n          statements: 0,\n        },\n      },\n    },\n    projects: [\n      {\n        resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n      '@academic-explorer/utils': path.resolve(workspaceRoot, 'packages/utils/src'),\n      '@academic-explorer/client': path.resolve(workspaceRoot, 'packages/client/src'),\n      '@academic-explorer/ui': path.resolve(workspaceRoot, 'packages/ui/src'),\n      '@academic-explorer/graph': path.resolve(workspaceRoot, 'packages/graph/src'),\n      '@academic-explorer/simulation': path.resolve(workspaceRoot, 'packages/simulation/src'),\n    },\n  },\n        test: {\n          name: 'unit',\n          include: ['src/**/*.unit.test.ts'],\n          environment: 'jsdom',\n          testTimeout: 30000,\n        },\n      },\n      {\n        resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n      '@academic-explorer/utils': path.resolve(workspaceRoot, 'packages/utils/src'),\n      '@academic-explorer/client': path.resolve(workspaceRoot, 'packages/client/src'),\n      '@academic-explorer/ui': path.resolve(workspaceRoot, 'packages/ui/src'),\n      '@academic-explorer/graph': path.resolve(workspaceRoot, 'packages/graph/src'),\n      '@academic-explorer/simulation': path.resolve(workspaceRoot, 'packages/simulation/src'),\n    },\n  },\n        test: {\n          name: 'component',\n          include: ['src/**/*.component.test.ts', 'src/**/*.component.test.tsx'],\n          environment: 'jsdom',\n          setupFiles: ['./src/test/setup.ts', './src/test/component-setup.ts'],\n          testTimeout: 30000,\n        },\n      },\n      {\n        resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n      '@academic-explorer/utils': path.resolve(workspaceRoot, 'packages/utils/src'),\n      '@academic-explorer/client': path.resolve(workspaceRoot, 'packages/client/src'),\n      '@academic-explorer/ui': path.resolve(workspaceRoot, 'packages/ui/src'),\n      '@academic-explorer/graph': path.resolve(workspaceRoot, 'packages/graph/src'),\n      '@academic-explorer/simulation': path.resolve(workspaceRoot, 'packages/simulation/src'),\n    },\n  },\n        test: {\n          name: 'integration',\n          include: ['src/**/*.integration.test.ts'],\n          environment: 'node',\n          testTimeout: 45000,\n        },\n      },\n      {\n        resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n      '@academic-explorer/utils': path.resolve(workspaceRoot, 'packages/utils/src'),\n      '@academic-explorer/client': path.resolve(workspaceRoot, 'packages/client/src'),\n      '@academic-explorer/ui': path.resolve(workspaceRoot, 'packages/ui/src'),\n      '@academic-explorer/graph': path.resolve(workspaceRoot, 'packages/graph/src'),\n      '@academic-explorer/simulation': path.resolve(workspaceRoot, 'packages/simulation/src'),\n    },\n  },\n        test: {\n          name: 'e2e',\n          include: ['src/**/*.e2e.test.ts'],\n          environment: 'node',\n          testTimeout: 90000,\n          setupFiles: ['./src/test/setup.ts', './src/test/e2e-setup.ts'],\n          // Serial execution for memory efficiency\n          maxConcurrency: 1,\n          pool: 'forks',\n          poolOptions: {\n            forks: {\n              singleFork: true,\n            },\n          },\n        },\n      },\n    ],\n  },\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          // Core React and routing\n          'vendor-react': ['react', 'react-dom'],\n          'vendor-router': ['@tanstack/react-router'],\n\n          // TanStack suite\n          'vendor-tanstack': [\n            '@tanstack/react-query',\n            '@tanstack/react-table',\n            '@tanstack/react-devtools',\n            '@tanstack/react-query-devtools',\n            '@tanstack/react-router-devtools'\n          ],\n\n          // Mantine UI suite\n          'vendor-mantine': [\n            '@mantine/core',\n            '@mantine/hooks',\n            '@mantine/notifications',\n            '@mantine/dates',\n            '@mantine/spotlight'\n          ],\n\n          // Graph visualization (route-specific)\n          'vendor-xyflow': ['@xyflow/react'],\n\n          // Icons and utilities\n          'vendor-icons': ['@tabler/icons-react'],\n          'vendor-utils': ['zustand']\n        }\n      }\n    },\n    // Increase chunk size warning threshold since we're now splitting properly\n    chunkSizeWarningLimit: 800\n  },\n}))","usedDeprecatedRules":[]},{"filePath":"/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
/Users/joe/Documents/Research/PhD/Academic Explorer/apps/web:
 ERR_PNPM_RECURSIVE_RUN_FIRST_FAIL  @academic-explorer/web@8.1.0 lint: `eslint . --format=json`
Exit status 1
